abc.sh:1:gcc ziplist.c  -DREDIS_TEST -std=c99 zmalloc.c sds.c endianconv.c util.c  -DZIPLIST_TEST  adlist.c sha1.c -g -o ziplist.out
adlist.c:3: * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
adlist.c:311: * where 0 is the head, 1 is the element next to head
adlist.c:313: * from the tail, -1 is the last element, -2 the penultimate
adlist.c:319:        index = (-index)-1;
adlist.c:333:    if (listLength(list) <= 1) return;
adlist.h:3: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
adlist.h:93:#define AL_START_TAIL 1
ae.c:5: * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
ae.c:76:    eventLoop->maxfd = -1;
ae.c:80:    if (aeApiCreate(eventLoop) == -1) goto err;
ae.c:113:    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;
ae.c:121:    for (i = eventLoop->maxfd+1; i < setsize; i++)
ae.c:134:    eventLoop->stop = 1;
ae.c:146:    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
ae.c:173:        for (j = eventLoop->maxfd-1; j >= 0; j--)
ae.c:192:    *milliseconds = tv.tv_usec/1000;
ae.c:199:    when_sec = cur_sec + milliseconds/1000;
ae.c:200:    when_ms = cur_ms + milliseconds%1000;
ae.c:201:    if (when_ms >= 1000) {
ae.c:203:        when_ms -= 1000;
ae.c:252: * 1) Insert the event in order, so that the nearest is just the head.
ae.c:254: * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).
ae.c:296:    maxId = eventLoop->timeEventNextId-1;
ae.c:371:    if (eventLoop->maxfd != -1 ||
ae.c:388:                (shortest->when_sec - now_sec)*1000 +
ae.c:392:                tvp->tv_sec = ms/1000;
ae.c:393:                tvp->tv_usec = (ms % 1000)*1000;
ae.c:488:    if ((retval = poll(&pfd, 1, milliseconds))== 1) {
ae_epoll.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
ae_epoll.c:42:    if (!state) return -1;
ae_epoll.c:46:        return -1;
ae_epoll.c:48:    state->epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
ae_epoll.c:49:    if (state->epfd == -1) {
ae_epoll.c:52:        return -1;
ae_epoll.c:86:    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
ae_epoll.c:114:            tvp ? (tvp->tv_sec*1000 + tvp->tv_usec/1000) : -1);
ae_evport.c:3: * Copyright (c) 2012, Joyent, Inc. All rights reserved.
ae_evport.c:45: * systems since Solaris 10.  Using the event port interface, we associate file
ae_evport.c:66:#define MAX_EVENT_BATCHSZ 512
ae_evport.c:78:    if (!state) return -1;
ae_evport.c:81:    if (state->portfd == -1) {
ae_evport.c:83:        return -1;
ae_evport.c:89:        state->pending_fds[i] = -1;
ae_evport.c:117:    return (-1);
ae_evport.c:142:    if (rv == -1) {
ae_evport.c:167:    if (pfd != -1) {
ae_evport.c:192:    if (pfd != -1) {
ae_evport.c:204:            state->pending_fds[pfd] = -1;
ae_evport.c:256:        if (state->pending_fds[i] == -1)
ae_evport.c:267:        state->pending_fds[i] = -1;
ae_evport.c:274:        timeout.tv_nsec = tvp->tv_usec * 1000;
ae_evport.c:284:    nevents = 1;
ae_evport.c:286:        tsp) == -1 && (errno != ETIME || nevents == 0)) {
ae.h:5: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
ae.h:39:#define AE_ERR -1
ae.h:42:#define AE_READABLE 1   /* Fire when descriptor is readable. */
ae.h:50:#define AE_FILE_EVENTS 1
ae.h:56:#define AE_NOMORE -1
ae.h:57:#define AE_DELETED_EVENT_ID -1
ae_kqueue.c:44:    if (!state) return -1;
ae_kqueue.c:48:        return -1;
ae_kqueue.c:51:    if (state->kqfd == -1) {
ae_kqueue.c:54:        return -1;
ae_kqueue.c:81:        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
ae_kqueue.c:85:        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
ae_kqueue.c:96:        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
ae_kqueue.c:100:        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
ae_kqueue.c:111:        timeout.tv_nsec = tvp->tv_usec * 1000;
ae_select.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
ae_select.c:45:    if (!state) return -1;
ae_select.c:54:    if (setsize >= FD_SETSIZE) return -1;
ae_select.c:84:    retval = select(eventLoop->maxfd+1,
anet.c:3: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
anet.c:67:    if ((flags = fcntl(fd, F_GETFL)) == -1) {
anet.c:77:    if (fcntl(fd, F_SETFL, flags) == -1) {
anet.c:85:    return anetSetBlock(err,fd,1);
anet.c:97:    int val = 1;
anet.c:99:    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)
anet.c:121:    if (val == 0) val = 1;
anet.c:143:    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)
anet.c:153:    return anetSetTcpNoDelay(err, fd, 1);
anet.c:164:    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffsize, sizeof(buffsize)) == -1)
anet.c:174:    int yes = 1;
anet.c:175:    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) == -1) {
anet.c:187:    tv.tv_sec = ms/1000;
anet.c:188:    tv.tv_usec = (ms%1000)*1000;
anet.c:189:    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
anet.c:239:    int yes = 1;
anet.c:242:    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {
anet.c:251:    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {
anet.c:266:#define ANET_CONNECT_NONBLOCK 1
anet.c:272:    char portstr[6];  /* strlen("65535") + 1; */
anet.c:288:        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
anet.c:302:                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {
anet.c:303:                    bound = 1;
anet.c:313:        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {
anet.c:381:    strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
anet.c:388:    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
anet.c:418:        if (nread == -1) return -1;
anet.c:433:        if (nwritten == -1) return -1;
anet.c:441:    if (bind(s,sa,len) == -1) {
anet.c:447:    if (listen(s, backlog) == -1) {
anet.c:456:    int yes = 1;
anet.c:457:    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {
anet.c:467:    int s = -1, rv;
anet.c:482:        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
anet.c:496:    if (s != -1) close(s);
anet.c:523:    strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
anet.c:533:    while(1) {
anet.c:535:        if (fd == -1) {
anet.c:552:    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
anet.c:571:    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
anet.c:581:    if (getpeername(fd,(struct sockaddr*)&sa,&salen) == -1) goto error;
anet.c:604:            ip[1] = '\0';
anet.c:605:        } else if (ip_len == 1) {
anet.c:610:    return -1;
anet.c:634:    if (getsockname(fd,(struct sockaddr*)&sa,&salen) == -1) {
anet.c:637:        ip[1] = '\0';
anet.c:638:        return -1;
anet.h:3: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
anet.h:37:#define ANET_ERR -1
anet.h:42:#define ANET_IP_ONLY (1<<0)
aof.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
aof.c:60:#define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    /* 10 MB per block */
aof.c:104:    while(1) {
aof.c:151:            /* Log every time we cross more 10 or 100 blocks, respectively
aof.c:154:            if (((numblocks+1) % 10) == 0) {
aof.c:155:                int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
aof.c:158:                    aofRewriteBufferSize()/(1024*1024));
aof.c:172: * fd. If a short write or any other error happens -1 is returned,
aof.c:188:                return -1;
aof.c:216:    if (server.aof_child_pid == -1) return;
aof.c:220:    if (kill(server.aof_child_pid,SIGUSR1) != -1) {
aof.c:226:    server.aof_child_pid = -1;
aof.c:227:    server.aof_rewrite_time_start = -1;
aof.c:236:    flushAppendOnlyFile(1);
aof.c:240:    server.aof_fd = -1;
aof.c:241:    server.aof_selected_db = -1;
aof.c:254:    if (newfd == -1) {
aof.c:265:    if (server.rdb_child_pid != -1) {
aof.c:266:        server.aof_rewrite_scheduled = 1;
aof.c:272:        if (server.aof_child_pid != -1) {
aof.c:307:            return totwritten ? totwritten : -1;
aof.c:334: * However if force is set to 1 we'll write regardless of the background
aof.c:398:    } else if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
aof.c:412:        /* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */
aof.c:414:            can_log = 1;
aof.c:419:        if (nwritten == -1) {
aof.c:434:            if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
aof.c:443:                 * -1 since there is no longer partial data into the AOF. */
aof.c:444:                nwritten = -1;
aof.c:456:            exit(1);
aof.c:467:                sdsrange(server.aof_buf,nwritten,-1);
aof.c:495:        (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
aof.c:524:    len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
aof.c:532:        len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
aof.c:556:    when = strtoll(seconds->ptr,NULL,10);
aof.c:561:        when *= 1000;
aof.c:572:    argv[1] = key;
aof.c:598:        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
aof.c:602:        tmpargv[1] = argv[1];
aof.c:606:        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
aof.c:613:            if (!strcasecmp(argv[i]->ptr, "ex")) exarg = argv[i+1];
aof.c:614:            if (!strcasecmp(argv[i]->ptr, "px")) pxarg = argv[i+1];
aof.c:618:            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
aof.c:621:            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
aof.c:640:    if (server.aof_child_pid != -1)
aof.c:656:    c->fd = -1;
aof.c:709:        exit(1);
aof.c:716:    if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
aof.c:733:    if (fread(sig,1,5,fp) != 5 || memcmp(sig,"REDIS",5) != 0) {
aof.c:735:        if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
aof.c:741:        if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
aof.c:743:        if (rdbLoadRio(&rdb,NULL,1) != C_OK) {
aof.c:752:    while(1) {
aof.c:756:        char buf[128];
aof.c:761:        if (!(loops++ % 1000)) {
aof.c:773:        if (buf[1] == '\0') goto readerr;
aof.c:774:        argc = atoi(buf+1);
aof.c:775:        if (argc < 1) goto fmterr;
aof.c:783:                fakeClient->argc = j; /* Free up to j-1. */
aof.c:788:            len = strtol(buf+1,NULL,10);
aof.c:790:            if (len && fread(argsds,len,1,fp) == 0) {
aof.c:792:                fakeClient->argc = j; /* Free up to j-1. */
aof.c:797:            if (fread(buf,2,1,fp) == 0) {
aof.c:798:                fakeClient->argc = j+1; /* Free up to j. */
aof.c:810:            exit(1);
aof.c:864:        exit(1);
aof.c:872:        if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
aof.c:873:            if (valid_up_to == -1) {
aof.c:882:            if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {
aof.c:893:    serverLog(LL_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
aof.c:894:    exit(1);
aof.c:899:    exit(1);
aof.c:921: * The function returns 0 on error, 1 on success. */
aof.c:951:    return 1;
aof.c:955: * The function returns 0 on error, 1 on success. */
aof.c:998:    return 1;
aof.c:1002: * The function returns 0 on error, 1 on success. */
aof.c:1067:    return 1;
aof.c:1097: * The function returns 0 on error, 1 on success. */
aof.c:1121:    return 1;
aof.c:1144:    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
aof.c:1149:    if (rioWriteBulkString(r,"0",1) == 0) return 0;
aof.c:1153:    if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
aof.c:1157:    return 1;
aof.c:1161: * The function returns 0 on error, 1 on success. */
aof.c:1196:        if (rioWriteBulkString(r,"0",1) == 0) return 0;
aof.c:1198:        if (rioWriteBulkString(r,"x",1) == 0) return 0;
aof.c:1199:        if (rioWriteBulkString(r,"y",1) == 0) return 0;
aof.c:1255:    return 1;
aof.c:1260: * The function returns 0 on error, 1 on success. */
aof.c:1271:    return io.error ? 0 : 1;
aof.c:1303:        if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
aof.c:1322:                if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
aof.c:1342:            if (expiretime != -1) {
aof.c:1344:                if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
aof.c:1405:    if (fsync(fileno(fp)) == -1) goto werr;
aof.c:1415:    while(mstime()-start < 1000 && nodata < 20) {
aof.c:1416:        if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) <= 0)
aof.c:1427:    if (write(server.aof_pipe_write_ack_to_parent,"!",1) != 1) goto werr;
aof.c:1430:    /* We read the ACK from the server using a 10 seconds timeout. Normally
aof.c:1433:    if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||
aof.c:1443:        (double) sdslen(server.aof_child_diff) / (1024*1024));
aof.c:1449:    if (fsync(fileno(fp)) == -1) goto werr;
aof.c:1454:    if (rename(tmpfile,filename) == -1) {
aof.c:1482:    if (read(fd,&byte,1) == 1 && byte == '!') {
aof.c:1484:        server.aof_stop_sending_diff = 1;
aof.c:1485:        if (write(server.aof_pipe_write_ack_to_child,"!",1) != 1) {
aof.c:1505:    int fds[6] = {-1, -1, -1, -1, -1, -1};
aof.c:1508:    if (pipe(fds) == -1) goto error; /* parent -> children data. */
aof.c:1509:    if (pipe(fds+2) == -1) goto error; /* children -> parent ack. */
aof.c:1510:    if (pipe(fds+4) == -1) goto error; /* parent -> children ack. */
aof.c:1513:    if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
aof.c:1516:    server.aof_pipe_write_data_to_child = fds[1];
aof.c:1528:    for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
aof.c:1549: * 1) The user calls BGREWRITEAOF
aof.c:1563:    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
aof.c:1575:            size_t private_dirty = zmalloc_get_private_dirty(-1);
aof.c:1580:                    private_dirty/(1024*1024));
aof.c:1587:            exitFromChild(1);
aof.c:1592:        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
aof.c:1593:        latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
aof.c:1594:        if (childpid == -1) {
aof.c:1608:        /* We set appendseldb to -1 in order to force the next call to the
aof.c:1612:        server.aof_selected_db = -1;
aof.c:1620:    if (server.aof_child_pid != -1) {
aof.c:1622:    } else if (server.rdb_child_pid != -1) {
aof.c:1623:        server.aof_rewrite_scheduled = 1;
aof.c:1648:    if (redis_fstat(server.aof_fd,&sb) == -1) {
aof.c:1676:        if (newfd == -1) {
aof.c:1682:        if (aofRewriteBufferWrite(newfd) == -1) {
aof.c:1692:            "Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)", (double) aofRewriteBufferSize() / (1024*1024));
aof.c:1701:         * 1) AOF is DISABLED and this was a one time rewrite. The temporary
aof.c:1713:         * caused by rename(2) in scenario 1, or by close(2) in scenario 2), we
aof.c:1715:         * make scenario 1 identical to scenario 2 by opening the target file
aof.c:1721:        if (server.aof_fd == -1) {
aof.c:1724:            /* Don't care if this fails: oldfd will be -1 and we handle that.
aof.c:1725:             * One notable case of -1 return is if the old file does
aof.c:1730:            oldfd = -1; /* We'll set this to the current AOF filedes later. */
aof.c:1736:        if (rename(tmpfile,server.aof_filename) == -1) {
aof.c:1743:            if (oldfd != -1) close(oldfd);
aof.c:1749:        if (server.aof_fd == -1) {
aof.c:1761:            server.aof_selected_db = -1; /* Make sure SELECT is re-issued */
aof.c:1780:        if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
aof.c:1785:        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
aof.c:1787:        if (bysignal != SIGUSR1)
aof.c:1802:    server.aof_child_pid = -1;
aof.c:1804:    server.aof_rewrite_time_start = -1;
aof.c:1807:        server.aof_rewrite_scheduled = 1;
匹配到二进制文件 a.out
asciilogo.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
atomicvar.h:17: *  atomicSet(myvar,12345);
atomicvar.h:27: *  atomicGetIncr(myvar,oldvalue,1);
atomicvar.h:32: * Copyright (c) 2015, Salvatore Sanfilippo <antirez at gmail dot com>
atomicvar.h:71:#if !defined(__ATOMIC_VAR_FORCE_SYNC_MACROS) && defined(__ATOMIC_RELAXED) && !defined(__sun) && (!defined(__clang__) || !defined(__APPLE__) || __apple_build_version__ > 4210057)
bio.c:32: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
bio.c:83:    void *arg1, *arg2, *arg3;
bio.c:88:void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2);
bio.c:93:#define REDIS_THREAD_STACK_SIZE (1024*1024*4)
bio.c:114:    if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */
bio.c:125:            exit(1);
bio.c:131:void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
bio.c:135:    job->arg1 = arg1;
bio.c:171:    while(1) {
bio.c:188:            close((long)job->arg1);
bio.c:190:            redis_fsync((long)job->arg1);
bio.c:193:             * arg1 -> free the object at pointer.
bio.c:196:            if (job->arg1)
bio.c:197:                lazyfreeFreeObjectFromBioThread(job->arg1);
bio.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
bio.h:32:void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);
bio.h:40:#define BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
bitops.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
bitops.c:39: * work with a input string length up to 512 MB. */
bitops.c:44:    static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};
bitops.c:55:        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;
bitops.c:57:        aux1 = *p4++;
bitops.c:66:        aux1 = aux1 - ((aux1 >> 1) & 0x55555555);
bitops.c:67:        aux1 = (aux1 & 0x33333333) + ((aux1 >> 2) & 0x33333333);
bitops.c:68:        aux2 = aux2 - ((aux2 >> 1) & 0x55555555);
bitops.c:70:        aux3 = aux3 - ((aux3 >> 1) & 0x55555555);
bitops.c:72:        aux4 = aux4 - ((aux4 >> 1) & 0x55555555);
bitops.c:74:        aux5 = aux5 - ((aux5 >> 1) & 0x55555555);
bitops.c:76:        aux6 = aux6 - ((aux6 >> 1) & 0x55555555);
bitops.c:78:        aux7 = aux7 - ((aux7 >> 1) & 0x55555555);
bitops.c:80:        bits += ((((aux1 + (aux1 >> 4)) & 0x0F0F0F0F) +
bitops.c:86:                    ((aux7 + (aux7 >> 4)) & 0x0F0F0F0F))* 0x01010101) >> 24;
bitops.c:94:/* Return the position of the first bit set to one (if 'bit' is 1) or
bitops.c:99: * padded on the right. However if 'bit' is 1 it is possible that there is
bitops.c:100: * not a single set bit in the bitmap. In this special case -1 is returned. */
bitops.c:112:     * blocks of 1 or 0 bits compared to the vanilla bit per bit processing.
bitops.c:122:    while((unsigned long)c & (sizeof(*l)-1) && count) {
bitops.c:124:            found = 1;
bitops.c:163:     * return -1 to signal that there is not a single "1" in the whole
bitops.c:166:    if (bit == 1 && word == 0) return -1;
bitops.c:169:     * have a single "1" set in the most significant position in an
bitops.c:172:    one = ULONG_MAX; /* All bits set to 1.*/
bitops.c:173:    one >>= 1;       /* All bits set to 1 but the MSB. */
bitops.c:179:        one >>= 1;
bitops.c:198: * |00000001|01110000|
bitops.c:213:        bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
bitops.c:217:        byteval &= ~(1 << bit);
bitops.c:225:    uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
bitops.c:236:        bitval = (byteval >> bit) & 1;
bitops.c:237:        value = (value<<1) | bitval;
bitops.c:257:    /* If the top significant bit is 1, propagate it to all the
bitops.c:260:    if (value & ((uint64_t)1 << (bits-1)))
bitops.c:261:        value |= ((uint64_t)-1) << bits;
bitops.c:269: * then zero is returned, otherwise in case of overflow, 1 is returned,
bitops.c:270: * otherwise in case of underflow, -1 is returned.
bitops.c:276: * For BFOVERFLOW_SAT if 1 is returned, *limit it is set maximum value that
bitops.c:277: * you can store in that integer. when -1 is returned, *limit is set to the
bitops.c:285:#define BFOVERFLOW_SAT 1
bitops.c:289:    uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
bitops.c:301:        return 1;
bitops.c:310:        return -1;
bitops.c:316:        uint64_t mask = ((uint64_t)-1) << bits;
bitops.c:322:    return 1;
bitops.c:326:    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
bitops.c:327:    int64_t min = (-max)-1;
bitops.c:344:        return 1;
bitops.c:353:        return -1;
bitops.c:359:        uint64_t mask = ((uint64_t)-1) << bits;
bitops.c:360:        uint64_t msb = (uint64_t)1 << (bits-1);
bitops.c:374:    return 1;
bitops.c:385:            printf("%c", (byte & i) ? '1' : '0');
bitops.c:396:#define BITOP_OR    1
bitops.c:401:#define BITFIELDOP_SET 1
bitops.c:406: * Redis 512 MB limit for the string value.
bitops.c:419:    if (p[0] == '#' && hash && bits > 0) usehash = 1;
bitops.c:429:    /* Limit offset to 512MB in bytes */
bitops.c:430:    if ((loffset < 0) || ((unsigned long long)loffset >> 3) >= (512*1024*1024))
bitops.c:442: * the bits is a value between 1 and 64. However 64 bits unsigned integers
bitops.c:449:    char *err = "Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is.";
bitops.c:453:        *sign = 1;
bitops.c:461:    if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
bitops.c:462:        llbits < 1 ||
bitops.c:463:        (*sign == 1 && llbits > 64) ||
bitops.c:480:    robj *o = lookupKeyWrite(c->db,c->argv[1]);
bitops.c:483:        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
bitops.c:484:        dbAdd(c->db,c->argv[1],o);
bitops.c:487:        o = dbUnshareStringValue(c->db,c->argv[1],o);
bitops.c:488:        o->ptr = sdsgrowzero(o->ptr,byte+1);
bitops.c:540:    if (on & ~1) {
bitops.c:551:    bitval = byteval & (1 << bit);
bitops.c:554:    byteval &= ~(1 << bit);
bitops.c:555:    byteval |= ((on & 0x1) << bit);
bitops.c:557:    signalModifiedKey(c->db,c->argv[1]);
bitops.c:558:    notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
bitops.c:574:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
bitops.c:581:            bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
bitops.c:584:            bitval = llbuf[byte] & (1 << bit);
bitops.c:590:/* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */
bitops.c:592:    char *opname = c->argv[1]->ptr;
bitops.c:669:        if (minlen >= sizeof(unsigned long)*4 && numkeys <= 16) {
bitops.c:670:            unsigned long *lp[16];
bitops.c:680:                    for (i = 1; i < numkeys; i++) {
bitops.c:682:                        lres[1] &= lp[i][1];
bitops.c:693:                    for (i = 1; i < numkeys; i++) {
bitops.c:695:                        lres[1] |= lp[i][1];
bitops.c:706:                    for (i = 1; i < numkeys; i++) {
bitops.c:708:                        lres[1] ^= lp[i][1];
bitops.c:720:                    lres[1] = ~lres[1];
bitops.c:735:            for (i = 1; i < numkeys; i++) {
bitops.c:776:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
bitops.c:795:        if (end >= strlen) end = strlen-1;
bitops.c:799:        end = strlen-1;
bitops.c:811:        long bytes = end-start+1;
bitops.c:829:    if (bit != 0 && bit != 1) {
bitops.c:830:        addReplyError(c, "The bit argument must be 1 or 0.");
bitops.c:836:     * If the user is looking for the first set bit, return -1. */
bitops.c:837:    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
bitops.c:838:        addReplyLongLong(c, bit ? -1 : 0);
bitops.c:851:            end_given = 1;
bitops.c:853:            end = strlen-1;
bitops.c:860:        if (end >= strlen) end = strlen-1;
bitops.c:864:        end = strlen-1;
bitops.c:871:    /* For empty ranges (start > end) we return -1 as an empty range does
bitops.c:872:     * not contain a 0 nor a 1. */
bitops.c:874:        addReplyLongLong(c, -1);
bitops.c:876:        long bytes = end-start+1;
bitops.c:884:         * we return -1 to the caller, to mean, in the specified range there
bitops.c:887:            addReplyLongLong(c,-1);
bitops.c:890:        if (pos != -1) pos += start*8; /* Adjust for the bytes we skipped. */
bitops.c:895:/* BITFIELD key subcommmand-1 arg ... subcommand-2 arg ... subcommand-N ...
bitops.c:920:    int readonly = 1;
bitops.c:924:        int remargs = c->argc-j-1; /* Remaining args other than current. */
bitops.c:937:        else if (!strcasecmp(subcmd,"overflow") && remargs >= 1) {
bitops.c:938:            char *owtypename = c->argv[j+1]->ptr;
bitops.c:959:        if (getBitfieldTypeFromArgument(c,c->argv[j+1],&sign,&bits) != C_OK) {
bitops.c:964:        if (getBitOffsetFromArgument(c,c->argv[j+2],&bitoffset,1,bits) != C_OK){
bitops.c:971:            if (highest_write_offset < bitoffset + bits - 1)
bitops.c:972:                highest_write_offset = bitoffset + bits - 1;
bitops.c:981:        ops = zrealloc(ops,sizeof(*ops)*(numops+1));
bitops.c:996:        o = lookupKeyRead(c->db,c->argv[1]);
bitops.c:1126:        signalModifiedKey(c->db,c->argv[1]);
bitops.c:1127:        notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
blocked.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
blocked.c:41: * 1) It calls the btype-specific function to cleanup the state.
blocked.c:91:        if (unit == UNIT_SECONDS) tval *= 1000;
blocked.c:141: * 1. When a client is blocked, its readable handler is still active.
blocked.c:355:                        genericZpopCommand(receiver,&rl->key,1,where,1,NULL);
blocked.c:364:                        argv[1] = rl->key;
blocked.c:369:                        decrRefCount(argv[1]);
blocked.c:431:                                           1);
blocked.c:439:                            addReplyMultiBulkLen(receiver,1);
blocked.c:602:     * to avoid adding it multiple times into a list with a simple O(1)
childinfo.c:2: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
childinfo.c:37:    if (pipe(server.child_info_pipe) == -1) {
childinfo.c:38:        /* On error our two file descriptors should be still set to -1,
childinfo.c:50:    if (server.child_info_pipe[0] != -1 ||
childinfo.c:51:        server.child_info_pipe[1] != -1)
childinfo.c:54:        close(server.child_info_pipe[1]);
childinfo.c:55:        server.child_info_pipe[0] = -1;
childinfo.c:56:        server.child_info_pipe[1] = -1;
childinfo.c:63:    if (server.child_info_pipe[1] == -1) return;
childinfo.c:67:    if (write(server.child_info_pipe[1],&server.child_info_data,wlen) != wlen) {
childinfo.c:74:    if (server.child_info_pipe[0] == -1) return;
cluster.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
cluster.c:75:sds representClusterNodeFlags(sds ci, uint16_t flags);
cluster.c:103:            exit(1);
cluster.c:109:    if (fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
cluster.c:120:     * To simplify we allocate 1024+CLUSTER_SLOTS*128 bytes per line. */
cluster.c:121:    maxline = 1024+CLUSTER_SLOTS*128;
cluster.c:141:            for (j = 1; j < argc; j += 2) {
cluster.c:144:                            strtoull(argv[j+1],NULL,10);
cluster.c:147:                            strtoull(argv[j+1],NULL,10);
cluster.c:168:        if ((p = strrchr(argv[1],':')) == NULL) goto fmterr;
cluster.c:170:        memcpy(n->ip,argv[1],strlen(argv[1])+1);
cluster.c:171:        char *port = p+1;
cluster.c:179:         * In this case we set it to the default offset of 10000 from the
cluster.c:212:            if (p) s = p+1;
cluster.c:232:        n->configEpoch = strtoull(argv[6],NULL,10);
cluster.c:247:                direction = p[1]; /* Either '>' or '<' */
cluster.c:248:                slot = atoi(argv[j]+1);
cluster.c:265:                stop = atoi(p+1);
cluster.c:297:    exit(1);
cluster.c:302: * This function writes the node config and returns 0, on error -1
cluster.c:329:        == -1) goto err;
cluster.c:332:    if (fstat(fd,&sb) != -1) {
cluster.c:346:    if (content_size != sdslen(ci) && ftruncate(fd,content_size) == -1) {
cluster.c:354:    if (fd != -1) close(fd);
cluster.c:356:    return -1;
cluster.c:360:    if (clusterSaveConfig(do_fsync) == -1) {
cluster.c:362:        exit(1);
cluster.c:385:    if (fd == -1) {
cluster.c:392:    if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
cluster.c:436:    server.cluster->size = 1;
cluster.c:458:        exit(1);
cluster.c:469:        saveconf = 1;
cluster.c:471:    if (saveconf) clusterSaveConfigOrDie(1);
cluster.c:481:                   "Cluster communication port is 10,000 port "
cluster.c:485:        exit(1);
cluster.c:491:        exit(1);
cluster.c:524: * 1) All other nodes are forget.
cluster.c:540:        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
cluster.c:595:    link->fd = -1;
cluster.c:603:    if (link->fd != -1) {
cluster.c:614:#define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
cluster.c:656:/* We have 16384 hash slots. The hash slot of a given key is obtained
cluster.c:657: * as the least significant 14 bits of the crc16 of the key.
cluster.c:669:    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
cluster.c:672:    for (e = s+1; e < keylen; e++)
cluster.c:676:    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
cluster.c:680:    return crc16(key+s+1,e-s-1) & 0x3FFF;
cluster.c:732: * failure report from the same sender. 1 is returned if a new failure
cluster.c:758:    return 1;
cluster.c:791: * The function returns 1 if the failure report was found and removed.
cluster.c:810:    return 1;
cluster.c:826:            if ((j+1) < master->numslaves) {
cluster.c:827:                int remaining_slaves = (master->numslaves - j) - 1;
cluster.c:828:                memmove(master->slaves+j,master->slaves+(j+1),
cluster.c:847:        sizeof(clusterNode*)*(master->numslaves+1));
cluster.c:900: * 1) Mark all the slots handled by it as unassigned.
cluster.c:912:    /* 1) Mark slots as unassigned. */
cluster.c:988: * 1) Generate a new config epoch, incrementing the current epoch.
cluster.c:1002: * 1) When slots are closed after importing. Otherwise resharding would be
cluster.c:1073: * the greatest configuration epoch currently detected among nodes plus 1.
cluster.c:1089:    clusterSaveConfigOrDie(1);
cluster.c:1109: * Currently the CLUSTER_BLACKLIST_TTL is set to 1 minute, this means
cluster.c:1119:#define CLUSTER_BLACKLIST_TTL 60      /* 1 minute. */
cluster.c:1178: * 1) We received enough failure reports from other master nodes via gossip.
cluster.c:1191: * 1) Either we reach the majority and eventually the FAIL state will propagate
cluster.c:1199:    int needed_quorum = (server.cluster->size / 2) + 1;
cluster.c:1243:     * 1) The FAIL state is old enough.
cluster.c:1335:    return 1;
cluster.c:1343:    uint16_t count = ntohs(hdr->count);
cluster.c:1348:        uint16_t flags = ntohs(g->flags);
cluster.c:1394:                pongtime *= 1000; /* Convert back to milliseconds. */
cluster.c:1451:        buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
cluster.c:1468: * otherwise 1 is returned. */
cluster.c:1501:    return 1;
cluster.c:1544:    uint16_t dirty_slots[CLUSTER_SLOTS];
cluster.c:1569:             * 1) The slot was unassigned or the new node claims it with a
cluster.c:1604:     * 1) We are a master left without slots. This means that we were
cluster.c:1635: * The function returns 1 if the link is still valid after the packet
cluster.c:1642:    uint16_t type = ntohs(hdr->type);
cluster.c:1650:    if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
cluster.c:1651:    if (totlen > sdslen(link->rcvbuf)) return 1;
cluster.c:1655:        return 1;
cluster.c:1658:    uint16_t flags = ntohs(hdr->flags);
cluster.c:1665:        uint16_t count = ntohs(hdr->count);
cluster.c:1670:        if (totlen != explen) return 1;
cluster.c:1675:        if (totlen != explen) return 1;
cluster.c:1683:        if (totlen != explen) return 1;
cluster.c:1690:        if (totlen != explen) return 1;
cluster.c:1695:        if (totlen != explen) return 1;
cluster.c:1701:        if (totlen != explen) return 1;
cluster.c:1757:            if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&
cluster.c:1950:        /* 1) If the sender of the message is a master, and we detected that
cluster.c:1965:         * A and B are master and slave for slots 1,2,3.
cluster.c:2056:        if (!sender) return 1;  /* We don't know that node. */
cluster.c:2059:        if (!sender) return 1;  /* We don't know that node. */
cluster.c:2074:        if (!sender || sender->slaveof != myself) return 1;
cluster.c:2088:        if (!sender) return 1;  /* We don't know the sender. */
cluster.c:2090:        if (!n) return 1;   /* We don't know the reported node. */
cluster.c:2091:        if (n->configEpoch >= reportedConfigEpoch) return 1; /* Nothing new. */
cluster.c:2106:        if (!sender) return 1;  /* Protect the module from unknown nodes. */
cluster.c:2117:    return 1;
cluster.c:2142:            (nwritten == -1) ? strerror(errno) : "short write");
cluster.c:2146:    sdsrange(link->sndbuf,nwritten,-1);
cluster.c:2163:    while(1) { /* Read as long as there is data to read. */
cluster.c:2190:        if (nread == -1 && errno == EAGAIN) return; /* No more data ready. */
cluster.c:2231:    uint16_t type = ntohs(hdr->type);
cluster.c:2275:    hdr->sig[1] = 'C';
cluster.c:2287:        hdr->myip[NET_IP_STR_LEN-1] = '\0';
cluster.c:2352:    gossip->ping_sent = htonl(n->ping_sent/1000);
cluster.c:2353:    gossip->pong_received = htonl(n->pong_received/1000);
cluster.c:2358:    gossip->notused1 = 0;
cluster.c:2375:    /* How many gossip sections we want to add? 1/10 of the number of nodes
cluster.c:2376:     * and anyway at least 3. Why 1/10?
cluster.c:2378:     * If we have N masters, with N/10 entries, and we consider that in
cluster.c:2389:     *        which is 1 / NUM_OF_NODES.
cluster.c:2390:     * ENTRIES = 10.
cluster.c:2394:     * is the same), with 1/10 we always get over the majority, and specifically
cluster.c:2400:     * 10% of the total nodes we have. */
cluster.c:2402:    wanted = floor(dictSize(server.cluster->nodes)/10);
cluster.c:2444:         * 1) Nodes in HANDSHAKE state.
cluster.c:2515:#define CLUSTER_BROADCAST_LOCAL_SLAVES 1
cluster.c:2740:    /* IF we are not a master serving at least 1 slot, we don't have the
cluster.c:2743:     * size + 1 */
cluster.c:2877: * 1) The reason for which the failover can't be initiated changed.
cluster.c:2945:    /* 1) Turn this node into a master. */
cluster.c:2959:    clusterSaveConfigOrDie(1);
cluster.c:2973: * 1) To check if we are able to perform a failover, is our data updated?
cluster.c:2984:    int needed_quorum = (server.cluster->size / 2) + 1;
cluster.c:3004:     * 1) We are a slave.
cluster.c:3025:                   * 1000;
cluster.c:3027:        data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;
cluster.c:3045:        (((mstime_t)server.repl_ping_slave_period * 1000) +
cluster.c:3069:         * Specifically 1 second * rank. This way slaves that have a probably
cluster.c:3072:            server.cluster->failover_auth_rank * 1000;
cluster.c:3106:                (newrank - server.cluster->failover_auth_rank) * 1000;
cluster.c:3137:        server.cluster->failover_auth_sent = 1;
cluster.c:3145:    //发起投票后，如果别的几点投票给自己则++auth_cout，如果超过size/2+1则
cluster.c:3179: * 1) We are a slave node.
cluster.c:3200:    /* Step 1: Don't migrate if the cluster state is not ok. */
cluster.c:3225:        int okslaves = 0, is_orphaned = 1;
cluster.c:3283: * 1) User send CLUSTER FAILOVER command. The failover state is initialized
cluster.c:3292: *    mf_can_start is set to 1, and clusterHandleSlaveFailover() will perform
cluster.c:3347:        server.cluster->mf_can_start = 1;
cluster.c:3358:/* This is executed 10 times every second */
cluster.c:3359://100ms执行一次
cluster.c:3382:        if (prev_ip == NULL && curr_ip != NULL) changed = 1;
cluster.c:3383:        else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
cluster.c:3384:        else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;
cluster.c:3396:                myself->ip[NET_IP_STR_LEN-1] = '\0';
cluster.c:3406:     * the value of 1 second. */
cluster.c:3408:    if (handshake_timeout < 1000) handshake_timeout = 1000;
cluster.c:3442:            if (fd == -1) {
cluster.c:3489:    /* Ping some random node 1 time every 10 iterations, so that we usually ping
cluster.c:3491:    //1s执行一次该分支
cluster.c:3492:    if (!(iteration % 10)) {
cluster.c:3519:     * 1) Check if there are orphaned masters (masters without non failing
cluster.c:3576:        //100个节点，timeout=60s。30s就要发送99个ping包。3.3/s个ping包
cluster.c:3611:                update_state = 1;
cluster.c:3683:/* Test bit 'pos' in a generic bitmap. Return 1 if the bit is set,
cluster.c:3688:    return (bitmap[byte] & (1<<bit)) != 0;
cluster.c:3695:    bitmap[byte] |= 1<<bit;
cluster.c:3702:    bitmap[byte] &= ~(1<<bit);
cluster.c:3734:         * 1. The used to have slaves (but no longer have).
cluster.c:3741:        if (n->numslots == 1 && clusterMastersHaveSlaves())
cluster.c:3778:    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
cluster.c:3882:        int needed_quorum = (server.cluster->size / 2) + 1;
cluster.c:3920: * 1) If we find keys about hash slots we have no responsibility for, the
cluster.c:3933: * the error described in "1". However if data is found in DB different
cluster.c:3953:    for (j = 1; j < server.dbnum; j++) {
cluster.c:3984:    if (update_config) clusterSaveConfigOrDie(1);
cluster.c:4017:    uint16_t flag;
cluster.c:4034:sds representClusterNodeFlags(sds ci, uint16_t flags) {
cluster.c:4043:    sdsIncrLen(ci,-1); /* Remove trailing comma. */
cluster.c:4080:    start = -1;
cluster.c:4085:            if (start == -1) start = j;
cluster.c:4087:        if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
cluster.c:4088:            if (bit && j == CLUSTER_SLOTS-1) j++;
cluster.c:4090:            if (start == j-1) {
cluster.c:4093:                ci = sdscatprintf(ci," %d-%d",start,j-1);
cluster.c:4095:            start = -1;
cluster.c:4141:        ci = sdscatlen(ci,"\n",1);
cluster.c:4174:        return -1;
cluster.c:4180:    /* Format: 1) 1) start slot
cluster.c:4182:     *            3) 1) master IP
cluster.c:4185:     *            4) 1) replica IP
cluster.c:4198:        int j = 0, start = -1;
cluster.c:4208:                if (start == -1) start = j;
cluster.c:4210:            if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
cluster.c:4211:                int nested_elements = 3; /* slots (2) + master addr (1). */
cluster.c:4214:                if (bit && j == CLUSTER_SLOTS-1) j++;
cluster.c:4218:                if (start == j-1) {
cluster.c:4223:                    addReplyLongLong(c, j-1);   /* high */
cluster.c:4225:                start = -1;
cluster.c:4259:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
cluster.c:4286:    } else if (!strcasecmp(c->argv[1]->ptr,"meet") && (c->argc == 4 || c->argc == 5)) {
cluster.c:4314:    } else if (!strcasecmp(c->argv[1]->ptr,"nodes") && c->argc == 2) {
cluster.c:4322:    } else if (!strcasecmp(c->argv[1]->ptr,"myid") && c->argc == 2) {
cluster.c:4325:    } else if (!strcasecmp(c->argv[1]->ptr,"slots") && c->argc == 2) {
cluster.c:4328:    } else if (!strcasecmp(c->argv[1]->ptr,"flushslots") && c->argc == 2) {
cluster.c:4337:    } else if ((!strcasecmp(c->argv[1]->ptr,"addslots") ||
cluster.c:4338:               !strcasecmp(c->argv[1]->ptr,"delslots")) && c->argc >= 3)
cluster.c:4345:        int del = !strcasecmp(c->argv[1]->ptr,"delslots");
cluster.c:4351:            if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {
cluster.c:4366:            if (slots[slot]++ == 1) {
cluster.c:4392:    } else if (!strcasecmp(c->argv[1]->ptr,"setslot") && c->argc >= 4) {
cluster.c:4393:        /* SETSLOT 10 MIGRATING <node ID> */
cluster.c:4394:        /* SETSLOT 10 IMPORTING <node ID> */
cluster.c:4395:        /* SETSLOT 10 STABLE */
cluster.c:4396:        /* SETSLOT 10 NODE <node ID> */
cluster.c:4405:        if ((slot = getSlotOrReply(c,c->argv[2])) == -1) return;
cluster.c:4499:    } else if (!strcasecmp(c->argv[1]->ptr,"bumpepoch") && c->argc == 2) {
cluster.c:4506:    } else if (!strcasecmp(c->argv[1]->ptr,"info") && c->argc == 2) {
cluster.c:4582:    } else if (!strcasecmp(c->argv[1]->ptr,"saveconfig") && c->argc == 2) {
cluster.c:4583:        int retval = clusterSaveConfig(1);
cluster.c:4590:    } else if (!strcasecmp(c->argv[1]->ptr,"keyslot") && c->argc == 3) {
cluster.c:4595:    } else if (!strcasecmp(c->argv[1]->ptr,"countkeysinslot") && c->argc == 3) {
cluster.c:4606:    } else if (!strcasecmp(c->argv[1]->ptr,"getkeysinslot") && c->argc == 4) {
cluster.c:4635:    } else if (!strcasecmp(c->argv[1]->ptr,"forget") && c->argc == 3) {
cluster.c:4654:    } else if (!strcasecmp(c->argv[1]->ptr,"replicate") && c->argc == 3) {
cluster.c:4692:    } else if ((!strcasecmp(c->argv[1]->ptr,"slaves") ||
cluster.c:4693:                !strcasecmp(c->argv[1]->ptr,"replicas")) && c->argc == 3) {
cluster.c:4715:    } else if (!strcasecmp(c->argv[1]->ptr,"count-failure-reports") &&
cluster.c:4727:    } else if (!strcasecmp(c->argv[1]->ptr,"failover") &&
cluster.c:4735:                force = 1;
cluster.c:4737:                takeover = 1;
cluster.c:4738:                force = 1; /* Takeover also implies force. */
cluster.c:4776:            server.cluster->mf_can_start = 1;
cluster.c:4782:    } else if (!strcasecmp(c->argv[1]->ptr,"set-config-epoch") && c->argc == 3)
cluster.c:4798:        } else if (dictSize(server.cluster->nodes) > 1) {
cluster.c:4818:    } else if (!strcasecmp(c->argv[1]->ptr,"reset") &&
cluster.c:4827:                hard = 1;
cluster.c:4876:    buf[1] = (RDB_VERSION >> 8) & 0xff;
cluster.c:4892:    uint16_t rdbver;
cluster.c:4896:    if (len < 10) return C_ERR;
cluster.c:4897:    footer = p+(len-10);
cluster.c:4900:    rdbver = (footer[1] << 8) | footer[0];
cluster.c:4917:    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
cluster.c:4923:    createDumpPayload(&payload,o,c->argv[1]);
cluster.c:4934:    long long ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
cluster.c:4941:        int additional = c->argc-j-1;
cluster.c:4943:            replace = 1;
cluster.c:4945:            absttl = 1;
cluster.c:4946:        } else if (!strcasecmp(c->argv[j]->ptr,"idletime") && additional >= 1 &&
cluster.c:4947:                   lfu_freq == -1)
cluster.c:4949:            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
cluster.c:4957:        } else if (!strcasecmp(c->argv[j]->ptr,"freq") && additional >= 1 &&
cluster.c:4958:                   lru_idle == -1)
cluster.c:4960:            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lfu_freq,NULL)
cluster.c:4974:    if (!replace && lookupKeyWrite(c->db,c->argv[1]) != NULL) {
cluster.c:4995:    if (((type = rdbLoadObjectType(&payload)) == -1) ||
cluster.c:4996:        ((obj = rdbLoadObject(type,&payload,c->argv[1])) == NULL))
cluster.c:5003:    if (replace) dbDelete(c->db,c->argv[1]);
cluster.c:5006:    dbAdd(c->db,c->argv[1],obj);
cluster.c:5009:        setExpire(c,c->db,c->argv[1],ttl);
cluster.c:5012:    signalModifiedKey(c->db,c->argv[1]);
cluster.c:5024:#define MIGRATE_SOCKET_CACHE_TTL 10 /* close cached sockets after 10 sec. */
cluster.c:5036: * connection can't be established. In this case -1 is returned.
cluster.c:5050:    name = sdscatlen(name,":",1);
cluster.c:5070:    fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,
cluster.c:5072:    if (fd == -1) {
cluster.c:5092:    cs->last_dbid = -1;
cluster.c:5104:    name = sdscatlen(name,":",1);
cluster.c:5138: * MIGRATE host port "" dbid timeout [COPY | REPLACE | AUTH password] KEYS key1
cluster.c:5151:    int may_retry = 1;
cluster.c:5157:    int num_keys = 1;  /* By default only migrate the 'key' argument. */
cluster.c:5161:        int moreargs = j < c->argc-1;
cluster.c:5163:            copy = 1;
cluster.c:5165:            replace = 1;
cluster.c:5180:            first_key = j+1;
cluster.c:5181:            num_keys = c->argc - j - 1;
cluster.c:5195:    if (timeout <= 0) timeout = 1000;
cluster.c:5224:    cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);
cluster.c:5258:        if (expireat != -1) {
cluster.c:5263:            if (ttl < 1) ttl = 1;
cluster.c:5276:                rioWriteBulkString(&cmd,"RESTORE-ASKING",14));
cluster.c:5309:            towrite = (towrite > (64*1024) ? (64*1024) : towrite);
cluster.c:5312:                write_error = 1;
cluster.c:5319:    char buf0[1024]; /* Auth reply. */
cluster.c:5320:    char buf1[1024]; /* Select reply. */
cluster.c:5321:    char buf2[1024]; /* Restore reply. */
cluster.c:5328:    if (select && syncReadLine(cs->fd, buf1, sizeof(buf1), timeout) <= 0)
cluster.c:5334:    int del_idx = 1; /* Index of the key argument for the replicated DEL op. */
cluster.c:5338:     * We allocate num_keys+1 because the additional argument is for "DEL"
cluster.c:5340:    if (!copy) newargv = zmalloc(sizeof(robj*)*(num_keys+1));
cluster.c:5344:            socket_error = 1;
cluster.c:5348:            (select && buf1[0] == '-') ||
cluster.c:5353:                cs->last_dbid = -1;
cluster.c:5356:                else if (select && buf1[0] == '-') errbuf = buf1;
cluster.c:5359:                error_from_target = 1;
cluster.c:5361:                    errbuf+1);
cluster.c:5389:    if (socket_error) migrateCloseSocket(c->argv[1],c->argv[2]);
cluster.c:5395:        if (del_idx > 1) {
cluster.c:5399:            argv_rewritten = 1;
cluster.c:5426:         * the currently selected socket to -1 to force SELECT the next time. */
cluster.c:5445:    if (!argv_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);
cluster.c:5503: * 1) A single key (even multiple times like LPOPRPUSH mylist mylist).
cluster.c:5564:        _ms.count = 1;
cluster.c:5613:                    migrating_slot = 1;
cluster.c:5615:                    importing_slot = 1;
cluster.c:5630:                        multiple_keys = 1;
cluster.c:5738: * 1) A client blocks with BLPOP or similar blocking operation.
cluster.c:5745: * returns 1. Otherwise 0 is returned and no operation is performed. */
cluster.c:5758:            return 1;
cluster.c:5769:             * 1) The slot is unassigned, emitting a cluster down error.
cluster.c:5782:                return 1;
cluster.h:8:#define CLUSTER_SLOTS 16384
cluster.h:10:#define CLUSTER_FAIL 1        /* The cluster can't work */
cluster.h:11:#define CLUSTER_NAMELEN 40    /* sha1 hex length */
cluster.h:12:#define CLUSTER_PORT_INCR 10000 /* Cluster port = baseport + PORT_INCR */
cluster.h:16:#define CLUSTER_DEFAULT_NODE_TIMEOUT 15000
cluster.h:17:#define CLUSTER_DEFAULT_SLAVE_VALIDITY 10 /* Slave max data age factor. */
cluster.h:18:#define CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE 1
cluster.h:22:#define CLUSTER_FAIL_UNDO_TIME_ADD 10 /* Some additional time. */
cluster.h:24:#define CLUSTER_DEFAULT_MIGRATION_BARRIER 1
cluster.h:31:#define CLUSTER_REDIR_CROSS_SLOT 1    /* -CROSSSLOT request. */
cluster.h:50:#define CLUSTER_NODE_MASTER 1     /* The node is a master */
cluster.h:54:#define CLUSTER_NODE_MYSELF 16    /* This node is myself */
cluster.h:57:#define CLUSTER_NODE_MEET 128     /* Send a MEET message to this node */
cluster.h:59:#define CLUSTER_NODE_NOFAILOVER 512 /* Slave will not try to failver. */
cluster.h:73:#define CLUSTER_CANT_FAILOVER_DATA_AGE 1
cluster.h:80:#define CLUSTER_TODO_HANDLE_FAILOVER (1<<0)
cluster.h:81:#define CLUSTER_TODO_UPDATE_STATE (1<<1)
cluster.h:82:#define CLUSTER_TODO_SAVE_CONFIG (1<<2)
cluster.h:83:#define CLUSTER_TODO_FSYNC_CONFIG (1<<3)
cluster.h:92:#define CLUSTERMSG_TYPE_PONG 1          /* Pong (reply to Ping) */
cluster.h:101:#define CLUSTERMSG_TYPE_COUNT 10        /* Total number of message types. */
cluster.h:107:#define CLUSTER_MODULE_FLAG_NO_FAILOVER (1<<1)
cluster.h:108:#define CLUSTER_MODULE_FLAG_NO_REDIRECTION (1<<2)
cluster.h:118:    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
cluster.h:193:    uint16_t port;              /* base port last time it was seen */
cluster.h:194:    uint16_t cport;             /* cluster port last time it was seen */
cluster.h:195:    uint16_t flags;             /* node->flags copy */
cluster.h:196:    uint32_t notused1;
cluster.h:226:        clusterMsgDataGossip gossip[1];
cluster.h:250:#define CLUSTER_PROTO_VER 1 /* Cluster bus protocol version. */
cluster.h:255:    uint16_t ver;       /* Protocol version, currently set to 1. */
cluster.h:256:    uint16_t port;      /* TCP base port number. */
cluster.h:257:    uint16_t type;      /* Message type */
cluster.h:258:    uint16_t count;     /* Only used for some kind of messages. */
cluster.h:269:    char notused1[34];  /* 34 bytes reserved for future usage. */
cluster.h:270:    uint16_t cport;      /* Sender TCP cluster bus port */
cluster.h:271:    uint16_t flags;      /* Sender node flags */
cluster.h:273:    unsigned char mflags[3]; /* Message flags: CLUSTERMSG_FLAG[012]_... */
cluster.h:281:#define CLUSTERMSG_FLAG0_PAUSED (1<<0) /* Master paused for manual failover. */
cluster.h:282:#define CLUSTERMSG_FLAG0_FORCEACK (1<<1) /* Give ACK to AUTH_REQUEST even if
config.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
config.c:61:    {"local1",  LOG_LOCAL1},
config.c:97:    {1024*1024*256, 1024*1024*64, 60}, /* slave */
config.c:98:    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */
config.c:140:    if (!strcasecmp(s,"yes")) return 1;
config.c:142:    else return -1;
config.c:146:    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));
config.c:178:    lines = sdssplitlen(config,strlen(config),"\n",1,&totlines);
config.c:184:        linenum = i+1;
config.c:206:            server.maxidletime = atoi(argv[1]);
config.c:211:            server.tcpkeepalive = atoi(argv[1]);
config.c:216:            if ((server.protected_mode = yesnotoi(argv[1])) == -1) {
config.c:220:            server.port = atoi(argv[1]);
config.c:225:            server.tcp_backlog = atoi(argv[1]);
config.c:230:            int j, addresses = argc-1;
config.c:236:                server.bindaddr[j] = zstrdup(argv[j+1]);
config.c:239:            server.unixsocket = zstrdup(argv[1]);
config.c:242:            server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);
config.c:248:                int seconds = atoi(argv[1]);
config.c:250:                if (seconds < 1 || changes < 0) {
config.c:254:            } else if (argc == 2 && !strcasecmp(argv[1],"")) {
config.c:258:            if (chdir(argv[1]) == -1) {
config.c:260:                    argv[1], strerror(errno));
config.c:261:                exit(1);
config.c:264:            server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);
config.c:274:            server.logfile = zstrdup(argv[1]);
config.c:287:            if ((server.always_show_logo = yesnotoi(argv[1])) == -1) {
config.c:291:            if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {
config.c:296:            server.syslog_ident = zstrdup(argv[1]);
config.c:299:                configEnumGetValue(syslog_facility_enum,argv[1]);
config.c:305:            server.dbnum = atoi(argv[1]);
config.c:306:            if (server.dbnum < 1) {
config.c:310:            loadServerConfig(argv[1],NULL);
config.c:312:            server.maxclients = atoi(argv[1]);
config.c:313:            if (server.maxclients < 1) {
config.c:317:            server.maxmemory = memtoll(argv[1],NULL);
config.c:320:                configEnumGetValue(maxmemory_policy_enum,argv[1]);
config.c:326:            server.maxmemory_samples = atoi(argv[1]);
config.c:328:                err = "maxmemory-samples must be 1 or greater";
config.c:332:            server.proto_max_bulk_len = memtoll(argv[1],NULL);
config.c:334:            server.client_max_querybuf_len = memtoll(argv[1],NULL);
config.c:336:            server.lfu_log_factor = atoi(argv[1]);
config.c:342:            server.lfu_decay_time = atoi(argv[1]);
config.c:350:            server.masterhost = sdsnew(argv[1]);
config.c:357:            server.repl_ping_slave_period = atoi(argv[1]);
config.c:359:                err = "repl-ping-replica-period must be 1 or greater";
config.c:363:            server.repl_timeout = atoi(argv[1]);
config.c:365:                err = "repl-timeout must be 1 or greater";
config.c:369:            if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {
config.c:373:            if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {
config.c:377:            server.repl_diskless_sync_delay = atoi(argv[1]);
config.c:383:            long long size = memtoll(argv[1],NULL);
config.c:385:                err = "repl-backlog-size must be 1 or greater.";
config.c:390:            server.repl_backlog_time_limit = atoi(argv[1]);
config.c:397:            server.masterauth = argv[1][0] ? zstrdup(argv[1]) : NULL;
config.c:402:            if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
config.c:409:            if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {
config.c:416:            if ((server.repl_slave_ignore_maxmemory = yesnotoi(argv[1])) == -1) {
config.c:420:            if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {
config.c:424:            if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {
config.c:428:            if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
config.c:432:            if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {
config.c:436:            if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {
config.c:440:            if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {
config.c:446:            if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {
config.c:450:            if ((server.active_defrag_enabled = yesnotoi(argv[1])) == -1) {
config.c:459:            if ((server.daemonize = yesnotoi(argv[1])) == -1) {
config.c:463:            if ((server.dynamic_hz = yesnotoi(argv[1])) == -1) {
config.c:467:            server.config_hz = atoi(argv[1]);
config.c:473:            if ((yes = yesnotoi(argv[1])) == -1) {
config.c:478:            if (!pathIsBaseName(argv[1])) {
config.c:483:            server.aof_filename = zstrdup(argv[1]);
config.c:486:            if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
config.c:490:            server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);
config.c:498:            server.aof_rewrite_perc = atoi(argv[1]);
config.c:506:            server.aof_rewrite_min_size = memtoll(argv[1],NULL);
config.c:511:                 yesnotoi(argv[1])) == -1) {
config.c:518:                 yesnotoi(argv[1])) == -1) {
config.c:522:            if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
config.c:526:            if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {
config.c:530:            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {
config.c:534:            server.requirepass = argv[1][0] ? zstrdup(argv[1]) : NULL;
config.c:537:            server.pidfile = zstrdup(argv[1]);
config.c:539:            if (!pathIsBaseName(argv[1])) {
config.c:544:            server.rdb_filename = zstrdup(argv[1]);
config.c:546:            server.active_defrag_threshold_lower = atoi(argv[1]);
config.c:548:                server.active_defrag_threshold_lower > 1000) {
config.c:549:                err = "active-defrag-threshold-lower must be between 0 and 1000";
config.c:553:            server.active_defrag_threshold_upper = atoi(argv[1]);
config.c:555:                server.active_defrag_threshold_upper > 1000) {
config.c:556:                err = "active-defrag-threshold-upper must be between 0 and 1000";
config.c:560:            server.active_defrag_ignore_bytes = memtoll(argv[1], NULL);
config.c:566:            server.active_defrag_cycle_min = atoi(argv[1]);
config.c:567:            if (server.active_defrag_cycle_min < 1 || server.active_defrag_cycle_min > 99) {
config.c:568:                err = "active-defrag-cycle-min must be between 1 and 99";
config.c:572:            server.active_defrag_cycle_max = atoi(argv[1]);
config.c:573:            if (server.active_defrag_cycle_max < 1 || server.active_defrag_cycle_max > 99) {
config.c:574:                err = "active-defrag-cycle-max must be between 1 and 99";
config.c:578:            server.active_defrag_max_scan_fields = strtoll(argv[1],NULL,10);
config.c:579:            if (server.active_defrag_max_scan_fields < 1) {
config.c:584:            server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
config.c:586:            server.hash_max_ziplist_value = memtoll(argv[1], NULL);
config.c:588:            server.stream_node_max_bytes = memtoll(argv[1], NULL);
config.c:590:            server.stream_node_max_entries = atoi(argv[1]);
config.c:596:            server.list_max_ziplist_size = atoi(argv[1]);
config.c:598:            server.list_compress_depth = atoi(argv[1]);
config.c:600:            server.set_max_intset_entries = memtoll(argv[1], NULL);
config.c:602:            server.zset_max_ziplist_entries = memtoll(argv[1], NULL);
config.c:604:            server.zset_max_ziplist_value = memtoll(argv[1], NULL);
config.c:606:            server.hll_sparse_max_bytes = memtoll(argv[1], NULL);
config.c:608:            struct redisCommand *cmd = lookupCommand(argv[1]);
config.c:618:            retval = dictDelete(server.commands, argv[1]);
config.c:632:            if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {
config.c:637:            server.cluster_configfile = zstrdup(argv[1]);
config.c:640:            server.cluster_announce_ip = zstrdup(argv[1]);
config.c:642:            server.cluster_announce_port = atoi(argv[1]);
config.c:651:            server.cluster_announce_bus_port = atoi(argv[1]);
config.c:660:            if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)
config.c:665:            server.cluster_node_timeout = strtoll(argv[1],NULL,10);
config.c:667:                err = "cluster node timeout must be 1 or greater"; goto loaderr;
config.c:672:            server.cluster_migration_barrier = atoi(argv[1]);
config.c:681:            server.cluster_slave_validity_factor = atoi(argv[1]);
config.c:690:            server.cluster_slave_no_failover = yesnotoi(argv[1]);
config.c:691:            if (server.cluster_slave_no_failover == -1) {
config.c:696:            server.lua_time_limit = strtoll(argv[1],NULL,10);
config.c:698:            server.lua_always_replicate_commands = yesnotoi(argv[1]);
config.c:702:            server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);
config.c:706:            server.latency_monitor_threshold = strtoll(argv[1],NULL,10);
config.c:712:            server.slowlog_max_len = strtoll(argv[1],NULL,10);
config.c:716:            int class = getClientTypeByName(argv[1]);
config.c:720:            if (class == -1 || class == CLIENT_TYPE_MASTER) {
config.c:737:            if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {
config.c:743:            server.slave_priority = atoi(argv[1]);
config.c:748:            server.slave_announce_ip = zstrdup(argv[1]);
config.c:752:            server.slave_announce_port = atoi(argv[1]);
config.c:761:            server.repl_min_slaves_to_write = atoi(argv[1]);
config.c:768:            server.repl_min_slaves_max_lag = atoi(argv[1]);
config.c:773:            int flags = keyspaceEventsStringToFlags(argv[1]);
config.c:775:            if (flags == -1) {
config.c:782:                configEnumGetValue(supervised_mode_enum,argv[1]);
config.c:790:            queueLoadModule(argv[1],&argv[2],argc-2);
config.c:792:            /* argc == 1 is handled by main() as we need to enter the sentinel
config.c:794:            if (argc != 1) {
config.c:799:                err = sentinelHandleConfiguration(argv+1,argc-1);
config.c:811:        i = linenum-1;
config.c:824:    exit(1);
config.c:836:    char buf[CONFIG_MAX_LINE+1];
config.c:842:        if (filename[0] == '-' && filename[1] == '\0') {
config.c:848:                exit(1);
config.c:851:        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)
config.c:871:        if (yn == -1) goto badfmt; \
config.c:896:#define config_set_special_field_with_alias(_name1,_name2) \
config.c:897:    } else if (!strcasecmp(c->argv[2]->ptr,_name1) || \
config.c:933:        if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;
config.c:959:        if (enable == -1) goto badfmt;
config.c:971:        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
config.c:975:         * - Seconds >= 1, changes >= 0 */
config.c:976:        if (vlen & 1) {
config.c:984:            val = strtoll(v[j], &eptr, 10);
config.c:986:                ((j & 1) == 0 && val < 1) ||
config.c:987:                ((j & 1) == 1 && val < 0)) {
config.c:998:            seconds = strtoll(v[j],NULL,10);
config.c:999:            changes = strtoll(v[j+1],NULL,10);
config.c:1004:        if (chdir((char*)o->ptr) == -1) {
config.c:1010:        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
config.c:1026:                if (class == -1 || class == CLIENT_TYPE_MASTER) {
config.c:1045:            hard = memtoll(v[j+1],NULL);
config.c:1047:            soft_seconds = strtoll(v[j+3],NULL,10);
config.c:1057:        if (flags == -1) goto badfmt;
config.c:1138:      "maxmemory-samples",server.maxmemory_samples,1,INT_MAX) {
config.c:1146:      "active-defrag-threshold-lower",server.active_defrag_threshold_lower,0,1000) {
config.c:1148:      "active-defrag-threshold-upper",server.active_defrag_threshold_upper,0,1000) {
config.c:1152:      "active-defrag-cycle-min",server.active_defrag_cycle_min,1,99) {
config.c:1154:      "active-defrag-cycle-max",server.active_defrag_cycle_max,1,99) {
config.c:1156:      "active-defrag-max-scan-fields",server.active_defrag_max_scan_fields,1,LONG_MAX) {
config.c:1182:      "slowlog-log-slower-than",server.slowlog_log_slower_than,-1,LLONG_MAX) {
config.c:1190:      "repl-ping-slave-period",server.repl_ping_slave_period,1,INT_MAX) {
config.c:1192:      "repl-ping-replica-period",server.repl_ping_slave_period,1,INT_MAX) {
config.c:1194:      "repl-timeout",server.repl_timeout,1,INT_MAX) {
config.c:1293:    if (stringmatch(pattern,_name,1)) { \
config.c:1301:    if (stringmatch(pattern,_name,1)) { \
config.c:1309:    if (stringmatch(pattern,_name,1)) { \
config.c:1318:    if (stringmatch(pattern,_name,1)) { \
config.c:1329:    char buf[128];
config.c:1485:    if (stringmatch(pattern,"appendonly",1)) {
config.c:1490:    if (stringmatch(pattern,"dir",1)) {
config.c:1491:        char buf[1024];
config.c:1500:    if (stringmatch(pattern,"save",1)) {
config.c:1508:            if (j != server.saveparamslen-1)
config.c:1509:                buf = sdscatlen(buf," ",1);
config.c:1516:    if (stringmatch(pattern,"client-output-buffer-limit",1)) {
config.c:1526:            if (j != CLIENT_TYPE_OBUF_COUNT-1)
config.c:1527:                buf = sdscatlen(buf," ",1);
config.c:1534:    if (stringmatch(pattern,"unixsocketperm",1)) {
config.c:1541:    if (stringmatch(pattern,"slaveof",1) ||
config.c:1542:        stringmatch(pattern,"replicaof",1))
config.c:1544:        char *optname = stringmatch(pattern,"slaveof",1) ?
config.c:1557:    if (stringmatch(pattern,"notify-keyspace-events",1)) {
config.c:1566:    if (stringmatch(pattern,"bind",1)) {
config.c:1587:int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
config.c:1625:    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
config.c:1659:    char buf[CONFIG_MAX_LINE+1];
config.c:1660:    int linenum = -1;
config.c:1670:    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
config.c:1675:        linenum++; /* Zero based, so we init at -1 */
config.c:1680:                state->has_tail = 1;
config.c:1767:            state->has_tail = 1;
config.c:1777:    int gb = 1024*1024*1024;
config.c:1778:    int mb = 1024*1024;
config.c:1779:    int kb = 1024;
config.c:1814:    int force = 1;
config.c:1828:    line = sdscatlen(line, " ", 1);
config.c:1885:        rewriteConfigRewriteLine(state,"save",line,1);
config.c:1893:    char cwd[1024];
config.c:1915:    rewriteConfigRewriteLine(state,option,line,1);
config.c:1926:    line = sdscatlen(line, " ", 1);
config.c:1963:    int force = 1;
config.c:1973:    /* Rewrite as bind <addr1> <addr2> ... <addrN> */
config.c:1976:    line = sdscatlen(line, " ", 1);
config.c:1993:            was_empty = 1;
config.c:1998:        content = sdscatlen(content,"\n",1);
config.c:2048: * 1) The old file length is obtained.
config.c:2056: * The function returns 0 on success, otherwise -1 is returned and errno
config.c:2065:    /* 1) Open the old file (or create a new one if it does not
config.c:2067:    if (fd == -1) return -1; /* errno set by open(). */
config.c:2068:    if (fstat(fd,&sb) == -1) {
config.c:2070:        return -1; /* errno set by fstat(). */
config.c:2081:        memset(content_padded+content_size+1,'#',padding-1);
config.c:2085:    if (write(fd,content_padded,strlen(content_padded)) == -1) {
config.c:2086:        retval = -1;
config.c:2092:        if (ftruncate(fd,content_size) == -1) {
config.c:2110: * On error -1 is returned and errno is set accordingly, otherwise 0. */
config.c:2116:    /* Step 1: read the old config into our rewrite state. */
config.c:2117:    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
config.c:2246:    if (server.loading && strcasecmp(c->argv[1]->ptr,"get")) {
config.c:2251:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
config.c:2260:    } else if (!strcasecmp(c->argv[1]->ptr,"set") && c->argc == 4) {
config.c:2262:    } else if (!strcasecmp(c->argv[1]->ptr,"get") && c->argc == 3) {
config.c:2264:    } else if (!strcasecmp(c->argv[1]->ptr,"resetstat") && c->argc == 2) {
config.c:2268:    } else if (!strcasecmp(c->argv[1]->ptr,"rewrite") && c->argc == 2) {
config.c:2273:        if (rewriteConfig(server.configfile) == -1) {
config.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
config.h:43:#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
config.h:53:#define HAVE_PROC_STAT 1
config.h:54:#define HAVE_PROC_MAPS 1
config.h:55:#define HAVE_PROC_SMAPS 1
config.h:56:#define HAVE_PROC_SOMAXCONN 1
config.h:61:#define HAVE_TASKINFO 1
config.h:68:#define HAVE_BACKTRACE 1
config.h:73:#define HAVE_MSG_NOSIGNAL 1
config.h:78:#define HAVE_EPOLL 1
config.h:81:#if (defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)
config.h:82:#define HAVE_KQUEUE 1
config.h:88:#define HAVE_EVPORT 1
config.h:103:#if (LINUX_VERSION_CODE >= 0x020611 && __GLIBC_PREREQ(2, 6))
config.h:104:#define HAVE_SYNC_FILE_RANGE 1
config.h:107:#if (LINUX_VERSION_CODE >= 0x020611)
config.h:108:#define HAVE_SYNC_FILE_RANGE 1
config.h:137:#if (BSD >= 199103)
config.h:143:#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax, pc) */
config.h:144:#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
config.h:145:#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp)*/
config.h:200:#define GNUC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
config.h:205:#if (GNUC_VERSION >= 40100 && __GLIBC_PREREQ(2, 6))
crc16.c:4: * Copyright 2001-2010 Georges Menie (www.menie.org)
crc16.c:5: * Copyright 2010-2012 Salvatore Sanfilippo (adapted to Redis coding style)
crc16.c:32:/* CRC16 implementation according to CCITT standards.
crc16.c:34: * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the
crc16.c:37: * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"
crc16.c:38: * Width                      : 16 bit
crc16.c:39: * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)
crc16.c:44: * Output for "123456789"     : 31C3
crc16.c:47:static const uint16_t crc16tab[256]= {
crc16.c:48:    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
crc16.c:49:    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
crc16.c:50:    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
crc16.c:51:    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
crc16.c:52:    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
crc16.c:54:    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
crc16.c:55:    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
crc16.c:56:    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
crc16.c:58:    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
crc16.c:59:    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
crc16.c:60:    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
crc16.c:62:    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
crc16.c:63:    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
crc16.c:64:    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
crc16.c:65:    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
crc16.c:66:    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
crc16.c:67:    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
crc16.c:69:    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
crc16.c:70:    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
crc16.c:71:    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
crc16.c:73:    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
crc16.c:74:    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
crc16.c:75:    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
crc16.c:77:    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
crc16.c:78:    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
crc16.c:79:    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
crc16.c:82:uint16_t crc16(const char *buf, int len) {
crc16.c:84:    uint16_t crc = 0;
crc16.c:86:            crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
crc64.c:11: * Check("123456789"): 0xe9c6d914c4b8d9ca
crc64.c:13: * Copyright (c) 2012, Salvatore Sanfilippo <antirez at gmail dot com>
crc64.c:44:    UINT64_C(0xf5b0e190606b12f2), UINT64_C(0x8f689158505e9b8b),
crc64.c:45:    UINT64_C(0xc038e5739841b68f), UINT64_C(0xbae095bba8743ff6),
crc64.c:46:    UINT64_C(0x358804e3f82aa47d), UINT64_C(0x4f50742bc81f2d04),
crc64.c:47:    UINT64_C(0xab28ecb46814fe75), UINT64_C(0xd1f09c7c5821770c),
crc64.c:49:    UINT64_C(0x6b1009c7f05548fa), UINT64_C(0x11c8790fc060c183),
crc64.c:50:    UINT64_C(0x9ea0e857903e5a08), UINT64_C(0xe478989fa00bd371),
crc64.c:51:    UINT64_C(0x7d08ff3b88be6f81), UINT64_C(0x07d08ff3b88be6f8),
crc64.c:52:    UINT64_C(0x88b81eabe8d57d73), UINT64_C(0xf2606e63d8e0f40a),
crc64.c:53:    UINT64_C(0xbd301a4810ffd90e), UINT64_C(0xc7e86a8020ca5077),
crc64.c:54:    UINT64_C(0x4880fbd87094cbfc), UINT64_C(0x32588b1040a14285),
crc64.c:55:    UINT64_C(0xd620138fe0aa91f4), UINT64_C(0xacf86347d09f188d),
crc64.c:56:    UINT64_C(0x2390f21f80c18306), UINT64_C(0x594882d7b0f40a7f),
crc64.c:57:    UINT64_C(0x1618f6fc78eb277b), UINT64_C(0x6cc0863448deae02),
crc64.c:58:    UINT64_C(0xe3a8176c18803589), UINT64_C(0x997067a428b5bcf0),
crc64.c:59:    UINT64_C(0xfa11fe77117cdf02), UINT64_C(0x80c98ebf2149567b),
crc64.c:60:    UINT64_C(0x0fa11fe77117cdf0), UINT64_C(0x75796f2f41224489),
crc64.c:61:    UINT64_C(0x3a291b04893d698d), UINT64_C(0x40f16bccb908e0f4),
crc64.c:62:    UINT64_C(0xcf99fa94e9567b7f), UINT64_C(0xb5418a5cd963f206),
crc64.c:63:    UINT64_C(0x513912c379682177), UINT64_C(0x2be1620b495da80e),
crc64.c:64:    UINT64_C(0xa489f35319033385), UINT64_C(0xde51839b2936bafc),
crc64.c:65:    UINT64_C(0x9101f7b0e12997f8), UINT64_C(0xebd98778d11c1e81),
crc64.c:66:    UINT64_C(0x64b116208142850a), UINT64_C(0x1e6966e8b1770c73),
crc64.c:67:    UINT64_C(0x8719014c99c2b083), UINT64_C(0xfdc17184a9f739fa),
crc64.c:68:    UINT64_C(0x72a9e0dcf9a9a271), UINT64_C(0x08719014c99c2b08),
crc64.c:69:    UINT64_C(0x4721e43f0183060c), UINT64_C(0x3df994f731b68f75),
crc64.c:70:    UINT64_C(0xb29105af61e814fe), UINT64_C(0xc849756751dd9d87),
crc64.c:71:    UINT64_C(0x2c31edf8f1d64ef6), UINT64_C(0x56e99d30c1e3c78f),
crc64.c:72:    UINT64_C(0xd9810c6891bd5c04), UINT64_C(0xa3597ca0a188d57d),
crc64.c:73:    UINT64_C(0xec09088b6997f879), UINT64_C(0x96d1784359a27100),
crc64.c:74:    UINT64_C(0x19b9e91b09fcea8b), UINT64_C(0x636199d339c963f2),
crc64.c:75:    UINT64_C(0xdf7adabd7a6e2d6f), UINT64_C(0xa5a2aa754a5ba416),
crc64.c:76:    UINT64_C(0x2aca3b2d1a053f9d), UINT64_C(0x50124be52a30b6e4),
crc64.c:77:    UINT64_C(0x1f423fcee22f9be0), UINT64_C(0x659a4f06d21a1299),
crc64.c:78:    UINT64_C(0xeaf2de5e82448912), UINT64_C(0x902aae96b271006b),
crc64.c:79:    UINT64_C(0x74523609127ad31a), UINT64_C(0x0e8a46c1224f5a63),
crc64.c:80:    UINT64_C(0x81e2d7997211c1e8), UINT64_C(0xfb3aa75142244891),
crc64.c:82:    UINT64_C(0x41da32eaea507767), UINT64_C(0x3b024222da65fe1e),
crc64.c:84:    UINT64_C(0x57c2c41692bb501c), UINT64_C(0x2d1ab4dea28ed965),
crc64.c:85:    UINT64_C(0x624ac0f56a91f461), UINT64_C(0x1892b03d5aa47d18),
crc64.c:86:    UINT64_C(0x97fa21650afae693), UINT64_C(0xed2251ad3acf6fea),
crc64.c:87:    UINT64_C(0x095ac9329ac4bc9b), UINT64_C(0x7382b9faaaf135e2),
crc64.c:88:    UINT64_C(0xfcea28a2faafae69), UINT64_C(0x8632586aca9a2710),
crc64.c:89:    UINT64_C(0xc9622c4102850a14), UINT64_C(0xb3ba5c8932b0836d),
crc64.c:90:    UINT64_C(0x3cd2cdd162ee18e6), UINT64_C(0x460abd1952db919f),
crc64.c:91:    UINT64_C(0x256b24ca6b12f26d), UINT64_C(0x5fb354025b277b14),
crc64.c:93:    UINT64_C(0xe553c1b9f35344e2), UINT64_C(0x9f8bb171c366cd9b),
crc64.c:94:    UINT64_C(0x10e3202993385610), UINT64_C(0x6a3b50e1a30ddf69),
crc64.c:95:    UINT64_C(0x8e43c87e03060c18), UINT64_C(0xf49bb8b633338561),
crc64.c:96:    UINT64_C(0x7bf329ee636d1eea), UINT64_C(0x012b592653589793),
crc64.c:98:    UINT64_C(0xbbcbcc9dfb2ca865), UINT64_C(0xc113bc55cb19211c),
crc64.c:99:    UINT64_C(0x5863dbf1e3ac9dec), UINT64_C(0x22bbab39d3991495),
crc64.c:100:    UINT64_C(0xadd33a6183c78f1e), UINT64_C(0xd70b4aa9b3f20667),
crc64.c:101:    UINT64_C(0x985b3e827bed2b63), UINT64_C(0xe2834e4a4bd8a21a),
crc64.c:102:    UINT64_C(0x6debdf121b863991), UINT64_C(0x1733afda2bb3b0e8),
crc64.c:104:    UINT64_C(0x06fbd6d5ebd3716b), UINT64_C(0x7c23a61ddbe6f812),
crc64.c:105:    UINT64_C(0x3373d23613f9d516), UINT64_C(0x49aba2fe23cc5c6f),
crc64.c:106:    UINT64_C(0xc6c333a67392c7e4), UINT64_C(0xbc1b436e43a74e9d),
crc64.c:107:    UINT64_C(0x95ac9329ac4bc9b5), UINT64_C(0xef74e3e19c7e40cc),
crc64.c:108:    UINT64_C(0x601c72b9cc20db47), UINT64_C(0x1ac40271fc15523e),
crc64.c:110:    UINT64_C(0xa02497ca54616dc8), UINT64_C(0xdafce7026454e4b1),
crc64.c:112:    UINT64_C(0xcb349e0da4342532), UINT64_C(0xb1eceec59401ac4b),
crc64.c:113:    UINT64_C(0xfebc9aee5c1e814f), UINT64_C(0x8464ea266c2b0836),
crc64.c:114:    UINT64_C(0x0b0c7b7e3c7593bd), UINT64_C(0x71d40bb60c401ac4),
crc64.c:115:    UINT64_C(0xe8a46c1224f5a634), UINT64_C(0x927c1cda14c02f4d),
crc64.c:116:    UINT64_C(0x1d148d82449eb4c6), UINT64_C(0x67ccfd4a74ab3dbf),
crc64.c:117:    UINT64_C(0x289c8961bcb410bb), UINT64_C(0x5244f9a98c8199c2),
crc64.c:118:    UINT64_C(0xdd2c68f1dcdf0249), UINT64_C(0xa7f41839ecea8b30),
crc64.c:119:    UINT64_C(0x438c80a64ce15841), UINT64_C(0x3954f06e7cd4d138),
crc64.c:120:    UINT64_C(0xb63c61362c8a4ab3), UINT64_C(0xcce411fe1cbfc3ca),
crc64.c:121:    UINT64_C(0x83b465d5d4a0eece), UINT64_C(0xf96c151de49567b7),
crc64.c:123:    UINT64_C(0x6fbd6d5ebd3716b7), UINT64_C(0x15651d968d029fce),
crc64.c:125:    UINT64_C(0xaf85882d2576a038), UINT64_C(0xd55df8e515432941),
crc64.c:126:    UINT64_C(0x5a3569bd451db2ca), UINT64_C(0x20ed197575283bb3),
crc64.c:127:    UINT64_C(0xc49581ead523e8c2), UINT64_C(0xbe4df122e51661bb),
crc64.c:128:    UINT64_C(0x3125607ab548fa30), UINT64_C(0x4bfd10b2857d7349),
crc64.c:129:    UINT64_C(0x04ad64994d625e4d), UINT64_C(0x7e7514517d57d734),
crc64.c:130:    UINT64_C(0xf11d85092d094cbf), UINT64_C(0x8bc5f5c11d3cc5c6),
crc64.c:131:    UINT64_C(0x12b5926535897936), UINT64_C(0x686de2ad05bcf04f),
crc64.c:133:    UINT64_C(0xd28d7716adc8cfb9), UINT64_C(0xa85507de9dfd46c0),
crc64.c:135:    UINT64_C(0xb99d7ed15d9d8743), UINT64_C(0xc3450e196da80e3a),
crc64.c:136:    UINT64_C(0x4c2d9f413df695b1), UINT64_C(0x36f5ef890dc31cc8),
crc64.c:137:    UINT64_C(0x79a59ba2c5dc31cc), UINT64_C(0x037deb6af5e9b8b5),
crc64.c:138:    UINT64_C(0x8c157a32a5b7233e), UINT64_C(0xf6cd0afa9582aa47),
crc64.c:139:    UINT64_C(0x4ad64994d625e4da), UINT64_C(0x300e395ce6106da3),
crc64.c:140:    UINT64_C(0xbf66a804b64ef628), UINT64_C(0xc5bed8cc867b7f51),
crc64.c:141:    UINT64_C(0x8aeeace74e645255), UINT64_C(0xf036dc2f7e51db2c),
crc64.c:142:    UINT64_C(0x7f5e4d772e0f40a7), UINT64_C(0x05863dbf1e3ac9de),
crc64.c:143:    UINT64_C(0xe1fea520be311aaf), UINT64_C(0x9b26d5e88e0493d6),
crc64.c:144:    UINT64_C(0x144e44b0de5a085d), UINT64_C(0x6e963478ee6f8124),
crc64.c:145:    UINT64_C(0x21c640532670ac20), UINT64_C(0x5b1e309b16452559),
crc64.c:146:    UINT64_C(0xd476a1c3461bbed2), UINT64_C(0xaeaed10b762e37ab),
crc64.c:148:    UINT64_C(0xc26e573f3ef099a9), UINT64_C(0xb8b627f70ec510d0),
crc64.c:149:    UINT64_C(0xf7e653dcc6da3dd4), UINT64_C(0x8d3e2314f6efb4ad),
crc64.c:150:    UINT64_C(0x0256b24ca6b12f26), UINT64_C(0x788ec2849684a65f),
crc64.c:151:    UINT64_C(0x9cf65a1b368f752e), UINT64_C(0xe62e2ad306bafc57),
crc64.c:152:    UINT64_C(0x6946bb8b56e467dc), UINT64_C(0x139ecb4366d1eea5),
crc64.c:153:    UINT64_C(0x5ccebf68aecec3a1), UINT64_C(0x2616cfa09efb4ad8),
crc64.c:154:    UINT64_C(0xa97e5ef8cea5d153), UINT64_C(0xd3a62e30fe90582a),
crc64.c:155:    UINT64_C(0xb0c7b7e3c7593bd8), UINT64_C(0xca1fc72bf76cb2a1),
crc64.c:157:    UINT64_C(0x70ff52905f188d57), UINT64_C(0x0a2722586f2d042e),
crc64.c:158:    UINT64_C(0x854fb3003f739fa5), UINT64_C(0xff97c3c80f4616dc),
crc64.c:159:    UINT64_C(0x1bef5b57af4dc5ad), UINT64_C(0x61372b9f9f784cd4),
crc64.c:160:    UINT64_C(0xee5fbac7cf26d75f), UINT64_C(0x9487ca0fff135e26),
crc64.c:161:    UINT64_C(0xdbd7be24370c7322), UINT64_C(0xa10fceec0739fa5b),
crc64.c:162:    UINT64_C(0x2e675fb4576761d0), UINT64_C(0x54bf2f7c6752e8a9),
crc64.c:163:    UINT64_C(0xcdcf48d84fe75459), UINT64_C(0xb71738107fd2dd20),
crc64.c:164:    UINT64_C(0x387fa9482f8c46ab), UINT64_C(0x42a7d9801fb9cfd2),
crc64.c:167:    UINT64_C(0x66e7a46c27f3aa2c), UINT64_C(0x1c3fd4a417c62355),
crc64.c:168:    UINT64_C(0x935745fc4798b8de), UINT64_C(0xe98f353477ad31a7),
crc64.c:169:    UINT64_C(0xa6df411fbfb21ca3), UINT64_C(0xdc0731d78f8795da),
crc64.c:170:    UINT64_C(0x536fa08fdfd90e51), UINT64_C(0x29b7d047efec8728),
crc64.c:191:    printf("e9c6d914c4b8d9ca == %016llx\n",
crc64.c:192:        (unsigned long long) crc64(0,(unsigned char*)"123456789",9));
db.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
db.c:63:        if (server.rdb_child_pid == -1 &&
db.c:64:            server.aof_child_pid == -1 &&
db.c:85: * 1. A key gets expired if it reached it's TTL.
db.c:104:    //查看key是否到期 到期返回1 其他返回0
db.c:105:    if (expireIfNeeded(db,key) == 1) {
db.c:219: * 1) The ref count of the value object is incremented.
db.c:250:    int maxtries = 100;
db.c:253:    while(1) {
db.c:292:        return 1;
db.c:311: * 1) The object 'o' is shared (refcount > 1), we don't want to affect
db.c:334:    if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
db.c:347: * The dbnum can be -1 if all the DBs should be flushed, or the specified
db.c:355: * database(s). Otherwise -1 is returned in the specific case the
db.c:361:    //<-1和太大的num 直接返回-1
db.c:362:    if (dbnum < -1 || dbnum >= server.dbnum) {
db.c:364:        return -1;
db.c:366:    //==-1清楚全部
db.c:368:    if (dbnum == -1) {
db.c:370:        enddb = server.dbnum-1;
db.c:392:    if (dbnum == -1) flushSlaveKeysWithExpireList();
db.c:434:    if (c->argc > 1) {
db.c:435:        if (c->argc > 2 || strcasecmp(c->argv[1]->ptr,"async")) {
db.c:465:    signalFlushedDb(-1);
db.c:466:    server.dirty += emptyDb(-1,flags,NULL);
db.c:468:    if (server.rdb_child_pid != -1) {
db.c:469:        kill(server.rdb_child_pid,SIGUSR1);
db.c:488:    for (j = 1; j < c->argc; j++) {
db.c:508:    delGenericCommand(c,1);
db.c:511:/* EXISTS key1 key2 ... key_N.
db.c:517:    for (j = 1; j < c->argc; j++) {
db.c:526:    if (getLongFromObjectOrReply(c, c->argv[1], &id,
db.c:556:    sds pattern = c->argv[1]->ptr;
db.c:562:    allkeys = (pattern[0] == '*' && pattern[1] == '\0');
db.c:585:    robj *o = pd[1];
db.c:621:    *cursor = strtoul(o->ptr, &eptr, 10);
db.c:645:    long count = 10;
db.c:658:    /* Step 1: Parse options. */
db.c:662:            if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
db.c:668:            if (count < 1) {
db.c:675:            pat = c->argv[i+1]->ptr;
db.c:680:            use_pattern = !(pat[0] == '*' && patlen == 1);
db.c:718:        long maxiterations = count*10;
db.c:724:        privdata[1] = o;
db.c:766:                    filter = 1;
db.c:773:                if (!stringmatchlen(pat, patlen, buf, len, 0)) filter = 1;
db.c:778:        if (!filter && o == NULL && expireIfNeeded(c->db, kobj)) filter = 1;
db.c:821:    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
db.c:837:    o = lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH);
db.c:865:        if (!strcasecmp(c->argv[1]->ptr,"nosave")) {
db.c:867:        } else if (!strcasecmp(c->argv[1]->ptr,"save")) {
db.c:893:    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
db.c:895:    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
db.c:904:    expire = getExpire(c->db,c->argv[1]);
db.c:916:    if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
db.c:917:    dbDelete(c->db,c->argv[1]);
db.c:918:    signalModifiedKey(c->db,c->argv[1]);
db.c:921:        c->argv[1],c->db->id);
db.c:933:    renameGenericCommand(c,1);
db.c:969:    o = lookupKeyWrite(c->db,c->argv[1]);
db.c:974:    expire = getExpire(c->db,c->argv[1]);
db.c:977:    if (lookupKeyWrite(dst,c->argv[1]) != NULL) {
db.c:981:    dbAdd(dst,c->argv[1],o);
db.c:982:    if (expire != -1) setExpire(c,dst,c->argv[1],expire);
db.c:986:    dbDelete(src,c->argv[1]);
db.c:1017:int dbSwapDatabases(int id1, int id2) {
db.c:1018:    if (id1 < 0 || id1 >= server.dbnum ||
db.c:1020:    if (id1 == id2) return C_OK;
db.c:1021:    redisDb aux = server.db[id1];
db.c:1022:    redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
db.c:1027:    db1->dict = db2->dict;
db.c:1028:    db1->expires = db2->expires;
db.c:1029:    db1->avg_ttl = db2->avg_ttl;
db.c:1044:    scanDatabaseForReadyLists(db1);
db.c:1049:/* SWAPDB db1 db2 */
db.c:1051:    long id1, id2;
db.c:1060:    if (getLongFromObjectOrReply(c, c->argv[1], &id1,
db.c:1069:    if (dbSwapDatabases(id1,id2) == C_ERR) {
db.c:1107:/* Return the expire time of the specified key, or -1 if no expire
db.c:1114:       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;
db.c:1134:    argv[1] = key;
db.c:1136:    incrRefCount(argv[1]);
db.c:1143:    decrRefCount(argv[1]);
db.c:1159:     * See issue #1525 on Github for more information. */
db.c:1183: * otherwise the function returns 1 if the key is expired. */
db.c:1193:     * that is, 0 if we think the key should be still valid, 1 if
db.c:1195:    if (server.masterhost != NULL) return 1;
db.c:1223:    keys = zmalloc(sizeof(int)*((last - cmd->firstkey)+1));
db.c:1282:    if (num < 1 || num > (argc-3)) {
db.c:1288:     * argv[1] = storage key,
db.c:1290:    keys = zmalloc(sizeof(int)*(num+1));
db.c:1295:    /* Finally add the argv[1] key position (the storage key target). */
db.c:1296:    keys[num] = 1;
db.c:1297:    *numkeys = num+1;  /* Total keys = {union,inter} keys + storage key */
db.c:1339:    keys[num++] = 1; /* <sort-key> is always present. */
db.c:1343:     * next. However there are options with 1 or 2 arguments, so we
db.c:1350:        {"get", 1},
db.c:1351:        {"by", 1},
db.c:1360:            } else if (!strcasecmp(argv[i]->ptr,"store") && i+1 < argc) {
db.c:1364:                found_store = 1;
db.c:1365:                keys[num] = i+1; /* <store-key> */
db.c:1380:    num = 1;
db.c:1388:                first = i+1;
db.c:1410:    int stored_key = -1;
db.c:1417:        if ((!strcasecmp(arg, "store") || !strcasecmp(arg, "storedist")) && ((i+1) < argc)) {
db.c:1418:            stored_key = i+1;
db.c:1422:    num = 1 + (stored_key == -1 ? 0 : 1);
db.c:1425:     * argv[1] = key,
db.c:1431:    keys[0] = 1;
db.c:1432:    if(num > 1) {
db.c:1433:         keys[1] = stored_key;
db.c:1440: *       STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N */
db.c:1449:    int streams_pos = -1;
db.c:1450:    for (i = 1; i < argc; i++) {
db.c:1467:    if (streams_pos != -1) num = argc - streams_pos - 1;
db.c:1470:    if (streams_pos == -1 || num == 0 || num % 2 != 0) {
db.c:1478:    for (i = streams_pos+1; i < argc-num; i++) keys[i-streams_pos-1] = i;
db.c:1493:    server.cluster->slots_keys_count[hashslot] += add ? 1 : -1;
db.c:1496:    indexed[1] = hashslot & 0xff;
db.c:1507:    slotToKeyUpdateKey(key,1);
db.c:1530:    indexed[1] = hashslot & 0xff;
db.c:1534:        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
db.c:1549:    indexed[1] = hashslot & 0xff;
debug.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
debug.c:31:#include "sha1.h"   /* SHA1 is used for DEBUG DIGEST */
debug.c:58:/* Compute the sha1 of string at 's' with 'len' bytes long.
debug.c:59: * The SHA1 is then xored against the string pointed by digest.
debug.c:65:    SHA1_CTX ctx;
debug.c:69:    SHA1Init(&ctx);
debug.c:70:    SHA1Update(&ctx,s,len);
debug.c:71:    SHA1Final(hash,&ctx);
debug.c:83:/* This function instead of just computing the SHA1 and xoring it
debug.c:89: * digest = SHA1(digest xor SHA1(data))
debug.c:98:    SHA1_CTX ctx;
debug.c:102:    SHA1Init(&ctx);
debug.c:103:    SHA1Update(&ctx,digest,20);
debug.c:104:    SHA1Final(digest,&ctx);
debug.c:125:    char buf[128];
debug.c:175:                snprintf(buf,sizeof(buf),"%.17g",score);
debug.c:189:                snprintf(buf,sizeof(buf),"%.17g",*score);
debug.c:249:    if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
debug.c:301:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
debug.c:307:"DIGEST-VALUE <key-1> ... <key-N>-- Output a hex signature of the values of all the specified keys.",
debug.c:313:"LUA-ALWAYS-REPLICATE-COMMANDS <0|1> -- Setting it to 1 makes Lua replication defaulting to replicating single commands, without the script having to enable effects replication.",
debug.c:321:"SET-ACTIVE-EXPIRE <0|1> -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.",
debug.c:329:    } else if (!strcasecmp(c->argv[1]->ptr,"segfault")) {
debug.c:330:        *((char*)-1) = 'x';
debug.c:331:    } else if (!strcasecmp(c->argv[1]->ptr,"panic")) {
debug.c:333:    } else if (!strcasecmp(c->argv[1]->ptr,"restart") ||
debug.c:334:               !strcasecmp(c->argv[1]->ptr,"crash-and-recover"))
debug.c:342:        int flags = !strcasecmp(c->argv[1]->ptr,"restart") ?
debug.c:347:    } else if (!strcasecmp(c->argv[1]->ptr,"oom")) {
debug.c:351:    } else if (!strcasecmp(c->argv[1]->ptr,"assert")) {
debug.c:352:        serverAssertWithInfo(c,c->argv[0],1 == 2);
debug.c:353:    } else if (!strcasecmp(c->argv[1]->ptr,"log") && c->argc == 3) {
debug.c:356:    } else if (!strcasecmp(c->argv[1]->ptr,"reload")) {
debug.c:363:        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
debug.c:373:    } else if (!strcasecmp(c->argv[1]->ptr,"loadaof")) {
debug.c:374:        if (server.aof_state != AOF_OFF) flushAppendOnlyFile(1);
debug.c:375:        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
debug.c:386:    } else if (!strcasecmp(c->argv[1]->ptr,"object") && c->argc == 3) {
debug.c:398:        char extra[138] = {0};
debug.c:437:            val->lru, estimateObjectIdleTime(val)/1000, extra);
debug.c:438:    } else if (!strcasecmp(c->argv[1]->ptr,"sdslen") && c->argc == 3) {
debug.c:463:    } else if (!strcasecmp(c->argv[1]->ptr,"ziplist") && c->argc == 3) {
debug.c:475:    } else if (!strcasecmp(c->argv[1]->ptr,"populate") &&
debug.c:479:        char buf[128];
debug.c:509:    } else if (!strcasecmp(c->argv[1]->ptr,"digest") && c->argc == 2) {
debug.c:518:    } else if (!strcasecmp(c->argv[1]->ptr,"digest-value") && c->argc >= 2) {
debug.c:532:    } else if (!strcasecmp(c->argv[1]->ptr,"sleep") && c->argc == 3) {
debug.c:534:        long long utime = dtime*1000000;
debug.c:537:        tv.tv_sec = utime / 1000000;
debug.c:538:        tv.tv_nsec = (utime % 1000000) * 1000;
debug.c:541:    } else if (!strcasecmp(c->argv[1]->ptr,"set-active-expire") &&
debug.c:546:    } else if (!strcasecmp(c->argv[1]->ptr,"lua-always-replicate-commands") &&
debug.c:551:    } else if (!strcasecmp(c->argv[1]->ptr,"error") && c->argc == 3) {
debug.c:552:        sds errstr = sdsnewlen("-",1);
debug.c:558:    } else if (!strcasecmp(c->argv[1]->ptr,"structsize") && c->argc == 2) {
debug.c:565:        sizes = sdscatprintf(sizes,"sdshdr16:%d ",(int)sizeof(struct sdshdr16));
debug.c:569:    } else if (!strcasecmp(c->argv[1]->ptr,"htstats") && c->argc == 3) {
debug.c:590:    } else if (!strcasecmp(c->argv[1]->ptr,"htstats-key") && c->argc == 3) {
debug.c:618:    } else if (!strcasecmp(c->argv[1]->ptr,"change-repl-id") && c->argc == 2) {
debug.c:623:    } else if (!strcasecmp(c->argv[1]->ptr,"stringmatch-test") && c->argc == 2)
debug.c:645:    *((char*)-1) = 'x';
debug.c:657:        char buf[128];
debug.c:723:    *((char*)-1) = 'x';
debug.c:730:        server.bug_report_start = 1;
debug.c:736:#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
debug.c:737:    /* OSX < 10.6 */
debug.c:745:#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
debug.c:746:    /* OSX >= 10.6 */
debug.c:755:    return (void*) uc->uc_mcontext.gregs[14]; /* Linux 32 */
debug.c:757:    return (void*) uc->uc_mcontext.gregs[16]; /* Linux 64 */
debug.c:788:    for (i = 15; i >= 0; i--) {
debug.c:795:            serverLog(LL_WARNING, "(%016lx) -> %016lx", addr, val);
debug.c:803:#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
debug.c:808:    "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
debug.c:809:    "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
debug.c:810:    "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
debug.c:811:    "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
debug.c:812:    "RIP:%016lx EFL:%016lx\nCS :%016lx FS:%016lx  GS:%016lx",
debug.c:823:        (unsigned long) uc->uc_mcontext->__ss.__r10,
debug.c:824:        (unsigned long) uc->uc_mcontext->__ss.__r11,
debug.c:825:        (unsigned long) uc->uc_mcontext->__ss.__r12,
debug.c:826:        (unsigned long) uc->uc_mcontext->__ss.__r13,
debug.c:827:        (unsigned long) uc->uc_mcontext->__ss.__r14,
debug.c:828:        (unsigned long) uc->uc_mcontext->__ss.__r15,
debug.c:873:        (unsigned long) uc->uc_mcontext.gregs[11],
debug.c:875:        (unsigned long) uc->uc_mcontext.gregs[10],
debug.c:881:        (unsigned long) uc->uc_mcontext.gregs[18],
debug.c:882:        (unsigned long) uc->uc_mcontext.gregs[17],
debug.c:883:        (unsigned long) uc->uc_mcontext.gregs[14],
debug.c:884:        (unsigned long) uc->uc_mcontext.gregs[15],
debug.c:887:        (unsigned long) uc->uc_mcontext.gregs[1],
debug.c:895:    "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
debug.c:896:    "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
debug.c:897:    "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
debug.c:898:    "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
debug.c:899:    "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
debug.c:900:        (unsigned long) uc->uc_mcontext.gregs[13],
debug.c:901:        (unsigned long) uc->uc_mcontext.gregs[11],
debug.c:902:        (unsigned long) uc->uc_mcontext.gregs[14],
debug.c:903:        (unsigned long) uc->uc_mcontext.gregs[12],
debug.c:906:        (unsigned long) uc->uc_mcontext.gregs[10],
debug.c:907:        (unsigned long) uc->uc_mcontext.gregs[15],
debug.c:909:        (unsigned long) uc->uc_mcontext.gregs[1],
debug.c:916:        (unsigned long) uc->uc_mcontext.gregs[16],
debug.c:917:        (unsigned long) uc->uc_mcontext.gregs[17],
debug.c:918:        (unsigned long) uc->uc_mcontext.gregs[18]
debug.c:920:    logStackContent((void**)uc->uc_mcontext.gregs[15]);
debug.c:926:    "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
debug.c:927:    "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
debug.c:928:    "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
debug.c:929:    "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
debug.c:930:    "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
debug.c:941:        (unsigned long) uc->uc_mcontext.mc_r10,
debug.c:942:        (unsigned long) uc->uc_mcontext.mc_r11,
debug.c:943:        (unsigned long) uc->uc_mcontext.mc_r12,
debug.c:944:        (unsigned long) uc->uc_mcontext.mc_r13,
debug.c:945:        (unsigned long) uc->uc_mcontext.mc_r14,
debug.c:946:        (unsigned long) uc->uc_mcontext.mc_r15,
debug.c:981:    "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
debug.c:982:    "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
debug.c:983:    "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
debug.c:984:    "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
debug.c:985:    "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
debug.c:996:        (unsigned long) uc->sc_r10,
debug.c:997:        (unsigned long) uc->sc_r11,
debug.c:998:        (unsigned long) uc->sc_r12,
debug.c:999:        (unsigned long) uc->sc_r13,
debug.c:1000:        (unsigned long) uc->sc_r14,
debug.c:1001:        (unsigned long) uc->sc_r15,
debug.c:1035:    "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
debug.c:1036:    "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
debug.c:1037:    "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
debug.c:1038:    "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
debug.c:1039:    "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
debug.c:1050:        (unsigned long) uc->uc_mcontext.mc_r10,
debug.c:1051:        (unsigned long) uc->uc_mcontext.mc_r11,
debug.c:1052:        (unsigned long) uc->uc_mcontext.mc_r12,
debug.c:1053:        (unsigned long) uc->uc_mcontext.mc_r13,
debug.c:1054:        (unsigned long) uc->uc_mcontext.mc_r14,
debug.c:1055:        (unsigned long) uc->uc_mcontext.mc_r15,
debug.c:1090:    void *trace[101];
debug.c:1093:    if (fd == -1) return; /* If we can't log there is anything to do. */
debug.c:1096:    trace_size = backtrace(trace+1, 100);
debug.c:1099:        char *msg1 = "EIP:\n";
debug.c:1101:        if (write(fd,msg1,strlen(msg1)) == -1) {/* Avoid warning. */};
debug.c:1103:        backtrace_symbols_fd(trace, 1, fd);
debug.c:1104:        if (write(fd,msg2,strlen(msg2)) == -1) {/* Avoid warning. */};
debug.c:1108:    backtrace_symbols_fd(trace+1, trace_size, fd);
debug.c:1138:    if (cc->argc >= 1) {
debug.c:1142:        key = getDecodedObject(cc->argv[1]);
debug.c:1155:#define MEMTEST_MAX_REGIONS 128
debug.c:1160:    char line[1024];
debug.c:1161:    char logbuf[1024];
debug.c:1189:        start_addr = strtoul(start,NULL,16);
debug.c:1190:        end_addr = strtoul(end,NULL,16);
debug.c:1199:        if (write(fd,logbuf,strlen(logbuf)) == -1) { /* Nothing to do. */ }
debug.c:1205:        if (write(fd,".",1) == -1) { /* Nothing to do. */ }
debug.c:1206:        errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);
debug.c:1207:        if (write(fd, errors ? "E" : "O",1) == -1) { /* Nothing to do. */ }
debug.c:1209:    if (write(fd,"\n",1) == -1) { /* Nothing to do. */ }
debug.c:1235:        target += *((int32_t*)(p+j+1));
debug.c:1277:    clients = getAllClientsInfoString(-1);
debug.c:1315:            if (len < 1<<13) { /* we don't have functions over 8k (verified) */
debug.c:1317:                 * limit when dumping. Then try to dump just 128 bytes more
debug.c:1319:                unsigned long next = ((unsigned long)eip + sz) & ~(sz-1);
debug.c:1320:                unsigned long end = (unsigned long)eip + 128;
debug.c:1355:    char charset[] = "0123456789abcdef";
debug.c:1361:        b[1] = charset[(*v)&0xf];
debug.c:1402:    it.it_value.tv_sec = period/1000;
debug.c:1403:    it.it_value.tv_usec = (period%1000)*1000;
debug.c:1427:    min_period = (1000/server.hz)*2;
debugmacro.h:5: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
defrag.c:8: * Copyright (c) 2017, Oran Agra
defrag.c:9: * Copyright (c) 2017, Redis Labs, Inc
defrag.c:68:    if (run_util > bin_util || run_util == 1<<16) {
defrag.c:105:    if (ob->refcount!=1)
defrag.c:181:    if (d->ht[1].table) {
defrag.c:182:        newtable = activeDefragAlloc(d->ht[1].table);
defrag.c:184:            defragged++, d->ht[1].table = newtable;
defrag.c:221:    for (i = zsl->level-1; i >= 0; i--) {
defrag.c:266:#define DEFRAG_SDS_DICT_VAL_IS_SDS 1
defrag.c:601:        return 1;
defrag.c:606:/* returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed. */
defrag.c:641:        if (++iterations > 16) {
defrag.c:646:                return 1;
defrag.c:660: * 1) rax struct
defrag.c:753:        defragged += defragRadixTree(&s->rax, 1, NULL, NULL);
defrag.c:756:        defragged += defragRadixTree(&s->cgroups, 1, defragStreamConsumerGroup, NULL);
defrag.c:872:    float frag_pct = ((float)active / allocated)*100 - 100;
defrag.c:874:    float rss_pct = ((float)resident / allocated)*100 - 100;
defrag.c:898: * and 1 if time is up and more work is needed. */
defrag.c:922:/* returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed. */
defrag.c:961:                quit = 1; /* time is up, we didn't finish all the work */
defrag.c:966:                quit = 1;
defrag.c:968:            /* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields
defrag.c:971:            if (quit || (++iterations > 16 ||
defrag.c:972:                            server.stat_active_defrag_hits - prev_defragged > 512 ||
defrag.c:979:                    return 1;
defrag.c:990:    } while(1);
defrag.c:993:#define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
defrag.c:1031:    static int current_db = -1;
defrag.c:1042:    if (server.aof_child_pid!=-1 || server.rdb_child_pid!=-1)
defrag.c:1047:    run_with_period(1000) {
defrag.c:1055:    timelimit = 1000000*server.active_defrag_running/server.hz/100;
defrag.c:1056:    if (timelimit <= 0) timelimit = 1;
defrag.c:1065:                quit = 1; /* time is up, we didn't finish all the work */
defrag.c:1079:                    (int)((now - start_scan)/1000), (int)(server.stat_active_defrag_hits - start_stat), frag_pct, frag_bytes);
defrag.c:1082:                current_db = -1;
defrag.c:1105:                quit = 1; /* time is up, we didn't finish all the work */
defrag.c:1111:            /* Once in 16 scan iterations, 512 pointer reallocations. or 64 keys
defrag.c:1116:            if (!cursor || (++iterations > 16 ||
defrag.c:1117:                            server.stat_active_defrag_hits - prev_defragged > 512 ||
defrag.c:1120:                    quit = 1;
dict.c:8: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
dict.c:62:static int dict_can_resize = 1;
dict.c:74:static uint8_t dict_hash_function_seed[16];
dict.c:125:    _dictReset(&d->ht[1]);
dict.c:128:    d->rehashidx = -1;
dict.c:134: * but with the invariant(常量) of a USED/BUCKETS ratio near to <= 1 */
dict.c:162:    n.sizemask = realsize-1;
dict.c:174:    //ht[0]作为被rehash的对象，ht[1]承受的对象
dict.c:176:    d->ht[1] = n;
dict.c:181:/* Performs N steps of incremental rehashing. Returns 1 if there are still
dict.c:188: * will visit at max N*10 empty buckets in total, otherwise the amount of
dict.c:191:    int empty_visits = n*10; /* Max number of empty buckets to visit. */
dict.c:204:            if (--empty_visits == 0) return 1;
dict.c:215:            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
dict.c:217:            de->next = d->ht[1].table[h];
dict.c:219:            d->ht[1].table[h] = de;
dict.c:220:            //原来的used--,标识着原来的元素数量-1
dict.c:222:            //rehash的table中数量+1
dict.c:223:            d->ht[1].used++;
dict.c:236:        d->ht[0] = d->ht[1];//赋值，直接把hahs_table[1]赋值给ht[0]  地址
dict.c:237:        _dictReset(&d->ht[1]);
dict.c:238:        d->rehashidx = -1; //标识着rehash结束
dict.c:243:    return 1;
dict.c:250:    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
dict.c:253:/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */
dict.c:259:    while(dictRehash(d,100)) {
dict.c:260:        rehashes += 100;
dict.c:272: * dictionary so that the hash table automatically migrates from H1 to H2
dict.c:277:    if (d->iterators == 0) dictRehash(d,1);
dict.c:300: * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
dict.c:317:    /* Get the index of the new element, or -1 if
dict.c:320:    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
dict.c:327:    //如果正在rehash,我们操作ht[1] else ht[0]
dict.c:328:    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
dict.c:343: * Return 1 if the key was added from scratch, 0 if there was already an
dict.c:355:        return 1;
dict.c:390:    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
dict.c:395:    for (table = 0; table <= 1; table++) {
dict.c:417:        //如果没有rehash 直接break。没有必要遍历1table hash
dict.c:451:    return dictGenericDelete(ht,key,1);
dict.c:494:    _dictClear(d,&d->ht[1],NULL);
dict.c:503:    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
dict.c:506:    for (table = 0; table <= 1; table++) {
dict.c:537:    integers[1] = d->ht[0].size;
dict.c:539:    integers[3] = (long) d->ht[1].table;
dict.c:540:    integers[4] = d->ht[1].size;
dict.c:541:    integers[5] = d->ht[1].used;
dict.c:546:     * Result = hash(hash(hash(int1)+int2)+int3) ...
dict.c:553:        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;
dict.c:556:        hash = hash ^ (hash >> 14);
dict.c:557:        hash = (hash + (hash << 2)) + (hash << 4); // hash * 21
dict.c:559:        hash = hash + (hash << 31);
dict.c:570:    iter->index = -1;
dict.c:580:    i->safe = 1;
dict.c:586:    while (1) {
dict.c:589:            if (iter->index == -1 && iter->table == 0) {
dict.c:600:                    ht = &iter->d->ht[1];
dict.c:621:    if (!(iter->index == -1 && iter->table == 0)) {
dict.c:644:             * to rehashidx-1 */
dict.c:647:                                            d->ht[1].size -
dict.c:649:            he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :
dict.c:700:    unsigned long j; /* internal hash table id, 0 or 1. */
dict.c:701:    unsigned long tables; /* 1 or 2 tables? */
dict.c:706:    maxsteps = count*10;
dict.c:716:    tables = dictIsRehashing(d) ? 2 : 1;
dict.c:718:    if (tables > 1 && maxsizemask < d->ht[1].sizemask)
dict.c:719:        maxsizemask = d->ht[1].sizemask;
dict.c:728:             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */
dict.c:734:                if (i >= d->ht[1].size)
dict.c:763:        i = (i+1) & maxsizemask;
dict.c:773:    while ((s >>= 1) > 0) {
dict.c:784: * 1) Initially you call the function using a cursor (v) value of 0.
dict.c:810: * by computing the bitwise AND between Hash(key) and SIZE-1
dict.c:811: * (where SIZE-1 is always the mask that is equivalent to taking the rest
dict.c:814: * For example if the current hash table size is 16, the mask is
dict.c:815: * (in binary) 1111. The position of a key in the hash table will always be
dict.c:822: * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).
dict.c:825: * be 111111. The new buckets you obtain by substituting in ??1100
dict.c:826: * with either 0 or 1 can be targeted only by keys we already visited
dict.c:827: * when scanning the bucket 1100 in the smaller hash table.
dict.c:831: * continue iterating using cursors without '1100' at the end, and also
dict.c:835: * 16 to 8, if a combination of the lower three bits (the mask for size 8
dict.c:836: * is 111) were already completely explored, it would not be visited again
dict.c:837: * because we are sure we tried, for example, both 0111 and 1111 (all the
dict.c:844: * table. For example if the current cursor is 101 and we also have a
dict.c:845: * larger table of size 16, we also test (0)101 and (1)101 inside the larger
dict.c:856: * 1) It is possible we return elements more than once. However this is usually
dict.c:870:    dictht *t0, *t1;
dict.c:872:    unsigned long m0, m1;
dict.c:900:        t1 = &d->ht[1];
dict.c:902:        /* Make sure t0 is the smaller and t1 is the bigger table */
dict.c:903:        if (t0->size > t1->size) {
dict.c:904:            t0 = &d->ht[1];
dict.c:905:            t1 = &d->ht[0];
dict.c:909:        m1 = t1->sizemask;
dict.c:924:            if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
dict.c:925:            de = t1->table[v & m1];
dict.c:933:            v |= ~m1;
dict.c:939:        } while (v & (m0 ^ m1));
dict.c:957:    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
dict.c:976:    if (size >= LONG_MAX) return LONG_MAX + 1LU;
dict.c:977:    while(1) {
dict.c:986: * If the key already exists, -1 is returned
dict.c:1000:        return -1;
dict.c:1001:    for (table = 0; table <= 1; table++) {
dict.c:1008:                return -1;
dict.c:1012:        //如果没有rehahs ht[1] 不用查找
dict.c:1020:    _dictClear(d,&d->ht[1],callback);
dict.c:1021:    d->rehashidx = -1;
dict.c:1026:    dict_can_resize = 1;
dict.c:1046:    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
dict.c:1047:    for (table = 0; table <= 1; table++) {
dict.c:1093:        clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;
dict.c:1112:    for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {
dict.c:1117:            (i == DICT_STATS_VECTLEN-1)?">= ":"",
dict.c:1118:            i, clvector[i], ((float)clvector[i]/ht->size)*100);
dict.c:1122:    if (bufsize) buf[bufsize-1] = '\0';
dict.c:1135:        _dictGetStatsHt(buf,bufsize,&d->ht[1],1);
dict.c:1138:    if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
dict.c:1151:int compareCallback(void *privdata, const void *key1, const void *key2) {
dict.c:1152:    int l1,l2;
dict.c:1155:    l1 = sdslen((sds)key1);
dict.c:1157:    if (l1 != l2) return 0;
dict.c:1158:    return memcmp(key1, key2, l1) == 0;
dict.c:1190:        count = strtol(argv[1],NULL,10);
dict.c:1205:        dictRehashMilliseconds(dict,100);
dict.c:1250:        key[0] += 17; /* Change first number to letter. */
dict.h:8: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
dict.h:42:#define DICT_ERR 1
dict.h:62:    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
dict.h:72:    unsigned long sizemask;//2^n-1
dict.h:80:    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
dict.h:84:/* If safe is set to 1 this is a safe iterator, that means, you can call
dict.h:91:    int table, safe;  //table 字典中ht的下标 safe=0 非安全  safe=1 安全
dict.h:135:#define dictCompareKeys(d, key1, key2) \
dict.h:137:        (d)->type->keyCompare((d)->privdata, key1, key2) : \
dict.h:138:        (key1) == (key2))
dict.h:146:#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)
dict.h:147:#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)
dict.h:148:#define dictIsRehashing(d) ((d)->rehashidx != -1)
endianconv.c:16: * Copyright (c) 2011-2012, Salvatore Sanfilippo <antirez at gmail dot com>
endianconv.c:47:/* Toggle the 16 bit unsigned integer pointed by *p from little endian to
endianconv.c:49:void memrev16(void *p) {
endianconv.c:53:    x[0] = x[1];
endianconv.c:54:    x[1] = t;
endianconv.c:65:    t = x[1];
endianconv.c:66:    x[1] = x[2];
endianconv.c:78:    t = x[1];
endianconv.c:79:    x[1] = x[6];
endianconv.c:89:uint16_t intrev16(uint16_t v) {
endianconv.c:90:    memrev16(&v);
endianconv.c:115:    memrev16(buf);
endianconv.h:5: * Copyright (c) 2011-2012, Salvatore Sanfilippo <antirez at gmail dot com>
endianconv.h:39:void memrev16(void *p);
endianconv.h:42:uint16_t intrev16(uint16_t v);
endianconv.h:49:#define memrev16ifbe(p) ((void)(0))
endianconv.h:52:#define intrev16ifbe(v) (v)
endianconv.h:56:#define memrev16ifbe(p) memrev16(p)
endianconv.h:59:#define intrev16ifbe(v) intrev16(v)
evict.c:5: * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>
evict.c:52:#define EVPOOL_SIZE 16
evict.c:80:    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {
evict.c:212:        if (k == 0 && pool[EVPOOL_SIZE-1].key != NULL) {
evict.c:221:            if (pool[EVPOOL_SIZE-1].key == NULL) {
evict.c:226:                sds cached = pool[EVPOOL_SIZE-1].cached;
evict.c:227:                memmove(pool+k+1,pool+k,
evict.c:228:                    sizeof(pool[0])*(EVPOOL_SIZE-k-1));
evict.c:231:                /* No free space on right? Insert at k-1 */
evict.c:237:                memmove(pool,pool+1,sizeof(pool[0])*k);
evict.c:250:            memcpy(pool[k].cached,key,klen+1);
evict.c:268: *          16 bits      8 bits
evict.c:278: * So the remaining 16 bits are used in order to store the "decrement time",
evict.c:279: * a reduced-precision Unix time (we take 16 bits of the time converted
evict.c:297: * 16 bits. The returned time is suitable to be stored as LDT (last decrement
evict.c:305: * the current 16 bits minutes time) considering the time as wrapping
evict.c:322:    //lfu_log_factor可配置默认1.counter越大 baseval越大p越小 counter越难增长
evict.c:323:    double p = 1.0/(baseval*server.lfu_log_factor+1);
evict.c:394: *  'level'     this usually ranges from 0 to 1, and reports the amount of
evict.c:395: *              memory currently used. May be > 1 if we are over the memory
evict.c:504:                for (k = EVPOOL_SIZE-1; k >= 0; k--) {
evict.c:598:            if (server.lazyfree_lazy_eviction && !(keys_freed % 16)) {
evict.c:623:        usleep(1000);
expire.c:5: * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>
expire.c:48: * 1 is returned. Otherwise no operation is performed and 0 is returned.
expire.c:69:        return 1;
expire.c:125:     * 1) Don't test more DBs than we have.
expire.c:136:    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
expire.c:138:    if (timelimit <= 0) timelimit = 1;
expire.c:174:            /* When there are less than 1% filled slots getting random
expire.c:178:                (num*100/slots < 1)) break;
expire.c:219:            if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */
expire.c:222:                    timelimit_exit = 1;
expire.c:233:    latencyAddSampleIfNeeded("expire-cycle",elapsed/1000);
expire.c:277: * to the DB where the keys may exist set to 1. Currently the keys created
expire.c:291:    while(1) {
expire.c:301:            if ((dbids & 1) != 0) {
expire.c:309:                    expired = 1;
expire.c:318:                    new_dbids |= (uint64_t)1 << dbid;
expire.c:322:            dbids >>= 1;
expire.c:337:        if ((cycles % 64) == 0 && mstime()-start > 1) break;
expire.c:369:    dbids |= (uint64_t)1 << db->id;
expire.c:406:    robj *key = c->argv[1], *param = c->argv[2];
expire.c:412:    if (unit == UNIT_SECONDS) when *= 1000;
expire.c:474:    long long expire, ttl = -1;
expire.c:477:    if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
expire.c:481:    /* The key exists. Return -1 if it has no expire, or the actual
expire.c:483:    expire = getExpire(c->db,c->argv[1]);
expire.c:484:    if (expire != -1) {
expire.c:488:    if (ttl == -1) {
expire.c:489:        addReplyLongLong(c,-1);
expire.c:491:        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
expire.c:502:    ttlGenericCommand(c, 1);
expire.c:507:    if (lookupKeyWrite(c->db,c->argv[1])) {
expire.c:508:        if (removeExpire(c->db,c->argv[1])) {
expire.c:519:/* TOUCH key1 [key2 key3 ... keyN] */
expire.c:522:    for (int j = 1; j < c->argc; j++)
fmacros.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
fmacros.h:55:#define _POSIX_C_SOURCE 199506L
geo.c:2: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
geo.c:3: * Copyright (c) 2015-2016, Salvatore Sanfilippo <antirez@gmail.com>.
geo.c:102:        xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
geo.c:104:            "-ERR invalid longitude,latitude pair %f,%f\r\n",xy[0],xy[1]));
geo.c:131:        return 1;
geo.c:133:        return 1000;
geo.c:137:        return 1609.34;
geo.c:141:        return -1;
geo.c:157:        return -1;
geo.c:162:        return -1;
geo.c:165:    double to_meters = extractUnitOrReply(c,argv[1]);
geo.c:167:        return -1;
geo.c:175: * for returning location distances. "5.2145 meters away" is nicer
geo.c:176: * than "5.2144992818115 meters away." We provide 4 digits after the dot
geo.c:180:    char dbuf[128];
geo.c:197:    if (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],
geo.c:206:    gp->latitude = xy[1];
geo.c:226:    /* minex 0 = include min in range; maxex 1 = exclude max in range */
geo.c:228:    zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };
geo.c:295:     * is 101010, since our score is 52 bits we want every element which
geo.c:296:     * is in binary: 101010?????????????????????????????????????????????
geo.c:297:     * Where ? can be 0 or 1.
geo.c:302:     * prefix: 101011, which we align again to 52 bits to get the maximum
geo.c:306:     * 1010100000000000000000000000000000000000000000000000 (included)
geo.c:308:     * 1010110000000000000000000000000000000000000000000000 (excluded).
geo.c:332:    neighbors[1] = n.neighbors.north;
geo.c:389:        return 1;
geo.c:393:        return -1;
geo.c:409:        addReplyError(c, "syntax error. Try GEOADD key [x1] [y1] [name1] "
geo.c:418:    argv[1] = c->argv[1]; /* key */
geo.c:419:    incrRefCount(argv[1]);
geo.c:437:        geohashEncodeWGS84(xy[0], xy[1], GEO_STEP_MAX, &hash);
geo.c:452:#define SORT_ASC 1
geo.c:455:#define RADIUS_COORDS (1<<0)    /* Search around coordinates. */
geo.c:456:#define RADIUS_MEMBER (1<<1)    /* Search around member. */
geo.c:457:#define RADIUS_NOSTORE (1<<2)   /* Do not acceot STORE/STOREDIST option. */
geo.c:463:    robj *key = c->argv[1];
geo.c:465:    int storedist = 0; /* 0 for STORE, 1 for STOREDIST. */
geo.c:494:    double radius_meters = 0, conversion = 1;
geo.c:509:                withdist = 1;
geo.c:511:                withhash = 1;
geo.c:513:                withcoords = 1;
geo.c:518:            } else if (!strcasecmp(arg, "count") && (i+1) < remaining) {
geo.c:519:                if (getLongLongFromObjectOrReply(c, c->argv[base_args+i+1],
geo.c:527:                       (i+1) < remaining &&
geo.c:530:                storekey = c->argv[base_args+i+1];
geo.c:534:                       (i+1) < remaining &&
geo.c:537:                storekey = c->argv[base_args+i+1];
geo.c:538:                storedist = 1;
geo.c:561:        geohashGetAreasByRadiusWGS84(xy[0], xy[1], radius_meters);
geo.c:565:    membersOfAllNeighbors(zobj, georadius, xy[0], xy[1], radius_meters, ga);
geo.c:613:             * as a nested multi-bulk.  Add 1 to account for result value
geo.c:616:                addReplyMultiBulkLen(c, option_length + 1);
geo.c:695:/* GEOHASH key ele1 ele2 ... eleN
geo.c:697: * Returns an array with an 11 characters geohash representation of the
geo.c:700:    char *geoalphabet= "0123456789bcdefghjkmnpqrstuvwxyz";
geo.c:704:    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
geo.c:731:            r[0].min = -180;
geo.c:732:            r[0].max = 180;
geo.c:733:            r[1].min = -90;
geo.c:734:            r[1].max = 90;
geo.c:735:            geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
geo.c:737:            char buf[12];
geo.c:739:            for (i = 0; i < 11; i++) {
geo.c:740:                int idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
geo.c:743:            buf[11] = '\0';
geo.c:744:            addReplyBulkCBuffer(c,buf,11);
geo.c:749:/* GEOPOS key ele1 ele2 ... eleN
geo.c:757:    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
geo.c:776:            addReplyHumanLongDouble(c,xy[1]);
geo.c:781:/* GEODIST key ele1 ele2 [unit]
geo.c:784: * between points ele1 and ele2. If one or more elements are missing NULL
geo.c:787:    double to_meter = 1;
geo.c:800:    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.nullbulk))
geo.c:804:    double score1, score2, xyxy[4];
geo.c:805:    if (zsetScore(zobj, c->argv[2]->ptr, &score1) == C_ERR ||
geo.c:813:    if (!decodeGeohash(score1,xyxy) || !decodeGeohash(score2,xyxy+2))
geo.c:817:            geohashGetDistance(xyxy[0],xyxy[1],xyxy[2],xyxy[3]) / to_meter);
geohash.c:2: * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
geohash.c:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
geohash.c:4: * Copyright (c) 2015-2016, Salvatore Sanfilippo <antirez@gmail.com>.
geohash.c:39: *  | 0,1   | 1,1   |
geohash.c:43: *  | 0,0   | 1,0   |
geohash.c:56:    static const unsigned int S[] = {1, 2, 4, 8, 16};
geohash.c:70:    x = (x | (x << S[1])) & B[1];
geohash.c:71:    y = (y | (y << S[1])) & B[1];
geohash.c:76:    return x | (y << 1);
geohash.c:86:    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};
geohash.c:89:    uint64_t y = interleaved >> 1;
geohash.c:94:    x = (x | (x >> S[1])) & B[1];
geohash.c:95:    y = (y | (y >> S[1])) & B[1];
geohash.c:113:    /* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
geohash.c:147:    lat_offset *= (1ULL << step);
geohash.c:148:    long_offset *= (1ULL << step);
geohash.c:150:    return 1;
geohash.c:155:    geohashGetCoordRange(&r[0], &r[1]);
geohash.c:156:    return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
geohash.c:182:     * Then, for 0-1 coordinate, multiply times scale and add
geohash.c:185:        lat_range.min + (ilato * 1.0 / (1ull << step)) * lat_scale;
geohash.c:187:        lat_range.min + ((ilato + 1) * 1.0 / (1ull << step)) * lat_scale;
geohash.c:189:        long_range.min + (ilono * 1.0 / (1ull << step)) * long_scale;
geohash.c:191:        long_range.min + ((ilono + 1) * 1.0 / (1ull << step)) * long_scale;
geohash.c:193:    return 1;
geohash.c:198:    geohashGetCoordRange(&r[0], &r[1]);
geohash.c:199:    return geohashDecode(r[0], r[1], hash, area);
geohash.c:209:    xy[1] = (area->latitude.min + area->latitude.max) / 2;
geohash.c:210:    return 1;
geohash.c:234:        x = x + (zz + 1);
geohash.c:237:        x = x - (zz + 1);
geohash.c:253:        y = y + (zz + 1);
geohash.c:256:        y = y - (zz + 1);
geohash.c:272:    geohash_move_x(&neighbors->east, 1);
geohash.c:275:    geohash_move_x(&neighbors->west, -1);
geohash.c:279:    geohash_move_y(&neighbors->south, -1);
geohash.c:282:    geohash_move_y(&neighbors->north, 1);
geohash.c:284:    geohash_move_x(&neighbors->north_west, -1);
geohash.c:285:    geohash_move_y(&neighbors->north_west, 1);
geohash.c:287:    geohash_move_x(&neighbors->north_east, 1);
geohash.c:288:    geohash_move_y(&neighbors->north_east, 1);
geohash.c:290:    geohash_move_x(&neighbors->south_east, 1);
geohash.c:291:    geohash_move_y(&neighbors->south_east, -1);
geohash.c:293:    geohash_move_x(&neighbors->south_west, -1);
geohash.c:294:    geohash_move_y(&neighbors->south_west, -1);
geohash.h:2: * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
geohash.h:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
geohash.h:4: * Copyright (c) 2015, Salvatore Sanfilippo <antirez@gmail.com>.
geohash.h:49:/* Limits from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
geohash.h:50:#define GEO_LAT_MIN -85.05112878
geohash.h:51:#define GEO_LAT_MAX 85.05112878
geohash.h:52:#define GEO_LONG_MIN -180
geohash.h:53:#define GEO_LONG_MAX 180
geohash.h:95: * -1:failed
geohash_helper.c:2: * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
geohash_helper.c:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
geohash_helper.c:4: * Copyright (c) 2015-2016, Salvatore Sanfilippo <antirez@gmail.com>.
geohash_helper.c:42:#define D_R (M_PI / 180.0)
geohash_helper.c:43:#define R_MAJOR 6378137.0
geohash_helper.c:44:#define R_MINOR 6356752.3142
geohash_helper.c:46:#define ECCENT (sqrt(1.0 - (RATIO *RATIO)))
geohash_helper.c:49:/// @brief The usual PI/180 constant
geohash_helper.c:50:const double DEG_TO_RAD = 0.017453292519943295769236907684886;
geohash_helper.c:64:    int step = 1;
geohash_helper.c:80:    if (step < 1) step = 1;
geohash_helper.c:87: * and maxium longitude, while bounds[1] - bounds[3] is the minimum and
geohash_helper.c:91: * instance for the coordinates 81.634948934258375 30.561509253718668 and a
geohash_helper.c:94: * min_lon 7.680495, min_lat -33.119473, max_lon 155.589402, max_lat 94.242491
geohash_helper.c:97: * point -1.27579540014266968 61.33421815228281559 is at less than 7000
geohash_helper.c:109:    bounds[1] = latitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
geohash_helper.c:111:    return 1;
geohash_helper.c:128:    min_lat = bounds[1];
geohash_helper.c:154:            < radius_meters) decrease_step = 1;
geohash_helper.c:156:            < radius_meters) decrease_step = 1;
geohash_helper.c:158:            < radius_meters) decrease_step = 1;
geohash_helper.c:160:            < radius_meters) decrease_step = 1;
geohash_helper.c:163:    if (steps > 1 && decrease_step) {
geohash_helper.c:211:double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
geohash_helper.c:212:    double lat1r, lon1r, lat2r, lon2r, u, v;
geohash_helper.c:213:    lat1r = deg_rad(lat1d);
geohash_helper.c:214:    lon1r = deg_rad(lon1d);
geohash_helper.c:217:    u = sin((lat2r - lat1r) / 2);
geohash_helper.c:218:    v = sin((lon2r - lon1r) / 2);
geohash_helper.c:220:           asin(sqrt(u * u + cos(lat1r) * cos(lat2r) * v * v));
geohash_helper.c:223:int geohashGetDistanceIfInRadius(double x1, double y1,
geohash_helper.c:226:    *distance = geohashGetDistance(x1, y1, x2, y2);
geohash_helper.c:228:    return 1;
geohash_helper.c:231:int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
geohash_helper.c:234:    return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
geohash_helper.h:2: * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
geohash_helper.h:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
geohash_helper.h:4: * Copyright (c) 2015, Salvatore Sanfilippo <antirez@gmail.com>.
geohash_helper.h:61:double geohashGetDistance(double lon1d, double lat1d,
geohash_helper.h:63:int geohashGetDistanceIfInRadius(double x1, double y1,
geohash_helper.h:66:int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
help.h:34:    1,
help.h:40:    "1.0.0" },
help.h:45:    "1.0.0" },
help.h:50:    "1.0.0" },
help.h:54:    1,
help.h:59:    1,
help.h:64:    1,
help.h:69:    1,
help.h:139:    12,
help.h:144:    12,
help.h:149:    12,
help.h:154:    12,
help.h:159:    12,
help.h:164:    12,
help.h:169:    12,
help.h:174:    12,
help.h:179:    12,
help.h:184:    12,
help.h:189:    12,
help.h:194:    12,
help.h:199:    12,
help.h:204:    12,
help.h:209:    12,
help.h:214:    12,
help.h:219:    12,
help.h:224:    12,
help.h:229:    12,
help.h:235:    "2.8.13" },
help.h:240:    "2.8.13" },
help.h:245:    "2.8.13" },
help.h:250:    "2.8.13" },
help.h:275:    "1.0.0" },
help.h:280:    "1.0.0" },
help.h:285:    "1.0.0" },
help.h:289:    1,
help.h:290:    "1.0.0" },
help.h:294:    1,
help.h:295:    "1.0.0" },
help.h:300:    "1.0.0" },
help.h:315:    "1.0.0" },
help.h:319:    10,
help.h:322:    "sha1 numkeys key [key ...] arg [arg ...]",
help.h:324:    10,
help.h:330:    "1.2.0" },
help.h:335:    "1.0.0" },
help.h:340:    "1.0.0" },
help.h:345:    "1.2.0" },
help.h:350:    "1.0.0" },
help.h:355:    "1.0.0" },
help.h:359:    13,
help.h:362:    "key member1 member2 [unit]",
help.h:364:    13,
help.h:369:    13,
help.h:374:    13,
help.h:379:    13,
help.h:384:    13,
help.h:389:    1,
help.h:390:    "1.0.0" },
help.h:394:    1,
help.h:399:    1,
help.h:404:    1,
help.h:405:    "1.0.0" },
help.h:484:    1,
help.h:485:    "1.0.0" },
help.h:489:    1,
help.h:490:    "1.0.0" },
help.h:494:    1,
help.h:500:    "1.0.0" },
help.h:505:    "1.0.0" },
help.h:510:    "1.0.0" },
help.h:515:    "1.0.0" },
help.h:525:    "1.0.0" },
help.h:530:    "1.0.0" },
help.h:535:    "1.0.0" },
help.h:545:    "1.0.0" },
help.h:550:    "1.0.0" },
help.h:555:    "1.0.0" },
help.h:560:    "1.0.0" },
help.h:594:    1,
help.h:595:    "1.0.0" },
help.h:605:    "1.0.0" },
help.h:610:    "1.0.0" },
help.h:614:    1,
help.h:615:    "1.0.1" },
help.h:619:    1,
help.h:620:    "1.0.1" },
help.h:625:    "1.2.0" },
help.h:649:    11,
help.h:654:    11,
help.h:659:    11,
help.h:665:    "1.0.0" },
help.h:669:    1,
help.h:700:    "1.0.0" },
help.h:705:    "1.0.0" },
help.h:709:    12,
help.h:714:    12,
help.h:720:    "1.0.0" },
help.h:725:    "1.0.0" },
help.h:740:    "2.8.12" },
help.h:745:    "1.0.0" },
help.h:750:    "1.2.0" },
help.h:755:    "1.0.0" },
help.h:765:    "1.0.0" },
help.h:770:    "1.0.0" },
help.h:780:    "1.0.0" },
help.h:784:    10,
help.h:787:    "sha1 [sha1 ...]",
help.h:789:    10,
help.h:794:    10,
help.h:799:    10,
help.h:804:    10,
help.h:810:    "1.0.0" },
help.h:815:    "1.0.0" },
help.h:820:    "1.0.0" },
help.h:824:    1,
help.h:825:    "1.0.0" },
help.h:829:    1,
help.h:834:    1,
help.h:839:    1,
help.h:840:    "1.0.0" },
help.h:844:    1,
help.h:850:    "1.0.0" },
help.h:855:    "1.0.0" },
help.h:860:    "1.0.0" },
help.h:865:    "1.0.0" },
help.h:870:    "1.0.0" },
help.h:875:    "2.2.12" },
help.h:880:    "1.0.0" },
help.h:885:    "1.0.0" },
help.h:890:    "1.0.0" },
help.h:895:    "1.0.0" },
help.h:900:    "1.0.0" },
help.h:905:    "1.0.0" },
help.h:914:    1,
help.h:925:    "1.0.0" },
help.h:930:    "1.0.0" },
help.h:940:    "1.0.0" },
help.h:950:    "3.2.1" },
help.h:955:    "1.0.0" },
help.h:960:    "1.0.0" },
help.h:989:    14,
help.h:994:    14,
help.h:999:    14,
help.h:1004:    14,
help.h:1009:    14,
help.h:1014:    14,
help.h:1019:    14,
help.h:1024:    14,
help.h:1029:    14,
help.h:1034:    14,
help.h:1039:    14,
help.h:1044:    14,
help.h:1049:    14,
help.h:1055:    "1.2.0" },
help.h:1060:    "1.2.0" },
help.h:1070:    "1.2.0" },
help.h:1095:    "1.2.0" },
help.h:1105:    "1.0.5" },
help.h:1115:    "1.2.0" },
help.h:1130:    "1.2.0" },
help.h:1135:    "1.2.0" },
help.h:1160:    "1.2.0" },
hyperloglog.c:4: * Copyright (c) 2014, Salvatore Sanfilippo <antirez at gmail dot com>
hyperloglog.c:39: * * The use of a 64 bit hash function as proposed in [1], in order to don't
hyperloglog.c:40: *   limited to cardinalities up to 10^9, at the cost of just 1 additional
hyperloglog.c:42: * * The use of 16384 6-bit registers for a great level of accuracy, using
hyperloglog.c:43: *   a total of 12k per key.
hyperloglog.c:45: * * No attempt is made to compress the data structure as in [1]. Also the
hyperloglog.c:48: *   is performed for values near 2^32 as in [1].
hyperloglog.c:50: * [1] Heule, Nunkesser, Hall: HyperLogLog in Practice: Algorithmic
hyperloglog.c:58: * 1) A "dense" representation where every entry is represented by
hyperloglog.c:68: * Both the dense and sparse representation have a 16 byte header as follows:
hyperloglog.c:94: * |11000000|22221111|33333322|55444444 ....     |
hyperloglog.c:108: * by the six bits 'xxxxxx', plus 1, means that there are N registers set
hyperloglog.c:109: * to 0. This opcode can represent from 1 to 64 contiguous registers set
hyperloglog.c:112: * XZERO opcode is represented by two bytes 01xxxxxx yyyyyyyy. The 14-bit
hyperloglog.c:114: * 'yyyyyyyy' as least significant bits, plus 1, means that there are N
hyperloglog.c:115: * registers set to 0. This opcode can represent from 0 to 16384 contiguous
hyperloglog.c:118: * VAL opcode is represented as 1vvvvvxx. It contains a 5-bit integer
hyperloglog.c:122: * incremented by one. This opcode can represent values from 1 to 32,
hyperloglog.c:123: * repeated from 1 to 4 times.
hyperloglog.c:132: * representation of an empty HLL is just: XZERO:16384.
hyperloglog.c:134: * An HLL having only 3 non-zero registers at position 1000, 1020, 1021
hyperloglog.c:138: * XZERO:1000 (Registers 0-999 are set to 0)
hyperloglog.c:139: * VAL:2,1    (1 register set to value 2, that is register 1000)
hyperloglog.c:140: * ZERO:19    (Registers 1001-1019 set to 0)
hyperloglog.c:141: * VAL:3,2    (2 registers set to value 3, that is registers 1020,1021)
hyperloglog.c:142: * XZERO:15362 (Registers 1022-16383 set to 0)
hyperloglog.c:145: * of 12k in order to represent the HLL registers. In general for low
hyperloglog.c:149: * The following table shows average cardinality vs bytes used, 100
hyperloglog.c:154: * 100 267
hyperloglog.c:158: * 500 1033
hyperloglog.c:159: * 600 1205
hyperloglog.c:160: * 700 1375
hyperloglog.c:161: * 800 1544
hyperloglog.c:162: * 900 1713
hyperloglog.c:163: * 1000 1882
hyperloglog.c:167: * 5000 7138
hyperloglog.c:171: * 9000 10088
hyperloglog.c:172: * 10000 10591
hyperloglog.c:174: * The dense representation uses 12288 bytes, so there is a big win up to
hyperloglog.c:191:#define HLL_INVALIDATE_CACHE(hdr) (hdr)->card[7] |= (1<<7)
hyperloglog.c:192:#define HLL_VALID_CACHE(hdr) (((hdr)->card[7] & (1<<7)) == 0)
hyperloglog.c:194:#define HLL_P 14 /* The greater is P, the smaller the error. */
hyperloglog.c:197:#define HLL_REGISTERS (1<<HLL_P) /* With P=14, 16384 registers. */
hyperloglog.c:198:#define HLL_P_MASK (HLL_REGISTERS-1) /* Mask to index register. */
hyperloglog.c:200:#define HLL_REGISTER_MAX ((1<<HLL_BITS)-1)
hyperloglog.c:204:#define HLL_SPARSE 1 /* Sparse encoding. */
hyperloglog.c:206:#define HLL_MAX_ENCODING 1
hyperloglog.c:221: * |11000000|22221111|33333322|55444444
hyperloglog.c:228: * Example, we want to access to counter at pos = 1 ("111111" in the
hyperloglog.c:236: *   |11000000|  <- Our byte at b0
hyperloglog.c:247: *   |11000000|  <- Initial value of b0
hyperloglog.c:248: *   |00000011|  <- After right shift of 6 pos.
hyperloglog.c:251: * Left shift b1 of bits 8-fb bits (2 bits)
hyperloglog.c:254: *   |22221111|  <- Initial value of b1
hyperloglog.c:255: *   |22111100|  <- After left shift of 2 bits.
hyperloglog.c:258: * OR the two bits, and finally AND with 111111 (63 in decimal) to
hyperloglog.c:262: *   |00000011|  <- b0 right shifted
hyperloglog.c:263: *   |22111100|  <- b1 left shifted
hyperloglog.c:264: *   |22111111|  <- b0 OR b1
hyperloglog.c:265: *   |  111111|  <- (b0 OR b1) AND 63, our value.
hyperloglog.c:274: *   |11000000|  <- Our byte at b0
hyperloglog.c:292: * Let's try with 'pos' = 1, so our first byte at 'b' is 0,
hyperloglog.c:297: *   |11000000|  <- Our byte at b0
hyperloglog.c:305: *   |00111111|  <- "mask" starts at 63
hyperloglog.c:306: *   |11000000|  <- "mask" after left shift of "ls" bits.
hyperloglog.c:307: *   |00111111|  <- "mask" after invert.
hyperloglog.c:313: * Now let's focus on the next byte b1:
hyperloglog.c:316: *   |22221111|  <- Initial value of b1
hyperloglog.c:323: *   |00111111|  <- "mask" set at 2&6-1
hyperloglog.c:324: *   |00001111|  <- "mask" after the right shift by 8-fb = 2 bits
hyperloglog.c:325: *   |11110000|  <- "mask" after bitwise not.
hyperloglog.c:328: * Now we can mask it with b+1 to clear the old bits, and bitwise-OR
hyperloglog.c:332:/* Note: if we access the last counter, we will also access the b+1 byte
hyperloglog.c:335: * to allocate 1 byte more explicitly). */
hyperloglog.c:345:    unsigned long b1 = _p[_byte+1]; \
hyperloglog.c:346:    target = ((b0 >> _fb) | (b1 << _fb8)) & HLL_REGISTER_MAX; \
hyperloglog.c:359:    _p[_byte+1] &= ~(HLL_REGISTER_MAX >> _fb8); \
hyperloglog.c:360:    _p[_byte+1] |= _v >> _fb8; \
hyperloglog.c:365:#define HLL_SPARSE_XZERO_BIT 0x40 /* 01xxxxxx */
hyperloglog.c:366:#define HLL_SPARSE_VAL_BIT 0x80 /* 1vvvvvxx */
hyperloglog.c:370:#define HLL_SPARSE_ZERO_LEN(p) (((*(p)) & 0x3f)+1)
hyperloglog.c:371:#define HLL_SPARSE_XZERO_LEN(p) (((((*(p)) & 0x3f) << 8) | (*((p)+1)))+1)
hyperloglog.c:372:#define HLL_SPARSE_VAL_VALUE(p) ((((*(p)) >> 2) & 0x1f)+1)
hyperloglog.c:373:#define HLL_SPARSE_VAL_LEN(p) (((*(p)) & 0x3)+1)
hyperloglog.c:377:#define HLL_SPARSE_XZERO_MAX_LEN 16384
hyperloglog.c:379:    *(p) = (((val)-1)<<2|((len)-1))|HLL_SPARSE_VAL_BIT; \
hyperloglog.c:382:    *(p) = (len)-1; \
hyperloglog.c:385:    int _l = (len)-1; \
hyperloglog.c:387:    *((p)+1) = (_l&0xff); \
hyperloglog.c:389:#define HLL_ALPHA_INF 0.721347520444481703680 /* constant for 0.5/ln(2) */
hyperloglog.c:397:    const uint64_t m = 0xc6a4a7935bd1e995;
hyperloglog.c:414:        k |= (uint64_t) data[1] << 8;
hyperloglog.c:415:        k |= (uint64_t) data[2] << 16;
hyperloglog.c:436:    case 3: h ^= (uint64_t)data[2] << 16; /* fall-thru */
hyperloglog.c:437:    case 2: h ^= (uint64_t)data[1] << 8; /* fall-thru */
hyperloglog.c:438:    case 1: h ^= (uint64_t)data[0];
hyperloglog.c:449: * of the pattern 000..1 of the element hash. As a side effect 'regp' is
hyperloglog.c:457:     * as index). The max run can be 64-P+1 = Q+1 bits.
hyperloglog.c:459:     * Note that the final "1" ending the sequence of zeroes must be
hyperloglog.c:460:     * included in the count, so if we find "001" the count is 3, and
hyperloglog.c:461:     * the smallest count possible is no zeroes at all, just a 1 bit
hyperloglog.c:462:     * at the first position, that is a count of 1.
hyperloglog.c:465:     * there are high probabilities to find a 1 after a few iterations. */
hyperloglog.c:466:    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);
hyperloglog.c:469:    hash |= ((uint64_t)1<<HLL_Q); /* Make sure the loop terminates
hyperloglog.c:470:                                     and count will be <= Q+1. */
hyperloglog.c:471:    bit = 1;
hyperloglog.c:472:    count = 1; /* Initialized to 1 since we count the "00000...1" pattern. */
hyperloglog.c:475:        bit <<= 1;
hyperloglog.c:491: * the approximated cardinality changed, 1 is returned. Otherwise 0
hyperloglog.c:499:        return 1;
hyperloglog.c:522:    /* Redis default is to use 16384 registers 6 bits each. The code works
hyperloglog.c:525:    if (HLL_REGISTERS == 16384 && HLL_BITS == 6) {
hyperloglog.c:527:        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
hyperloglog.c:528:                      r10, r11, r12, r13, r14, r15;
hyperloglog.c:529:        for (j = 0; j < 1024; j++) {
hyperloglog.c:530:            /* Handle 16 registers per iteration. */
hyperloglog.c:532:            r1 = (r[0] >> 6 | r[1] << 2) & 63;
hyperloglog.c:533:            r2 = (r[1] >> 4 | r[2] << 4) & 63;
hyperloglog.c:541:            r10 = (r[7] >> 4 | r[8] << 4) & 63;
hyperloglog.c:542:            r11 = (r[8] >> 2) & 63;
hyperloglog.c:543:            r12 = r[9] & 63;
hyperloglog.c:544:            r13 = (r[9] >> 6 | r[10] << 2) & 63;
hyperloglog.c:545:            r14 = (r[10] >> 4 | r[11] << 4) & 63;
hyperloglog.c:546:            r15 = (r[11] >> 2) & 63;
hyperloglog.c:549:            reghisto[r1]++;
hyperloglog.c:558:            reghisto[r10]++;
hyperloglog.c:559:            reghisto[r11]++;
hyperloglog.c:560:            reghisto[r12]++;
hyperloglog.c:561:            reghisto[r13]++;
hyperloglog.c:562:            reghisto[r14]++;
hyperloglog.c:563:            reghisto[r15]++;
hyperloglog.c:565:            r += 12;
hyperloglog.c:646: * On success, the function returns 1 if the cardinality changed, or 0
hyperloglog.c:648: * On error (if the representation is invalid) -1 is returned.
hyperloglog.c:671:    /* Step 1: we need to locate the opcode we need to modify to check
hyperloglog.c:688:        oplen = 1;
hyperloglog.c:698:        if (index <= first+span-1) break;
hyperloglog.c:703:    if (span == 0) return -1; /* Invalid format. */
hyperloglog.c:705:    next = HLL_SPARSE_IS_XZERO(p) ? p+2 : p+1;
hyperloglog.c:712:        is_zero = 1;
hyperloglog.c:715:        is_xzero = 1;
hyperloglog.c:718:        is_val = 1;
hyperloglog.c:740:     * B) If it is a VAL opcode with len = 1 (representing only our
hyperloglog.c:749:        if (runlen == 1) {
hyperloglog.c:750:            HLL_SPARSE_VAL_SET(p,count,1);
hyperloglog.c:755:    /* C) Another trivial to handle case is a ZERO opcode with a len of 1.
hyperloglog.c:756:     * We can just replace it with a VAL opcode with our value and len of 1. */
hyperloglog.c:757:    if (is_zero && runlen == 1) {
hyperloglog.c:758:        HLL_SPARSE_VAL_SET(p,count,1);
hyperloglog.c:765:     * and is either currently represented by a VAL opcode with len > 1,
hyperloglog.c:766:     * by a ZERO opcode with len > 1, or by an XZERO opcode.
hyperloglog.c:778:    int last = first+span-1; /* Last register covered by the sequence. */
hyperloglog.c:793:        HLL_SPARSE_VAL_SET(n,count,1);
hyperloglog.c:814:        HLL_SPARSE_VAL_SET(n,count,1);
hyperloglog.c:828:     int oldlen = is_xzero ? 2 : 1;
hyperloglog.c:856:        if (p+1 < end && HLL_SPARSE_IS_VAL(p+1)) {
hyperloglog.c:857:            int v1 = HLL_SPARSE_VAL_VALUE(p);
hyperloglog.c:858:            int v2 = HLL_SPARSE_VAL_VALUE(p+1);
hyperloglog.c:859:            if (v1 == v2) {
hyperloglog.c:860:                int len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+1);
hyperloglog.c:862:                    HLL_SPARSE_VAL_SET(p+1,v1,len);
hyperloglog.c:863:                    memmove(p,p+1,end-p);
hyperloglog.c:864:                    sdsIncrLen(o->ptr,-1);
hyperloglog.c:879:    return 1;
hyperloglog.c:882:    if (hllSparseToDense(o) == C_ERR) return -1; /* Corrupted HLL. */
hyperloglog.c:886:     * conversion. However the result must be 1, since if we need to
hyperloglog.c:893:    serverAssert(dense_retval == 1);
hyperloglog.c:934:    if (idx != HLL_REGISTERS && invalid) *invalid = 1;
hyperloglog.c:956:            reghisto[bytes[1]]++;
hyperloglog.c:970: * Otmar Ertl, arXiv:1702.01284 */
hyperloglog.c:972:    if (x == 1.) return INFINITY;
hyperloglog.c:974:    double y = 1;
hyperloglog.c:987: * Otmar Ertl, arXiv:1702.01284 */
hyperloglog.c:989:    if (x == 0. || x == 1.) return 0.;
hyperloglog.c:991:    double y = 1.0;
hyperloglog.c:992:    double z = 1 - x;
hyperloglog.c:997:        z -= pow(1 - x, 2)*y;
hyperloglog.c:1017:    /* Note that reghisto size could be just HLL_Q+2, becuase HLL_Q+1 is
hyperloglog.c:1018:     * the maximum frequency of the "000...1" sequence the hash function is
hyperloglog.c:1038:     * Otmar Ertl, arXiv:1702.01284 */
hyperloglog.c:1039:    double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);
hyperloglog.c:1040:    for (j = HLL_Q; j >= 1; --j) {
hyperloglog.c:1056:    default: return -1; /* Invalid representation. */
hyperloglog.c:1120:                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
hyperloglog.c:1161:    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
hyperloglog.c:1180:/* PFADD var ele ele ele ... ele => :0 or :1 */
hyperloglog.c:1182:    robj *o = lookupKeyWrite(c->db,c->argv[1]);
hyperloglog.c:1191:        dbAdd(c->db,c->argv[1],o);
hyperloglog.c:1195:        o = dbUnshareStringValue(c->db,c->argv[1],o);
hyperloglog.c:1202:        case 1:
hyperloglog.c:1205:        case -1:
hyperloglog.c:1212:        signalModifiedKey(c->db,c->argv[1]);
hyperloglog.c:1213:        notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
hyperloglog.c:1226:    /* Case 1: multi-key keys, cardinality of the union.
hyperloglog.c:1239:        for (j = 1; j < c->argc; j++) {
hyperloglog.c:1262:    o = lookupKeyWrite(c->db,c->argv[1]);
hyperloglog.c:1269:        o = dbUnshareStringValue(c->db,c->argv[1],o);
hyperloglog.c:1276:            card |= (uint64_t)hdr->card[1] << 8;
hyperloglog.c:1277:            card |= (uint64_t)hdr->card[2] << 16;
hyperloglog.c:1292:            hdr->card[1] = (card >> 8) & 0xff;
hyperloglog.c:1293:            hdr->card[2] = (card >> 16) & 0xff;
hyperloglog.c:1303:            signalModifiedKey(c->db,c->argv[1]);
hyperloglog.c:1310:/* PFMERGE dest src1 src2 src3 ... srcN => OK */
hyperloglog.c:1321:    for (j = 1; j < c->argc; j++) {
hyperloglog.c:1330:        if (hdr->encoding == HLL_DENSE) use_dense = 1;
hyperloglog.c:1341:    robj *o = lookupKeyWrite(c->db,c->argv[1]);
hyperloglog.c:1347:        dbAdd(c->db,c->argv[1],o);
hyperloglog.c:1352:        o = dbUnshareStringValue(c->db,c->argv[1],o);
hyperloglog.c:1376:    signalModifiedKey(c->db,c->argv[1]);
hyperloglog.c:1379:    notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
hyperloglog.c:1389:#define HLL_TEST_CYCLES 1000
hyperloglog.c:1397:    /* Test 1: access registers.
hyperloglog.c:1436:    double relerr = 1.04/sqrt(HLL_REGISTERS);
hyperloglog.c:1437:    int64_t checkpoint = 1;
hyperloglog.c:1440:    for (j = 1; j <= 10000000; j++) {
hyperloglog.c:1466:            /* Adjust the max error we expect for cardinality 10
hyperloglog.c:1470:            if (j == 10) maxerr = 1;
hyperloglog.c:1480:            checkpoint *= 10;
hyperloglog.c:1495:    char *cmd = c->argv[1]->ptr;
hyperloglog.c:1582:            conv = 1;
intset.c:2: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
intset.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
intset.c:39: * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */
intset.c:40:#define INTSET_ENC_INT16 (sizeof(int16_t))
intset.c:48:    else if (v < INT16_MIN || v > INT16_MAX)
intset.c:51:        return INTSET_ENC_INT16;
intset.c:58:    int16_t v16;
intset.c:69:        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));
intset.c:70:        memrev16ifbe(&v16);
intset.c:71:        return v16;
intset.c:91:        ((int16_t*)is->contents)[pos] = value;
intset.c:92:        memrev16ifbe(((int16_t*)is->contents)+pos);
intset.c:99:    is->encoding = intrev32ifbe(INTSET_ENC_INT16);
intset.c:111:/* Search for the position of "value". Return 1 when the value was found and
intset.c:116:    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
intset.c:117:    int64_t cur = -1;
intset.c:136:        mid = ((unsigned int)min + (unsigned int)max) >> 1;
intset.c:139:            min = mid+1;
intset.c:141:            max = mid-1;
intset.c:149:        return 1;
intset.c:161:    int prepend = value < 0 ? 1 : 0;
intset.c:165:    is = intsetResize(is,intrev32ifbe(is->length)+1);
intset.c:179:    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
intset.c:197:        src = (int16_t*)is->contents+from;
intset.c:198:        dst = (int16_t*)is->contents+to;
intset.c:199:        bytes *= sizeof(int16_t);
intset.c:208:    if (success) *success = 1;
intset.c:225:        is = intsetResize(is,intrev32ifbe(is->length)+1);
intset.c:226:        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
intset.c:230:    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
intset.c:244:        if (success) *success = 1;
intset.c:247:        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
intset.c:248:        is = intsetResize(is,len-1);
intset.c:249:        is->length = intrev32ifbe(len-1);
intset.c:266: * out of range the function returns 0, when in range it returns 1. */
intset.c:270:        return 1;
intset.c:299:    exit(1);
intset.c:310:    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
intset.c:313:#define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))
intset.c:320:    uint64_t mask = (1<<bits)-1;
intset.c:336:    for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {
intset.c:339:        if (encoding == INTSET_ENC_INT16) {
intset.c:340:            int16_t *i16 = (int16_t*)is->contents;
intset.c:341:            assert(i16[i] < i16[i+1]);
intset.c:344:            assert(i32[i] < i32[i+1]);
intset.c:347:            assert(i64[i] < i64[i+1]);
intset.c:363:        assert(_intsetValueEncoding(-32768) == INTSET_ENC_INT16);
intset.c:364:        assert(_intsetValueEncoding(+32767) == INTSET_ENC_INT16);
intset.c:367:        assert(_intsetValueEncoding(-2147483648) == INTSET_ENC_INT32);
intset.c:368:        assert(_intsetValueEncoding(+2147483647) == INTSET_ENC_INT32);
intset.c:369:        assert(_intsetValueEncoding(-2147483649) == INTSET_ENC_INT64);
intset.c:370:        assert(_intsetValueEncoding(+2147483648) == INTSET_ENC_INT64);
intset.c:390:        for (i = 0; i < 1024; i++) {
intset.c:399:    printf("Upgrade from int16 to int32: "); {
intset.c:402:        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);
intset.c:411:        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);
intset.c:420:    printf("Upgrade from int16 to int64: "); {
intset.c:426:        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);
intset.c:435:        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);
intset.c:466:        long num = 100000, size = 10000;
intset.c:473:        for (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);
intset.c:479:        int i, v1, v2;
intset.c:482:            v1 = rand() % 0xfff;
intset.c:483:            is = intsetAdd(is,v1,NULL);
intset.c:484:            assert(intsetFind(is,v1));
intset.h:2: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
intset.h:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
latency.c:8: * Copyright (c) 2014, Salvatore Sanfilippo <antirez at gmail dot com>
latency.c:39:int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {
latency.c:41:    return strcmp(key1,key2) == 0;
latency.c:62:/* Returns 1 if Transparent Huge Pages support is enabled in the kernel.
latency.c:65:    char buf[1024];
latency.c:74:    return (strstr(buf,"[never]") == NULL) ? 1 : 0;
latency.c:82:    return zmalloc_get_smap_bytes_by_field("AnonHugePages:",-1);
latency.c:116:    prev = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;
latency.c:179:        if (ls->samples == 1) {
latency.c:200:        if (ls->period == 0) ls->period = 1;
latency.c:260:        if (eventnum == 1) {
latency.c:277:            if (server.stat_fork_rate < 10) {
latency.c:279:                advise_better_vm = 1;
latency.c:283:                advise_better_vm = 1;
latency.c:285:            } else if (server.stat_fork_rate < 100) {
latency.c:298:                advise_slowlog_enabled = 1;
latency.c:300:            } else if (server.slowlog_log_slower_than/1000 >
latency.c:303:                advise_slowlog_tuning = 1;
latency.c:306:            advise_slowlog_inspect = 1;
latency.c:307:            advise_large_objects = 1;
latency.c:313:            advise_scheduler = 1;
latency.c:319:            advise_local_disk = 1;
latency.c:320:            advise_disk_contention = 1;
latency.c:321:            advise_ssd = 1;
latency.c:322:            advise_data_writeback = 1;
latency.c:327:            advise_no_appendfsync = 1;
latency.c:328:            advise_data_writeback = 1;
latency.c:329:            advise_ssd = 1;
latency.c:334:            advise_local_disk = 1;
latency.c:335:            advise_data_writeback = 1;
latency.c:336:            advise_ssd = 1;
latency.c:341:            advise_relax_fsync_policy = 1;
latency.c:347:            advise_disk_contention = 1;
latency.c:348:            advise_local_disk = 1;
latency.c:354:            advise_write_load_info = 1;
latency.c:355:            advise_data_writeback = 1;
latency.c:356:            advise_ssd = 1;
latency.c:357:            advise_local_disk = 1;
latency.c:363:            advise_hz = 1;
latency.c:364:            advise_large_objects = 1;
latency.c:370:            advise_large_objects = 1;
latency.c:375:            advise_mass_eviction = 1;
latency.c:379:        report = sdscatlen(report,"\n",1);
latency.c:385:        advise_disable_thp = 1;
latency.c:404:            report = sdscatprintf(report,"- There are latency issues with potentially slow commands you are using. Try to enable the Slow Log Redis feature using the command 'CONFIG SET slowlog-log-slower-than %llu'. If the Slow log is disabled Redis is not able to log slow commands execution for you.\n", (unsigned long long)server.latency_monitor_threshold*1000);
latency.c:408:            report = sdscatprintf(report,"- Your current Slow Log configuration only logs events that are slower than your configured latency monitor threshold. Please use 'CONFIG SET slowlog-log-slower-than %llu'.\n", (unsigned long long)server.latency_monitor_threshold*1000);
latency.c:418:            "  1) Lower the system load.\n"
latency.c:421:            "  4) Check with 'redis-cli --intrinsic-latency 100' what is the intrinsic latency in your system.\n"
latency.c:454:        if (advise_hz && server.hz < 100) {
latency.c:455:            report = sdscat(report,"- In order to make the Redis keys expiring process more incremental, try to set the 'hz' configuration parameter to 100 using 'CONFIG SET hz 100'.\n");
latency.c:505:        int last = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;
latency.c:554:        graph = sdscatlen(graph,"-",1);
latency.c:555:    graph = sdscatlen(graph,"\n",1);
latency.c:582:    if (!strcasecmp(c->argv[1]->ptr,"history") && c->argc == 3) {
latency.c:590:    } else if (!strcasecmp(c->argv[1]->ptr,"graph") && c->argc == 3) {
latency.c:604:    } else if (!strcasecmp(c->argv[1]->ptr,"latest") && c->argc == 2) {
latency.c:607:    } else if (!strcasecmp(c->argv[1]->ptr,"doctor") && c->argc == 2) {
latency.c:613:    } else if (!strcasecmp(c->argv[1]->ptr,"reset") && c->argc >= 2) {
latency.c:624:    } else if (!strcasecmp(c->argv[1]->ptr,"help") && c->argc >= 2) {
latency.h:6: * Copyright (c) 2014, Salvatore Sanfilippo <antirez at gmail dot com>
latency.h:37:#define LATENCY_TS_LEN 160 /* History length for every monitored event. */
lazyfree.c:20: * For strings the function always returns 1.
lazyfree.c:45:        return 1; /* Everything else is a single allocation. */
lazyfree.c:75:        if (free_effort > LAZYFREE_THRESHOLD && val->refcount == 1) {
lazyfree.c:76:            atomicIncr(lazyfree_objects,1);
lazyfree.c:87:        return 1;
lazyfree.c:96:    if (free_effort > LAZYFREE_THRESHOLD && o->refcount == 1) {
lazyfree.c:97:        atomicIncr(lazyfree_objects,1);
lazyfree.c:108:    dict *oldht1 = db->dict, *oldht2 = db->expires;
lazyfree.c:111:    atomicIncr(lazyfree_objects,dictSize(oldht1));
lazyfree.c:112:    bioCreateBackgroundJob(BIO_LAZY_FREE,NULL,oldht1,oldht2);
lazyfree.c:131:    atomicDecr(lazyfree_objects,1);
lazyfree.c:139:void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2) {
lazyfree.c:140:    size_t numkeys = dictSize(ht1);
lazyfree.c:141:    dictRelease(ht1);
listpack.c:7: * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
listpack.c:45:#define LP_HDR_SIZE 6       /* 32 bit total len + 16 bit number of elements. */
listpack.c:46:#define LP_HDR_NUMELE_UNKNOWN UINT16_MAX
listpack.c:51:#define LP_ENCODING_STRING 1
listpack.c:52://0xxxxxxx 7位无符号整型0- 127
listpack.c:56://10aaaaaa  6位长度的字符串 0~63长度的字符串
listpack.c:60://110aaaaa bbbbbbbb 13位有符号的整数-2048 - 2047
listpack.c:61:#define LP_ENCODING_13BIT_INT 0xC0
listpack.c:62:#define LP_ENCODING_13BIT_INT_MASK 0xE0
listpack.c:63:#define LP_ENCODING_IS_13BIT_INT(byte) (((byte)&LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT)
listpack.c:64://1110aaaa bbbbbbbb 12位字符串长度 0-4096
listpack.c:65:#define LP_ENCODING_12BIT_STR 0xE0
listpack.c:66:#define LP_ENCODING_12BIT_STR_MASK 0xF0
listpack.c:67:#define LP_ENCODING_IS_12BIT_STR(byte) (((byte)&LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR)
listpack.c:68://11110001 aaaaaaaa bbbbbbbb 16位有符号整型 -32768~32767
listpack.c:69:#define LP_ENCODING_16BIT_INT 0xF1
listpack.c:70:#define LP_ENCODING_16BIT_INT_MASK 0xFF
listpack.c:71:#define LP_ENCODING_IS_16BIT_INT(byte) (((byte)&LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT)
listpack.c:72://11110010 aaaaaaaa bbbbbbbb cccccccc 24位有符号整型 -8388608 ~ 8388607
listpack.c:76://11110011 aaaaaaaa bbbbbbbb cccccccc dddddddd 32位有符号整型 -2147483648~2147483647
listpack.c:80://11110100 aaaaaaa bbbbbbbb cccccccc dddddddd eeeeeeee ffffffff gggggggg hhhhhhhh  64位有符号整型
listpack.c:84://11110000 aaaaaaaa bbbbbbbb cccccccc ddddddddd 32长度的字符串 32长度的字符串
listpack.c:90://获得6 12 32 64 位字符串长度
listpack.c:92:#define LP_ENCODING_12BIT_STR_LEN(p) ((((p)[0] & 0xF) << 8) | (p)[1])
listpack.c:93:#define LP_ENCODING_32BIT_STR_LEN(p) (((uint32_t)(p)[1]<<0) | \
listpack.c:95:                                      ((uint32_t)(p)[3]<<16) | \
listpack.c:99:                                      ((uint32_t)(p)[1]<<8) | \
listpack.c:100:                                      ((uint32_t)(p)[2]<<16) | \
listpack.c:107:    (p)[1] = ((v)>>8)&0xff; \
listpack.c:108:    (p)[2] = ((v)>>16)&0xff; \
listpack.c:118: * The function returns 1 if the string could be parsed into a (non-overflowing)
listpack.c:136: * Copyright(C) 2011, Pieter Noordhuis
listpack.c:137: * Copyright(C) 2011, Salvatore Sanfilippo
listpack.c:151:    if (slen == 1 && p[0] == '0') {
listpack.c:153:        return 1;
listpack.c:157:        negative = 1;
listpack.c:165:    /* First digit should be 1-9, otherwise the string should just be 0. */
listpack.c:166:    if (p[0] >= '1' && p[0] <= '9') {
listpack.c:169:    } else if (p[0] == '0' && slen == 1) {
listpack.c:171:        return 1;
listpack.c:177:        if (v > (UINT64_MAX / 10)) /* Overflow. */
listpack.c:179:        v *= 10;
listpack.c:193:        if (v > ((uint64_t)(-(INT64_MIN+1))+1)) /* Overflow. */
listpack.c:201:    return 1;
listpack.c:209:    unsigned char *lp = lp_malloc(LP_HDR_SIZE+1);
listpack.c:211:    lpSetTotalBytes(lp,LP_HDR_SIZE+1);//赋值长度
listpack.c:236:        if (v >= 0 && v <= 127) {
listpack.c:237:            /* Single byte 0-127 integer. */
listpack.c:239:            *enclen = 1;
listpack.c:241:            /* 13 bit integer. */
listpack.c:242:            if (v < 0) v = ((int64_t)1<<13)+v;
listpack.c:243:            intenc[0] = (v>>8)|LP_ENCODING_13BIT_INT;
listpack.c:244:            intenc[1] = v&0xff;
listpack.c:247:            /* 16 bit integer. */
listpack.c:248:            if (v < 0) v = ((int64_t)1<<16)+v;
listpack.c:249:            intenc[0] = LP_ENCODING_16BIT_INT;
listpack.c:250:            intenc[1] = v&0xff;
listpack.c:255:            if (v < 0) v = ((int64_t)1<<24)+v;
listpack.c:257:            intenc[1] = v&0xff;
listpack.c:259:            intenc[3] = v>>16;
listpack.c:261:        } else if (v >= -2147483648 && v <= 2147483647) {
listpack.c:263:            if (v < 0) v = ((int64_t)1<<32)+v;
listpack.c:265:            intenc[1] = v&0xff;
listpack.c:267:            intenc[3] = (v>>16)&0xff;
listpack.c:274:            intenc[1] = uv&0xff;
listpack.c:276:            intenc[3] = (uv>>16)&0xff;
listpack.c:286:        if (size < 64) *enclen = 1+size;
listpack.c:296: * 1 to 5. If 'buf' is NULL the function just returns the number of bytes
listpack.c:299:    if (l <= 127) {
listpack.c:301:        return 1;
listpack.c:302:    } else if (l < 16383) {
listpack.c:305:            buf[1] = (l&127)|128;
listpack.c:308:    } else if (l < 2097151) {
listpack.c:310:            buf[0] = l>>14;
listpack.c:311:            buf[1] = ((l>>7)&127)|128;
listpack.c:312:            buf[2] = (l&127)|128;
listpack.c:317:            buf[0] = l>>21;
listpack.c:318:            buf[1] = ((l>>14)&127)|128;
listpack.c:319:            buf[2] = ((l>>7)&127)|128;
listpack.c:320:            buf[3] = (l&127)|128;
listpack.c:326:            buf[1] = ((l>>21)&127)|128;
listpack.c:327:            buf[2] = ((l>>14)&127)|128;
listpack.c:328:            buf[3] = ((l>>7)&127)|128;
listpack.c:329:            buf[4] = (l&127)|128;
listpack.c:341:        val |= (uint64_t)(p[0] & 127) << shift;
listpack.c:342:        if (!(p[0] & 128)) break;
listpack.c:346:    } while(1);
listpack.c:349://6位 12 64位长度的字符串写入 
listpack.c:358:        memcpy(buf+1,s,len);
listpack.c:360:        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
listpack.c:361:        buf[1] = len & 0xff;
listpack.c:365:        buf[1] = len & 0xff;
listpack.c:367:        buf[3] = (len >> 16) & 0xff;
listpack.c:378:    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
listpack.c:379:    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
listpack.c:380:    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
listpack.c:381:    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
listpack.c:385:    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
listpack.c:387:    if (p[0] == LP_EOF) return 1;
listpack.c:424:    return p-prevlen+1; /* Seek the first byte of the previous entry. */
listpack.c:439:    unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
listpack.c:443://如果数量超过uint16_max则表示数量太多从新遍历获取
listpack.c:494: * integer encoded with value 12345678900000000 + <unrecognized byte>, this may
listpack.c:517:        return p+1;
listpack.c:518:    } else if (LP_ENCODING_IS_13BIT_INT(p[0])) {
listpack.c:519:        uval = ((p[0]&0x1f)<<8) | p[1];
listpack.c:520:        negstart = (uint64_t)1<<12;
listpack.c:521:        negmax = 8191;
listpack.c:522:    } else if (LP_ENCODING_IS_16BIT_INT(p[0])) {
listpack.c:523:        uval = (uint64_t)p[1] |
listpack.c:525:        negstart = (uint64_t)1<<15;
listpack.c:526:        negmax = UINT16_MAX;
listpack.c:528:        uval = (uint64_t)p[1] |
listpack.c:530:               (uint64_t)p[3]<<16;
listpack.c:531:        negstart = (uint64_t)1<<23;
listpack.c:534:        uval = (uint64_t)p[1] |
listpack.c:536:               (uint64_t)p[3]<<16 |
listpack.c:538:        negstart = (uint64_t)1<<31;
listpack.c:541:        uval = (uint64_t)p[1] |
listpack.c:543:               (uint64_t)p[3]<<16 |
listpack.c:549:        negstart = (uint64_t)1<<63;
listpack.c:551:    } else if (LP_ENCODING_IS_12BIT_STR(p[0])) {
listpack.c:552:        *count = LP_ENCODING_12BIT_STR_LEN(p);
listpack.c:558:        uval = 12345678900000000ULL + p[0];
listpack.c:571:        val = -val-1;
listpack.c:600: * the max allowed size of 2^32-1, otherwise the new pointer to the listpack
listpack.c:655:        enctype = -1;
listpack.c:729:                lpSetNumElements(lp,num_elements+1);
listpack.c:731:                lpSetNumElements(lp,num_elements-1);
listpack.c:764:    unsigned char *eofptr = lp + listpack_bytes - 1;
listpack.c:785: * -1 means the last element, -2 the penultimate and so forth. If the index
listpack.c:789:    int forward = 1; /* Seek forward by default. */
listpack.c:828:        while (index < -1 && ele) {
listpack.h:7: * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
listpack.h:40:#define LP_INTBUF_SIZE 21 /* 20 digits of -2^63 + 1 null term = 21. */
listpack.h:44:#define LP_AFTER 1
listpack_malloc.h:4: * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
localtime.c:2: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
localtime.c:49: * Note that this function does not work for dates < 1/1/1970, it is solely
localtime.c:54:    else if (year % 100) return 1;  /* If div by 4 and not 100 is surely leap. */
localtime.c:55:    else if (year % 400) return 0;  /* If div by 100 *and* 400 is not leap. */
localtime.c:56:    else return 1;                  /* If div by 100 and not by 400 is leap. */
localtime.c:74:    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
localtime.c:80:    tmp->tm_year = 1970;
localtime.c:81:    while(1) {
localtime.c:93:    int mdays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
localtime.c:94:    mdays[1] += is_leap_year(tmp->tm_year);
localtime.c:102:    tmp->tm_mday = days+1;  /* Add 1 since our 'days' is zero-based. */
localtime.c:103:    tmp->tm_year -= 1900;   /* Surprisingly tm_year is year-1900. */
localtime.c:117:    char buf[1024];
lolwut5.c:2: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
lolwut5.c:54: *   1 4
lolwut5.c:66:     * 1110xxxx 10xxxxxx 10xxxxxx. */
lolwut5.c:67:    output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
lolwut5.c:68:    output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
lolwut5.c:69:    output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
lolwut5.c:88:/* Set a pixel to the specified color. Color is 0 or 1, where zero means no
lolwut5.c:89: * dot will be displyed, and 1 means dot will be displayed.
lolwut5.c:105:/* Draw a line from x1,y1 to x2,y2 using the Bresenham algorithm. */
lolwut5.c:106:void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
lolwut5.c:107:    int dx = abs(x2-x1);
lolwut5.c:108:    int dy = abs(y2-y1);
lolwut5.c:109:    int sx = (x1 < x2) ? 1 : -1;
lolwut5.c:110:    int sy = (y1 < y2) ? 1 : -1;
lolwut5.c:113:    while(1) {
lolwut5.c:114:        lwDrawPixel(canvas,x1,y1,color);
lolwut5.c:115:        if (x1 == x2 && y1 == y2) break;
lolwut5.c:119:            x1 += sx;
lolwut5.c:123:            y1 += sy;
lolwut5.c:142: * circle of radius 1, so in order to draw larger squares we'll have to
lolwut5.c:151:     * into a circle of radius 1 has the side of length SQRT(2). This way
lolwut5.c:154:    size /= 1.4142135623;
lolwut5.c:167:        lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],1);
lolwut5.c:192:            if (y > 1) {
lolwut5.c:193:                float r1 = (float)rand() / RAND_MAX / squares_per_col * y;
lolwut5.c:196:                if (rand() % 2) r1 = -r1;
lolwut5.c:199:                angle = r1;
lolwut5.c:222:            if (lwGetPixel(canvas,x,y)) byte |= (1<<0);
lolwut5.c:223:            if (lwGetPixel(canvas,x,y+1)) byte |= (1<<1);
lolwut5.c:224:            if (lwGetPixel(canvas,x,y+2)) byte |= (1<<2);
lolwut5.c:225:            if (lwGetPixel(canvas,x+1,y)) byte |= (1<<3);
lolwut5.c:226:            if (lwGetPixel(canvas,x+1,y+1)) byte |= (1<<4);
lolwut5.c:227:            if (lwGetPixel(canvas,x+1,y+2)) byte |= (1<<5);
lolwut5.c:228:            if (lwGetPixel(canvas,x,y+3)) byte |= (1<<6);
lolwut5.c:229:            if (lwGetPixel(canvas,x+1,y+3)) byte |= (1<<7);
lolwut5.c:234:        if (y != canvas->height-1) text = sdscatlen(text,"\n",1);
lolwut5.c:243: * By default the command uses 66 columns, 8 squares per row, 12 squares
lolwut5.c:249:    long squares_per_col = 12;
lolwut5.c:252:    if (c->argc > 1 &&
lolwut5.c:253:        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
lolwut5.c:266:    if (cols < 1) cols = 1;
lolwut5.c:267:    if (cols > 1000) cols = 1000;
lolwut5.c:268:    if (squares_per_row < 1) squares_per_row = 1;
lolwut5.c:270:    if (squares_per_col < 1) squares_per_col = 1;
lolwut5.c:277:        "\nGeorg Nees - schotter, plotter on paper, 1968. Redis ver. ");
lolwut5.c:279:    rendered = sdscatlen(rendered,"\n",1);
lolwut.c:2: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
lolwut.c:45:    rendered = sdscatlen(rendered,"\n",1);
lolwut.c:51:    if ((v[0] == '5' && v[1] == '.') ||
lolwut.c:52:        (v[0] == '4' && v[1] == '.' && v[2] == '9'))
lzf_c.c:2: * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
lzf_c.c:7: *   1.  Redistributions of source code must retain the above copyright notice,
lzf_c.c:39:#define HSIZE (1 << (HLOG))
lzf_c.c:48:# define FRST(p) (((p[0]) << 8) | p[1])
lzf_c.c:51:#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h  ) & (HSIZE - 1))
lzf_c.c:53:#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
lzf_c.c:55:#  define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
lzf_c.c:60: * ((h * 57321 >> (3*8 - HLOG)) & (HSIZE - 1))
lzf_c.c:64: * (int)(cos(h & 0xffffff) * 1e6)
lzf_c.c:69:# define FRST(p) (p[0] << 5) ^ p[1]
lzf_c.c:71:# define IDX(h) ((h) & (HSIZE - 1))
lzf_c.c:74:#define        MAX_LIT        (1 <<  5)
lzf_c.c:75:#define        MAX_OFF        (1 << 13)
lzf_c.c:76:#define        MAX_REF        ((1 << 8) + (1 << 3))
lzf_c.c:87:#define expect_true(expr)  expect ((expr) != 0, 1)
lzf_c.c:92: * 000LLLLL <L+1>    ; literal, L+1=1..33 octets
lzf_c.c:93: * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
lzf_c.c:94: * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
lzf_c.c:148:      if (1
lzf_c.c:152:          && (off = ip - ref - 1) < MAX_OFF
lzf_c.c:156:          && ((ref[1] << 8) | ref[0]) == ((ip[1] << 8) | ip[0])
lzf_c.c:158:          && *(u16 *)ref == *(u16 *)ip
lzf_c.c:167:          if (expect_false (op + 3 + 1 >= out_end)) /* first a faster conservative test */
lzf_c.c:168:            if (op - !lit + 3 + 1 >= out_end) /* second the exact but rare test */
lzf_c.c:171:          op [- lit - 1] = lit - 1; /* stop run */
lzf_c.c:176:              if (expect_true (maxlen > 16))
lzf_c.c:206:          len -= 2; /* len is now #octets - 1 */
lzf_c.c:223:          ip += len + 1;
lzf_c.c:245:          ip -= len + 1;
lzf_c.c:266:              op [- lit - 1] = lit - 1; /* stop run */
lzf_c.c:281:          op [- lit - 1] = lit - 1; /* stop run */
lzf_c.c:286:  op [- lit - 1] = lit - 1; /* end run */
lzf_d.c:2: * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
lzf_d.c:7: *   1.  Redistributions of source code must retain the above copyright notice,
lzf_d.c:51:        :  "0" (dst),  "1" (src),  "2" (len));
lzf_d.c:72:      if (ctrl < (1 << 5)) /* literal run */
lzf_d.c:95:              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
lzf_d.c:97:              case 24: *op++ = *ip++; case 23: *op++ = *ip++; case 22: *op++ = *ip++; case 21: *op++ = *ip++;
lzf_d.c:98:              case 20: *op++ = *ip++; case 19: *op++ = *ip++; case 18: *op++ = *ip++; case 17: *op++ = *ip++;
lzf_d.c:99:              case 16: *op++ = *ip++; case 15: *op++ = *ip++; case 14: *op++ = *ip++; case 13: *op++ = *ip++;
lzf_d.c:100:              case 12: *op++ = *ip++; case 11: *op++ = *ip++; case 10: *op++ = *ip++; case  9: *op++ = *ip++;
lzf_d.c:102:              case  4: *op++ = *ip++; case  3: *op++ = *ip++; case  2: *op++ = *ip++; case  1: *op++ = *ip++;
lzf_d.c:110:          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;
lzf_d.c:178:              case 1: *op++ = *ref++; /* fall-thru */
lzf.h:7: *   1.  Redistributions of source code must retain the above copyright notice,
lzf.h:49:#define LZF_VERSION 0x0105 /* 1.5, API version */
lzf.h:58: * more than in_len (but less than 104% of the original size), so it
lzf.h:59: * makes sense to always use out_len == in_len - 1), to ensure _some_
lzfP.h:7: *   1.  Redistributions of source code must retain the above copyright notice,
lzfP.h:40:#define STANDALONE 1 /* at the moment, this is ok. */
lzfP.h:47: * Size of hashtable is (1 << HLOG) * sizeof (char *)
lzfP.h:49: * the difference between 15 and 14 is very small
lzfP.h:50: * for small blocks (and 14 is usually a bit faster).
lzfP.h:51: * For a low-memory/faster configuration, use HLOG == 13;
lzfP.h:52: * For best compression, use 15 or 16 (or more, up to 22).
lzfP.h:55:# define HLOG 16
lzfP.h:61: * (very roughly) 15% faster. This is the preferred mode of operation.
lzfP.h:64:# define VERY_FAST 1
lzfP.h:69: * (roughly 1-2% worse compression for large blocks and
lzfP.h:70: * 9-10% for small, redundant, blocks and >>20% better speed in both cases)
lzfP.h:83:#  define STRICT_ALIGN 1
lzfP.h:109: * on the stack. For small-stack environments, define this to 1.
lzfP.h:122: * (<1% slowdown), but might slow down older cpus considerably.
lzfP.h:125:# define CHECK_INPUT 1
lzfP.h:151:#  if __cplusplus > 199711L
lzfP.h:170:typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];
lzfP.h:173:/* for unaligned accesses we need a 16 bit datatype. */
lzfP.h:175:    typedef unsigned short u16;
lzfP.h:177:    typedef unsigned int u16;
lzfP.h:180:#  define STRICT_ALIGN 1
Lzf_test/lzf_d.c:2: * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
Lzf_test/lzf_d.c:7: *   1.  Redistributions of source code must retain the above copyright notice,
Lzf_test/lzf_d.c:51:        :  "0" (dst),  "1" (src),  "2" (len));
Lzf_test/lzf_d.c:72:      if (ctrl < (1 << 5)) /* literal run */
Lzf_test/lzf_d.c:95:              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
Lzf_test/lzf_d.c:97:              case 24: *op++ = *ip++; case 23: *op++ = *ip++; case 22: *op++ = *ip++; case 21: *op++ = *ip++;
Lzf_test/lzf_d.c:98:              case 20: *op++ = *ip++; case 19: *op++ = *ip++; case 18: *op++ = *ip++; case 17: *op++ = *ip++;
Lzf_test/lzf_d.c:99:              case 16: *op++ = *ip++; case 15: *op++ = *ip++; case 14: *op++ = *ip++; case 13: *op++ = *ip++;
Lzf_test/lzf_d.c:100:              case 12: *op++ = *ip++; case 11: *op++ = *ip++; case 10: *op++ = *ip++; case  9: *op++ = *ip++;
Lzf_test/lzf_d.c:102:              case  4: *op++ = *ip++; case  3: *op++ = *ip++; case  2: *op++ = *ip++; case  1: *op++ = *ip++;
Lzf_test/lzf_d.c:110:          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;
Lzf_test/lzf_d.c:178:              case 1: *op++ = *ref++; /* fall-thru */
Lzf_test/lzfP.h:7: *   1.  Redistributions of source code must retain the above copyright notice,
Lzf_test/lzfP.h:40:#define STANDALONE 1 /* at the moment, this is ok. */
Lzf_test/lzfP.h:47: * Size of hashtable is (1 << HLOG) * sizeof (char *)
Lzf_test/lzfP.h:49: * the difference between 15 and 14 is very small
Lzf_test/lzfP.h:50: * for small blocks (and 14 is usually a bit faster).
Lzf_test/lzfP.h:51: * For a low-memory/faster configuration, use HLOG == 13;
Lzf_test/lzfP.h:52: * For best compression, use 15 or 16 (or more, up to 22).
Lzf_test/lzfP.h:55:# define HLOG 16
Lzf_test/lzfP.h:61: * (very roughly) 15% faster. This is the preferred mode of operation.
Lzf_test/lzfP.h:64:# define VERY_FAST 1
Lzf_test/lzfP.h:69: * (roughly 1-2% worse compression for large blocks and
Lzf_test/lzfP.h:70: * 9-10% for small, redundant, blocks and >>20% better speed in both cases)
Lzf_test/lzfP.h:83:#  define STRICT_ALIGN 1
Lzf_test/lzfP.h:109: * on the stack. For small-stack environments, define this to 1.
Lzf_test/lzfP.h:122: * (<1% slowdown), but might slow down older cpus considerably.
Lzf_test/lzfP.h:125:# define CHECK_INPUT 1
Lzf_test/lzfP.h:151:#  if __cplusplus > 199711L
Lzf_test/lzfP.h:170:typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];
Lzf_test/lzfP.h:173:/* for unaligned accesses we need a 16 bit datatype. */
Lzf_test/lzfP.h:175:    typedef unsigned short u16;
Lzf_test/lzfP.h:177:    typedef unsigned int u16;
Lzf_test/lzfP.h:180:#  define STRICT_ALIGN 1
匹配到二进制文件 Lzf_test/a.out
Lzf_test/lzf.h:7: *   1.  Redistributions of source code must retain the above copyright notice,
Lzf_test/lzf.h:49:#define LZF_VERSION 0x0105 /* 1.5, API version */
Lzf_test/lzf.h:58: * more than in_len (but less than 104% of the original size), so it
Lzf_test/lzf.h:59: * makes sense to always use out_len == in_len - 1), to ensure _some_
Lzf_test/lzf_c.c:2: * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
Lzf_test/lzf_c.c:7: *   1.  Redistributions of source code must retain the above copyright notice,
Lzf_test/lzf_c.c:39:#define HSIZE (1 << (HLOG))
Lzf_test/lzf_c.c:48:# define FRST(p) (((p[0]) << 8) | p[1])
Lzf_test/lzf_c.c:51:#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h  ) & (HSIZE - 1))
Lzf_test/lzf_c.c:53:#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
Lzf_test/lzf_c.c:55:#  define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
Lzf_test/lzf_c.c:60: * ((h * 57321 >> (3*8 - HLOG)) & (HSIZE - 1))
Lzf_test/lzf_c.c:64: * (int)(cos(h & 0xffffff) * 1e6)
Lzf_test/lzf_c.c:69:# define FRST(p) (p[0] << 5) ^ p[1]
Lzf_test/lzf_c.c:71:# define IDX(h) ((h) & (HSIZE - 1))
Lzf_test/lzf_c.c:74:#define        MAX_LIT        (1 <<  5)
Lzf_test/lzf_c.c:75:#define        MAX_OFF        (1 << 13)
Lzf_test/lzf_c.c:76:#define        MAX_REF        ((1 << 8) + (1 << 3))
Lzf_test/lzf_c.c:87:#define expect_true(expr)  expect ((expr) != 0, 1)
Lzf_test/lzf_c.c:92: * 000LLLLL <L+1>    ; literal, L+1=1..33 octets
Lzf_test/lzf_c.c:93: * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
Lzf_test/lzf_c.c:94: * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
Lzf_test/lzf_c.c:148:        if (1
Lzf_test/lzf_c.c:152:                    && (off = ip - ref - 1) < MAX_OFF
Lzf_test/lzf_c.c:156:                    && ((ref[1] << 8) | ref[0]) == ((ip[1] << 8) | ip[0])
Lzf_test/lzf_c.c:158:                    && *(u16 *)ref == *(u16 *)ip
Lzf_test/lzf_c.c:167:            if (expect_false (op + 3 + 1 >= out_end)) /* first a faster conservative test */
Lzf_test/lzf_c.c:168:              if (op - !lit + 3 + 1 >= out_end) /* second the exact but rare test */
Lzf_test/lzf_c.c:171:            op [- lit - 1] = lit - 1; /* stop run */
Lzf_test/lzf_c.c:176:                if (expect_true (maxlen > 16))
Lzf_test/lzf_c.c:206:            len -= 2; /* len is now #octets - 1 */
Lzf_test/lzf_c.c:223:            ip += len + 1;
Lzf_test/lzf_c.c:245:            ip -= len + 1;
Lzf_test/lzf_c.c:266:                op [- lit - 1] = lit - 1; /* stop run */
Lzf_test/lzf_c.c:281:            op [- lit - 1] = lit - 1; /* stop run */
Lzf_test/lzf_c.c:286:    op [- lit - 1] = lit - 1; /* end run */
Lzf_test/lzf_c.c:303:        //char value[]="1234567890123456789012345678901234567890123456";
Lzf_test/lzf_c.c:304:        //char value[]="12345678901234567";
Lzf_test/lzf_c.c:329:        cout << "out = malloc(outlen+1)" << endl;
Makefile:26:  STD+=-Wno-c11-extensions
Makefile:153:LINKCOLOR="\033[34;1m"
Makefile:155:BINCOLOR="\033[37;1m"
Makefile:156:MAKECOLOR="\033[32;1m"
Makefile:160:QUIET_CC = @printf '    %b %b\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
Makefile:161:QUIET_LINK = @printf '    %b %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
Makefile:162:QUIET_INSTALL = @printf '    %b %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
Makefile:167:REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o
Makefile:169:REDIS_CLI_OBJ=anet.o adlist.o dict.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o siphash.o crc16.o
Makefile:271:	@(set -e; cd ..; ./runtest --clients 1)
malloc/siphash.c:4:   Copyright (c) 2012-2016 Jean-Philippe Aumasson
malloc/siphash.c:6:   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>
malloc/siphash.c:7:   Copyright (c) 2017 Salvatore Sanfilippo <antirez@gmail.com>
malloc/siphash.c:15:   <http://creativecommons.org/publicdomain/zero/1.0/>.
malloc/siphash.c:22:   1. We use SipHash 1-2. This is not believed to be as strong as the
malloc/siphash.c:32:      and the 16 bytes output code handling was removed.
malloc/siphash.c:69:    (p)[1] = (uint8_t)((v) >> 8);                                              \
malloc/siphash.c:70:    (p)[2] = (uint8_t)((v) >> 16);                                             \
malloc/siphash.c:81:    (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
malloc/siphash.c:82:     ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
malloc/siphash.c:89:     ((uint64_t)(siptlw((p)[1])) << 8) |                                      \
malloc/siphash.c:90:     ((uint64_t)(siptlw((p)[2])) << 16) |                                     \
malloc/siphash.c:99:        v0 += v1;                                                              \
malloc/siphash.c:100:        v1 = ROTL(v1, 13);                                                     \
malloc/siphash.c:101:        v1 ^= v0;                                                              \
malloc/siphash.c:104:        v3 = ROTL(v3, 16);                                                     \
malloc/siphash.c:107:        v3 = ROTL(v3, 21);                                                     \
malloc/siphash.c:109:        v2 += v1;                                                              \
malloc/siphash.c:110:        v1 = ROTL(v1, 17);                                                     \
malloc/siphash.c:111:        v1 ^= v2;                                                              \
malloc/siphash.c:121:    uint64_t v1 = 0x646f72616e646f6dULL;
malloc/siphash.c:122:    uint64_t v2 = 0x6c7967656e657261ULL;
malloc/siphash.c:125:    uint64_t k1 = U8TO64_LE(k + 8);
malloc/siphash.c:130:    v3 ^= k1;
malloc/siphash.c:132:    v1 ^= k1;
malloc/siphash.c:149:    case 3: b |= ((uint64_t)in[2]) << 16; /* fall-thru */
malloc/siphash.c:150:    case 2: b |= ((uint64_t)in[1]) << 8; /* fall-thru */
malloc/siphash.c:151:    case 1: b |= ((uint64_t)in[0]); break;
malloc/siphash.c:165:    b = v0 ^ v1 ^ v2 ^ v3;
malloc/siphash.c:181:    uint64_t v1 = 0x646f72616e646f6dULL;
malloc/siphash.c:182:    uint64_t v2 = 0x6c7967656e657261ULL;
malloc/siphash.c:185:    uint64_t k1 = U8TO64_LE(k + 8);
malloc/siphash.c:190:    v3 ^= k1;
malloc/siphash.c:192:    v1 ^= k1;
malloc/siphash.c:209:    case 3: b |= ((uint64_t)siptlw(in[2])) << 16; /* fall-thru */
malloc/siphash.c:210:    case 2: b |= ((uint64_t)siptlw(in[1])) << 8; /* fall-thru */
malloc/siphash.c:211:    case 1: b |= ((uint64_t)siptlw(in[0])); break;
malloc/siphash.c:225:    b = v0 ^ v1 ^ v2 ^ v3;
malloc/siphash.c:240:    { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
malloc/siphash.c:244:    { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
malloc/siphash.c:245:    { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
malloc/siphash.c:247:    { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
malloc/siphash.c:252:    { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
malloc/siphash.c:253:    { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
malloc/siphash.c:255:    { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
malloc/siphash.c:258:    { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
malloc/siphash.c:259:    { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
malloc/siphash.c:260:    { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
malloc/siphash.c:265:    { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
malloc/siphash.c:266:    { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
malloc/siphash.c:267:    { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
malloc/siphash.c:268:    { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
malloc/siphash.c:269:    { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
malloc/siphash.c:271:    { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
malloc/siphash.c:272:    { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
malloc/siphash.c:274:    { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
malloc/siphash.c:275:    { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
malloc/siphash.c:276:    { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
malloc/siphash.c:277:    { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
malloc/siphash.c:282:    { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
malloc/siphash.c:284:    { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
malloc/siphash.c:285:    { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
malloc/siphash.c:286:    { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
malloc/siphash.c:288:    { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
malloc/siphash.c:291:    { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
malloc/siphash.c:293:    { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
malloc/siphash.c:295:    { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
malloc/siphash.c:297:    { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
malloc/siphash.c:298:    { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
malloc/siphash.c:300:    { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
malloc/siphash.c:301:    { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
malloc/siphash.c:302:    { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
malloc/siphash.c:308: * all the tests, otherwise 1 is returned.
malloc/siphash.c:312: * now it uses 1-2 rounds. */
malloc/siphash.c:314:    uint8_t in[64], k[16];
malloc/siphash.c:318:    for (i = 0; i < 16; ++i)
malloc/siphash.c:336:    uint64_t h1, h2;
malloc/siphash.c:337:    h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:338:    h2 = siphash_nocase((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:339:    if (h1 != h2) {printf("1\n");fails++;}
malloc/siphash.c:341:    h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:342:    h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:343:    if (h1 != h2) {printf("2\n");fails++;}
malloc/siphash.c:345:    h1 = siphash((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:346:    h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
malloc/siphash.c:347:    if (h1 != h2) {printf("3\n");fails++;}
malloc/siphash.c:350:    return 1;
malloc/siphash.c:359:        return 1;
malloc/atomicvar.h:17: *  atomicSet(myvar,12345);
malloc/atomicvar.h:27: *  atomicGetIncr(myvar,oldvalue,1);
malloc/atomicvar.h:32: * Copyright (c) 2015, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/atomicvar.h:71:#if !defined(__ATOMIC_VAR_FORCE_SYNC_MACROS) && defined(__ATOMIC_RELAXED) && !defined(__sun) && (!defined(__clang__) || !defined(__APPLE__) || __apple_build_version__ > 4210057)
malloc/dict.h:8: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/dict.h:42:#define DICT_ERR 1
malloc/dict.h:62:    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
malloc/dict.h:80:    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
malloc/dict.h:84:/* If safe is set to 1 this is a safe iterator, that means, you can call
malloc/dict.h:135:#define dictCompareKeys(d, key1, key2) \
malloc/dict.h:137:        (d)->type->keyCompare((d)->privdata, key1, key2) : \
malloc/dict.h:138:        (key1) == (key2))
malloc/dict.h:146:#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)
malloc/dict.h:147:#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)
malloc/dict.h:148:#define dictIsRehashing(d) ((d)->rehashidx != -1)
匹配到二进制文件 malloc/a.out
malloc/main.c:31:struct  sdshdr18 {
malloc/main.c:42://    void * ptr=zmalloc(11);
malloc/main.c:46:    printf("sds_18:%d\n",sizeof(struct sdshdr18));
malloc/zmalloc.c:3: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/zmalloc.c:76:    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
malloc/zmalloc.c:82:    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
malloc/zmalloc.c:131:    void *ptr = calloc(1, size+PREFIX_SIZE);
malloc/zmalloc.c:183:    if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));
malloc/zmalloc.c:211:    size_t l = strlen(s)+1;
malloc/zmalloc.c:253:    if ((fd = open(filename,O_RDONLY)) == -1) return 0;
malloc/zmalloc.c:271:    rss = strtoll(p,NULL,10);
malloc/zmalloc.c:300:     * Fragmentation will appear to be always 1 (no fragmentation)
malloc/zmalloc.c:310:    uint64_t epoch = 1;
malloc/zmalloc.c:326:    return 1;
malloc/zmalloc.c:333:    return 1;
malloc/zmalloc.c:342: * otherwise if pid is -1 the information is reported is about the
malloc/zmalloc.c:345: * Example: zmalloc_get_smap_bytes_by_field("Rss:",-1);
malloc/zmalloc.c:349:    char line[1024];
malloc/zmalloc.c:354:    if (pid == -1) {
malloc/zmalloc.c:357:        char filename[128];
malloc/zmalloc.c:368:                bytes += strtol(line+flen,NULL,10) * 1024;
malloc/zmalloc.c:391: * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system
malloc/zmalloc.c:394: * 1) Was released under the following CC attribution license:
malloc/zmalloc.c:407:    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
malloc/zmalloc.c:409:    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
malloc/zmalloc.c:426:    mib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */
malloc/zmalloc.c:428:    mib[1] = HW_PHYSMEM;        /* Others. ------------------ */
malloc/zmalloc.c:451:    ptr = zmalloc(123);
malloc/zmalloc.c:452:    printf("Allocated 123 bytes; used: %zu\n", zmalloc_used_memory());
malloc/sdsalloc.h:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/sdsalloc.h:4: * Copyright (c) 2015, Redis Labs, Inc
malloc/sds.c:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/sds.c:4: * Copyright (c) 2015, Oran Agra
malloc/sds.c:5: * Copyright (c) 2015, Redis Labs, Inc
malloc/sds.c:50:        case SDS_TYPE_16:
malloc/sds.c:51:            return sizeof(struct sdshdr16);
malloc/sds.c:61:    if (string_size < 1<<5)
malloc/sds.c:63:    if (string_size < 1<<8)
malloc/sds.c:65:    if (string_size < 1<<16)
malloc/sds.c:66:        return SDS_TYPE_16;
malloc/sds.c:68:    if (string_size < 1ll<<32)
malloc/sds.c:99:    sh = s_malloc(hdrlen+initlen+1);
malloc/sds.c:103:        memset(sh, 0, hdrlen+initlen+1);
malloc/sds.c:106:    fp = ((unsigned char*)s)-1;
malloc/sds.c:119:        case SDS_TYPE_16: {
malloc/sds.c:120:            SDS_HDR_VAR(16,s);
malloc/sds.c:167:    s_free((char*)s-sdsHdrSize(s[-1]));
malloc/sds.c:208:    char type, oldtype = s[-1] & SDS_TYPE_MASK;
malloc/sds.c:231:        newsh = s_realloc(sh, hdrlen+newlen+1);
malloc/sds.c:237:        newsh = s_malloc(hdrlen+newlen+1);
malloc/sds.c:239:        memcpy((char*)newsh+hdrlen, s, len+1);
malloc/sds.c:242:        s[-1] = type;
malloc/sds.c:257:    char type, oldtype = s[-1] & SDS_TYPE_MASK;
malloc/sds.c:276:        newsh = s_realloc(sh, oldhdrlen+len+1);
malloc/sds.c:280:        newsh = s_malloc(hdrlen+len+1);
malloc/sds.c:282:        memcpy((char*)newsh+hdrlen, s, len+1);
malloc/sds.c:285:        s[-1] = type;
malloc/sds.c:294: * 1) The sds header before the pointer.
malloc/sds.c:301:    return sdsHdrSize(s[-1])+alloc+1;
malloc/sds.c:307:    return (void*) (s-sdsHdrSize(s[-1]));
malloc/sds.c:334:    unsigned char flags = s[-1];
malloc/sds.c:338:            unsigned char *fp = ((unsigned char*)s)-1;
malloc/sds.c:351:        case SDS_TYPE_16: {
malloc/sds.c:352:            SDS_HDR_VAR(16,s);
malloc/sds.c:387:    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
malloc/sds.c:449:#define SDS_LLSTR_SIZE 21
malloc/sds.c:460:        *p++ = '0'+(v%10);
malloc/sds.c:461:        v /= 10;
malloc/sds.c:490:        *p++ = '0'+(v%10);
malloc/sds.c:491:        v /= 10;
malloc/sds.c:524:    char staticbuf[1024], *buf = staticbuf, *t;
malloc/sds.c:538:    while(1) {
malloc/sds.c:615:        /* Make sure there is always space for at least 1 char. */
malloc/sds.c:617:            s = sdsMakeRoomFor(s,1);
malloc/sds.c:622:            next = *(f+1);
malloc/sds.c:672:                sdsinclen(s,1);
malloc/sds.c:678:            sdsinclen(s,1);
malloc/sds.c:709:    ep = end = s+sdslen(s)-1;
malloc/sds.c:712:    len = (sp > ep) ? 0 : ((ep-sp)+1);
malloc/sds.c:722: * start and end can be negative, where -1 means the last character of the
malloc/sds.c:733: * sdsrange(s,1,-1); => "ello World"
malloc/sds.c:747:    newlen = (start > end) ? 0 : (end-start)+1;
malloc/sds.c:752:            end = len-1;
malloc/sds.c:753:            newlen = (start > end) ? 0 : (end-start)+1;
malloc/sds.c:777:/* Compare two sds strings s1 and s2 with memcmp().
malloc/sds.c:781: *     positive if s1 > s2.
malloc/sds.c:782: *     negative if s1 < s2.
malloc/sds.c:783: *     0 if s1 and s2 are exactly the same binary string.
malloc/sds.c:788:int sdscmp(const sds s1, const sds s2) {
malloc/sds.c:789:    size_t l1, l2, minlen;
malloc/sds.c:792:    l1 = sdslen(s1);
malloc/sds.c:794:    minlen = (l1 < l2) ? l1 : l2;
malloc/sds.c:795:    cmp = memcmp(s1,s2,minlen);
malloc/sds.c:796:    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
malloc/sds.c:821:    if (seplen < 1 || len < 0) return NULL;
malloc/sds.c:830:    for (j = 0; j < (len-(seplen-1)); j++) {
malloc/sds.c:841:        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
malloc/sds.c:846:            j = j+seplen-1; /* skip the separator */
malloc/sds.c:881:    s = sdscatlen(s,"\"",1);
malloc/sds.c:902:    return sdscatlen(s,"\"",1);
malloc/sds.c:913: * integer from 0 to 15 */
malloc/sds.c:917:    case '1': return 1;
malloc/sds.c:926:    case 'a': case 'A': return 10;
malloc/sds.c:927:    case 'b': case 'B': return 11;
malloc/sds.c:928:    case 'c': case 'C': return 12;
malloc/sds.c:929:    case 'd': case 'D': return 13;
malloc/sds.c:930:    case 'e': case 'E': return 14;
malloc/sds.c:931:    case 'f': case 'F': return 15;
malloc/sds.c:961:    while(1) {
malloc/sds.c:966:            int inq=0;  /* set to 1 if we are in "quotes" */
malloc/sds.c:967:            int insq=0; /* set to 1 if we are in 'single quotes' */
malloc/sds.c:973:                    if (*p == '\\' && *(p+1) == 'x' &&
malloc/sds.c:979:                        byte = (hex_digit_to_int(*(p+2))*16)+
malloc/sds.c:981:                        current = sdscatlen(current,(char*)&byte,1);
malloc/sds.c:983:                    } else if (*p == '\\' && *(p+1)) {
malloc/sds.c:995:                        current = sdscatlen(current,&c,1);
malloc/sds.c:999:                        if (*(p+1) && !isspace(*(p+1))) goto err;
malloc/sds.c:1000:                        done=1;
malloc/sds.c:1005:                        current = sdscatlen(current,p,1);
malloc/sds.c:1008:                    if (*p == '\\' && *(p+1) == '\'') {
malloc/sds.c:1010:                        current = sdscatlen(current,"'",1);
malloc/sds.c:1014:                        if (*(p+1) && !isspace(*(p+1))) goto err;
malloc/sds.c:1015:                        done=1;
malloc/sds.c:1020:                        current = sdscatlen(current,p,1);
malloc/sds.c:1029:                        done=1;
malloc/sds.c:1032:                        inq=1;
malloc/sds.c:1035:                        insq=1;
malloc/sds.c:1038:                        current = sdscatlen(current,p,1);
malloc/sds.c:1045:            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));
malloc/sds.c:1069: * For instance: sdsmapchars(mystring, "ho", "01", 2)
malloc/sds.c:1070: * will have the effect of turning the string "hello" into "0ell1".
malloc/sds.c:1096:        if (j != argc-1) join = sdscat(join,sep);
malloc/sds.c:1108:        if (j != argc-1) join = sdscatlen(join,sep,seplen);
malloc/sds.c:1146:            sdslen(x) == 1 && memcmp(x,"a\0",2) == 0)
malloc/sds.c:1154:        x = sdscatprintf(sdsempty(),"%d",123);
malloc/sds.c:1156:            sdslen(x) == 3 && memcmp(x,"123\0",4) == 0)
malloc/sds.c:1172:            memcmp(x,"--4294967295,18446744073709551615--",35) == 0)
malloc/sds.c:1184:            sdslen(x) == 1 && x[0] == 'x')
malloc/sds.c:1193:        sdsrange(y,1,1);
malloc/sds.c:1194:        test_cond("sdsrange(...,1,1)",
malloc/sds.c:1195:            sdslen(y) == 1 && memcmp(y,"i\0",2) == 0)
malloc/sds.c:1199:        sdsrange(y,1,-1);
malloc/sds.c:1200:        test_cond("sdsrange(...,1,-1)",
malloc/sds.c:1205:        sdsrange(y,-2,-1);
malloc/sds.c:1206:        test_cond("sdsrange(...,-2,-1)",
malloc/sds.c:1211:        sdsrange(y,2,1);
malloc/sds.c:1212:        test_cond("sdsrange(...,2,1)",
malloc/sds.c:1213:            sdslen(y) == 0 && memcmp(y,"\0",1) == 0)
malloc/sds.c:1217:        sdsrange(y,1,100);
malloc/sds.c:1218:        test_cond("sdsrange(...,1,100)",
malloc/sds.c:1223:        sdsrange(y,100,100);
malloc/sds.c:1224:        test_cond("sdsrange(...,100,100)",
malloc/sds.c:1225:            sdslen(y) == 0 && memcmp(y,"\0",1) == 0)
malloc/sds.c:1250:            memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0)
malloc/sds.c:1255:            int step = 10, j, i;
malloc/sds.c:1260:            test_cond("sdsnew() free/len buffers", sdslen(x) == 1 && sdsavail(x) == 0);
malloc/sds.c:1264:            for (i = 0; i < 10; i++) {
malloc/sds.c:1267:                int type = x[-1]&SDS_TYPE_MASK;
malloc/sds.c:1281:                memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0);
malloc/sds.c:1282:            test_cond("sdsMakeRoomFor() final length",sdslen(x)==101);
malloc/testhelp.h:5: * test_cond("Check if 1 == 1", 1==1)
malloc/testhelp.h:6: * test_cond("Check if 5 > 10", 5 > 10)
malloc/testhelp.h:11: * Copyright (c) 2010-2012, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/testhelp.h:53:        exit(1); \
malloc/dict.c:8: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/dict.c:62:static int dict_can_resize = 1;
malloc/dict.c:74:static uint8_t dict_hash_function_seed[16];
malloc/dict.c:125:    _dictReset(&d->ht[1]);
malloc/dict.c:128:    d->rehashidx = -1;
malloc/dict.c:134: * but with the invariant of a USED/BUCKETS ratio near to <= 1 */
malloc/dict.c:162:    n.sizemask = realsize-1;
malloc/dict.c:174:    d->ht[1] = n;
malloc/dict.c:179:/* Performs N steps of incremental rehashing. Returns 1 if there are still
malloc/dict.c:186: * will visit at max N*10 empty buckets in total, otherwise the amount of
malloc/dict.c:189:    int empty_visits = n*10; /* Max number of empty buckets to visit. */
malloc/dict.c:200:            if (--empty_visits == 0) return 1;
malloc/dict.c:209:            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
malloc/dict.c:210:            de->next = d->ht[1].table[h];
malloc/dict.c:211:            d->ht[1].table[h] = de;
malloc/dict.c:213:            d->ht[1].used++;
malloc/dict.c:223:        d->ht[0] = d->ht[1];
malloc/dict.c:224:        _dictReset(&d->ht[1]);
malloc/dict.c:225:        d->rehashidx = -1;
malloc/dict.c:230:    return 1;
malloc/dict.c:237:    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
malloc/dict.c:240:/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */
malloc/dict.c:245:    while(dictRehash(d,100)) {
malloc/dict.c:246:        rehashes += 100;
malloc/dict.c:258: * dictionary so that the hash table automatically migrates from H1 to H2
malloc/dict.c:261:    if (d->iterators == 0) dictRehash(d,1);
malloc/dict.c:283: * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
malloc/dict.c:300:    /* Get the index of the new element, or -1 if
malloc/dict.c:302:    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
malloc/dict.c:309:    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
malloc/dict.c:322: * Return 1 if the key was added from scratch, 0 if there was already an
malloc/dict.c:334:        return 1;
malloc/dict.c:369:    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
malloc/dict.c:374:    for (table = 0; table <= 1; table++) {
malloc/dict.c:429:    return dictGenericDelete(ht,key,1);
malloc/dict.c:472:    _dictClear(d,&d->ht[1],NULL);
malloc/dict.c:481:    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
malloc/dict.c:484:    for (table = 0; table <= 1; table++) {
malloc/dict.c:515:    integers[1] = d->ht[0].size;
malloc/dict.c:517:    integers[3] = (long) d->ht[1].table;
malloc/dict.c:518:    integers[4] = d->ht[1].size;
malloc/dict.c:519:    integers[5] = d->ht[1].used;
malloc/dict.c:524:     * Result = hash(hash(hash(int1)+int2)+int3) ...
malloc/dict.c:531:        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;
malloc/dict.c:534:        hash = hash ^ (hash >> 14);
malloc/dict.c:535:        hash = (hash + (hash << 2)) + (hash << 4); // hash * 21
malloc/dict.c:537:        hash = hash + (hash << 31);
malloc/dict.c:548:    iter->index = -1;
malloc/dict.c:558:    i->safe = 1;
malloc/dict.c:564:    while (1) {
malloc/dict.c:567:            if (iter->index == -1 && iter->table == 0) {
malloc/dict.c:578:                    ht = &iter->d->ht[1];
malloc/dict.c:599:    if (!(iter->index == -1 && iter->table == 0)) {
malloc/dict.c:621:             * to rehashidx-1 */
malloc/dict.c:623:                                            d->ht[1].size -
malloc/dict.c:625:            he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :
malloc/dict.c:674:    unsigned long j; /* internal hash table id, 0 or 1. */
malloc/dict.c:675:    unsigned long tables; /* 1 or 2 tables? */
malloc/dict.c:680:    maxsteps = count*10;
malloc/dict.c:690:    tables = dictIsRehashing(d) ? 2 : 1;
malloc/dict.c:692:    if (tables > 1 && maxsizemask < d->ht[1].sizemask)
malloc/dict.c:693:        maxsizemask = d->ht[1].sizemask;
malloc/dict.c:702:             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */
malloc/dict.c:708:                if (i >= d->ht[1].size)
malloc/dict.c:737:        i = (i+1) & maxsizemask;
malloc/dict.c:747:    while ((s >>= 1) > 0) {
malloc/dict.c:758: * 1) Initially you call the function using a cursor (v) value of 0.
malloc/dict.c:784: * by computing the bitwise AND between Hash(key) and SIZE-1
malloc/dict.c:785: * (where SIZE-1 is always the mask that is equivalent to taking the rest
malloc/dict.c:788: * For example if the current hash table size is 16, the mask is
malloc/dict.c:789: * (in binary) 1111. The position of a key in the hash table will always be
malloc/dict.c:796: * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).
malloc/dict.c:799: * be 111111. The new buckets you obtain by substituting in ??1100
malloc/dict.c:800: * with either 0 or 1 can be targeted only by keys we already visited
malloc/dict.c:801: * when scanning the bucket 1100 in the smaller hash table.
malloc/dict.c:805: * continue iterating using cursors without '1100' at the end, and also
malloc/dict.c:809: * 16 to 8, if a combination of the lower three bits (the mask for size 8
malloc/dict.c:810: * is 111) were already completely explored, it would not be visited again
malloc/dict.c:811: * because we are sure we tried, for example, both 0111 and 1111 (all the
malloc/dict.c:818: * table. For example if the current cursor is 101 and we also have a
malloc/dict.c:819: * larger table of size 16, we also test (0)101 and (1)101 inside the larger
malloc/dict.c:830: * 1) It is possible we return elements more than once. However this is usually
malloc/dict.c:844:    dictht *t0, *t1;
malloc/dict.c:846:    unsigned long m0, m1;
malloc/dict.c:874:        t1 = &d->ht[1];
malloc/dict.c:876:        /* Make sure t0 is the smaller and t1 is the bigger table */
malloc/dict.c:877:        if (t0->size > t1->size) {
malloc/dict.c:878:            t0 = &d->ht[1];
malloc/dict.c:879:            t1 = &d->ht[0];
malloc/dict.c:883:        m1 = t1->sizemask;
malloc/dict.c:898:            if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
malloc/dict.c:899:            de = t1->table[v & m1];
malloc/dict.c:907:            v |= ~m1;
malloc/dict.c:913:        } while (v & (m0 ^ m1));
malloc/dict.c:930:    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
malloc/dict.c:948:    if (size >= LONG_MAX) return LONG_MAX + 1LU;
malloc/dict.c:949:    while(1) {
malloc/dict.c:958: * If the key already exists, -1 is returned
malloc/dict.c:971:        return -1;
malloc/dict.c:972:    for (table = 0; table <= 1; table++) {
malloc/dict.c:979:                return -1;
malloc/dict.c:990:    _dictClear(d,&d->ht[1],callback);
malloc/dict.c:991:    d->rehashidx = -1;
malloc/dict.c:996:    dict_can_resize = 1;
malloc/dict.c:1016:    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
malloc/dict.c:1017:    for (table = 0; table <= 1; table++) {
malloc/dict.c:1063:        clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;
malloc/dict.c:1082:    for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {
malloc/dict.c:1087:            (i == DICT_STATS_VECTLEN-1)?">= ":"",
malloc/dict.c:1088:            i, clvector[i], ((float)clvector[i]/ht->size)*100);
malloc/dict.c:1092:    if (bufsize) buf[bufsize-1] = '\0';
malloc/dict.c:1105:        _dictGetStatsHt(buf,bufsize,&d->ht[1],1);
malloc/dict.c:1108:    if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
malloc/dict.c:1121:int compareCallback(void *privdata, const void *key1, const void *key2) {
malloc/dict.c:1122:    int l1,l2;
malloc/dict.c:1125:    l1 = sdslen((sds)key1);
malloc/dict.c:1127:    if (l1 != l2) return 0;
malloc/dict.c:1128:    return memcmp(key1, key2, l1) == 0;
malloc/dict.c:1160:        count = strtol(argv[1],NULL,10);
malloc/dict.c:1175:        dictRehashMilliseconds(dict,100);
malloc/dict.c:1220:        key[0] += 17; /* Change first number to letter. */
malloc/Makefile:26:  STD+=-Wno-c11-extensions
malloc/Makefile:153:LINKCOLOR="\033[34;1m"
malloc/Makefile:155:BINCOLOR="\033[37;1m"
malloc/Makefile:156:MAKECOLOR="\033[32;1m"
malloc/Makefile:160:QUIET_CC = @printf '    %b %b\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
malloc/Makefile:161:QUIET_LINK = @printf '    %b %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
malloc/Makefile:162:QUIET_INSTALL = @printf '    %b %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
malloc/Makefile:167:REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o
malloc/Makefile:169:REDIS_CLI_OBJ=anet.o adlist.o dict.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o siphash.o crc16.o
malloc/Makefile:271:	@(set -e; cd ..; ./runtest --clients 1)
malloc/sds.h:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/sds.h:4: * Copyright (c) 2015, Oran Agra
malloc/sds.h:5: * Copyright (c) 2015, Redis Labs, Inc
malloc/sds.h:36:#define SDS_MAX_PREALLOC (1024*1024)
malloc/sds.h:57:struct __attribute__ ((__packed__)) sdshdr16 {
malloc/sds.h:58:    uint16_t len; /* used */
malloc/sds.h:59:    uint16_t alloc; /* excluding the header and null terminator */
malloc/sds.h:77:#define SDS_TYPE_8  1
malloc/sds.h:78:#define SDS_TYPE_16 2
malloc/sds.h:88:    unsigned char flags = s[-1];
malloc/sds.h:94:        case SDS_TYPE_16:
malloc/sds.h:95:            return SDS_HDR(16,s)->len;
malloc/sds.h:105:    unsigned char flags = s[-1];
malloc/sds.h:114:        case SDS_TYPE_16: {
malloc/sds.h:115:            SDS_HDR_VAR(16,s);
malloc/sds.h:131:    unsigned char flags = s[-1];
malloc/sds.h:135:                unsigned char *fp = ((unsigned char*)s)-1;
malloc/sds.h:142:        case SDS_TYPE_16:
malloc/sds.h:143:            SDS_HDR(16,s)->len = newlen;
malloc/sds.h:155:    unsigned char flags = s[-1];
malloc/sds.h:159:                unsigned char *fp = ((unsigned char*)s)-1;
malloc/sds.h:167:        case SDS_TYPE_16:
malloc/sds.h:168:            SDS_HDR(16,s)->len += inc;
malloc/sds.h:181:    unsigned char flags = s[-1];
malloc/sds.h:187:        case SDS_TYPE_16:
malloc/sds.h:188:            return SDS_HDR(16,s)->alloc;
malloc/sds.h:198:    unsigned char flags = s[-1];
malloc/sds.h:206:        case SDS_TYPE_16:
malloc/sds.h:207:            SDS_HDR(16,s)->alloc = newlen;
malloc/sds.h:243:int sdscmp(const sds s1, const sds s2);
malloc/config.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/config.h:43:#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
malloc/config.h:53:#define HAVE_PROC_STAT 1
malloc/config.h:54:#define HAVE_PROC_MAPS 1
malloc/config.h:55:#define HAVE_PROC_SMAPS 1
malloc/config.h:56:#define HAVE_PROC_SOMAXCONN 1
malloc/config.h:61:#define HAVE_TASKINFO 1
malloc/config.h:68:#define HAVE_BACKTRACE 1
malloc/config.h:73:#define HAVE_MSG_NOSIGNAL 1
malloc/config.h:78:#define HAVE_EPOLL 1
malloc/config.h:81:#if (defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)
malloc/config.h:82:#define HAVE_KQUEUE 1
malloc/config.h:88:#define HAVE_EVPORT 1
malloc/config.h:103:#if (LINUX_VERSION_CODE >= 0x020611 && __GLIBC_PREREQ(2, 6))
malloc/config.h:104:#define HAVE_SYNC_FILE_RANGE 1
malloc/config.h:107:#if (LINUX_VERSION_CODE >= 0x020611)
malloc/config.h:108:#define HAVE_SYNC_FILE_RANGE 1
malloc/config.h:137:#if (BSD >= 199103)
malloc/config.h:143:#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax, pc) */
malloc/config.h:144:#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
malloc/config.h:145:#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp)*/
malloc/config.h:200:#define GNUC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
malloc/config.h:205:#if (GNUC_VERSION >= 40100 && __GLIBC_PREREQ(2, 6))
malloc/zmalloc.h:3: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
malloc/zmalloc.h:41:#if (TC_VERSION_MAJOR == 1 && TC_VERSION_MINOR >= 6) || (TC_VERSION_MAJOR > 1)
malloc/zmalloc.h:42:#define HAVE_MALLOC_SIZE 1
malloc/zmalloc.h:51:#if (JEMALLOC_VERSION_MAJOR == 2 && JEMALLOC_VERSION_MINOR >= 1) || (JEMALLOC_VERSION_MAJOR > 2)
malloc/zmalloc.h:52:#define HAVE_MALLOC_SIZE 1
malloc/zmalloc.h:60:#define HAVE_MALLOC_SIZE 1
malloc/zmalloc.h:68:#define HAVE_MALLOC_SIZE 1
memtest.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
memtest.c:45:#elif (ULONG_MAX == 18446744073709551615ULL)
memtest.c:66:    printf("\x1b[H\x1b[2J");    /* Cursor home, clear screen. */
memtest.c:71:    printf("\x1b[H\x1b[2K");          /* Cursor home, clear current line.  */
memtest.c:79:    printf("\x1b[H\x1b[2J");    /* Cursor home, clear screen. */
memtest.c:112:                exit(1);
memtest.c:114:            return 1;
memtest.c:132:        rseed ^= rseed >> 12; \
memtest.c:135:        rout = rseed * UINT64_C(2685821657736338717); \
memtest.c:142:    unsigned long off, w, *l1, *l2;
memtest.c:143:    uint64_t rseed = UINT64_C(0xd13133de9afdb566); /* Just a random seed. */
memtest.c:148:        l1 = l+off;
memtest.c:149:        l2 = l1+words;
memtest.c:152:            *l1 = *l2 = (unsigned long) rout;
memtest.c:153:            l1 += step;
memtest.c:162: * memory, in an alternated way (v1|v2|v1|v2|...) */
memtest.c:163:void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
memtest.c:169:    unsigned long off, w, *l1, *l2, v;
memtest.c:173:        l1 = l+off;
memtest.c:174:        l2 = l1+words;
memtest.c:175:        v = (off & 1) ? v2 : v1;
memtest.c:178:            *l1 = *l2 = ((unsigned long)     v) |
memtest.c:179:                        (((unsigned long)    v) << 16);
memtest.c:181:            *l1 = *l2 = ((unsigned long)     v) |
memtest.c:182:                        (((unsigned long)    v) << 16) |
memtest.c:186:            l1 += step;
memtest.c:196:    unsigned long w, *l1, *l2;
memtest.c:199:    l1 = l;
memtest.c:200:    l2 = l1+words;
memtest.c:202:        if (*l1 != *l2) {
memtest.c:205:                    (void*)l1, (void*)l2, *l1, *l2);
memtest.c:206:                exit(1);
memtest.c:208:            return 1;
memtest.c:210:        l1 ++;
memtest.c:235: * be used as an API call, and returns 1 if memory errors were found or
memtest.c:254:        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S',interactive);
memtest.c:275:#define MEMTEST_BACKUP_WORDS (1024*(1024/sizeof(long)))
memtest.c:279:#define MEMTEST_DECACHE_SIZE (1024*8)
memtest.c:311:                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:312:                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:315:            memtest_fill_value(p,len,0,(unsigned long)-1,'S',0);
memtest.c:317:                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:318:                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:323:                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:324:                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
memtest.c:337:    size_t bytes = megabytes*1024*1024;
memtest.c:343:        exit(1);
memtest.c:345:    memtest_test(m,bytes,passes,1);
memtest.c:350:    if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
memtest.c:357:    printf("1) memtest86: http://www.memtest86.com/\n");
mkreleasehdr.sh:2:GIT_SHA1=`(git show-ref --head --hash=8 2> /dev/null || echo 00000000) | head -n1`
mkreleasehdr.sh:9:(cat release.h | grep SHA1 | grep $GIT_SHA1) && \
mkreleasehdr.sh:11:echo "#define REDIS_GIT_SHA1 \"$GIT_SHA1\"" > release.h
module.c:2: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
module.c:34:#define REDISMODULE_CORE 1
module.c:78:#define REDISMODULE_AM_STRING 1
module.c:88: * 1) The memory is automatically released when the callback returns.
module.c:96:#define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)
module.c:139:#define REDISMODULE_CTX_MULTI_EMITTED (1<<0)
module.c:140:#define REDISMODULE_CTX_AUTO_MEMORY (1<<1)
module.c:141:#define REDISMODULE_CTX_KEYS_POS_REQUEST (1<<2)
module.c:142:#define REDISMODULE_CTX_BLOCKED_REPLY (1<<3)
module.c:143:#define REDISMODULE_CTX_BLOCKED_TIMEOUT (1<<4)
module.c:144:#define REDISMODULE_CTX_THREAD_SAFE (1<<5)
module.c:145:#define REDISMODULE_CTX_BLOCKED_DISCONNECTED (1<<6)
module.c:170:#define REDISMODULE_ZSET_RANGE_LEX 1
module.c:189:#define REDISMODULE_REPLYFLAG_TOPARSE (1<<0) /* Protocol must be parsed. */
module.c:190:#define REDISMODULE_REPLYFLAG_NESTED (1<<1)  /* Nested reply object. No proto
module.c:414: * 1) The key is not open for writing.
module.c:452: * The function returns 1 if the key value object is found empty and is
module.c:470:        return 1;
module.c:526:        robj *propargv[1];
module.c:528:        alsoPropagate(server.execCommand,c->db->id,propargv,1,
module.c:557:         * in that case the refcount is no longer 1. */
module.c:558:        if (c->argv[i]->refcount > 1)
module.c:600: *         RedisModule_KeyAtPos(ctx,1);
module.c:610:    ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));
module.c:617: * It returns the set of flags, or -1 if unknown flags are found. */
module.c:621:    sds *tokens = sdssplitlen(s,strlen(s)," ",1,&count);
module.c:640:    if (j != count) return -1; /* Some token not processed correctly. */
module.c:699:    if (flags == -1) return REDISMODULE_ERR;
module.c:726:    cp->rediscmd->arity = -1;
module.c:790:        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
module.c:801: * The function returns 1 if the object was actually found in the auto memory
module.c:806:    int count = (ctx->amqueue_used+1)/2;
module.c:810:             * side = 1 check the left side instead (zig-zag scanning). */
module.c:811:            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;
module.c:819:                if (i != ctx->amqueue_used-1) {
module.c:820:                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];
module.c:826:                return 1;
module.c:954: * 1) You have automatic memory management enabled.
module.c:977:         * value is 1 (instead of going to 2 to be dropped later to 1)
module.c:1018:/* Compare two string objects, returning -1, 0 or 1 respectively if
module.c:1028:    if (str->refcount != 1) {
module.c:1127:    sds strmsg = sdsnewlen(prefix,1);
module.c:1177:                (ctx->postponed_arrays_count+1));
module.c:1196: * For example in order to output an array like [1,[10,20,30]] we
module.c:1200: *      RedisModule_ReplyWithLongLong(ctx,1);
module.c:1202: *      RedisModule_ReplyWithLongLong(ctx,10);
module.c:1205: *      RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.
module.c:1255: * as the string "$-1\r\n".
module.c:1385: * 1. The ID is different for each different client, so if the same client
module.c:1391: * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way
module.c:1622:    if (expire == -1 || key->value == NULL) return -1;
module.c:1680: * 1. No other key writing function should be called since the moment
module.c:1723: * or resizing for more than 512 MB is requested.
module.c:1730:    if (newlen > 512*1024*1024) return REDISMODULE_ERR;
module.c:1749:            sdsrange(key->value->ptr,0,newlen-1);
module.c:1779: * 1) The list is empty.
module.c:1905: * setting it to 1 or 0 depending on the outcome of the operation.
module.c:1914:        if (deleted) *deleted = 1;
module.c:1943:    key->zer = 1;
module.c:1994:    if (key->zcurrent == NULL) key->zer = 1;
module.c:2002: * 1. The value stored at key is not a sorted set or the key is empty.
module.c:2014:    return zsetInitScoreRange(key,min,max,minex,maxex,1);
module.c:2058:    if (key->zcurrent == NULL) key->zer = 1;
module.c:2068: * 1. The value stored at key is not a sorted set or the key is empty.
module.c:2076:    return zsetInitLexRange(key,min,max,1);
module.c:2112:/* Go to the next element of the sorted set iterator. Returns 1 if there was
module.c:2125:            key->zer = 1;
module.c:2136:                    key->zer = 1;
module.c:2142:                    key->zer = 1;
module.c:2147:            return 1;
module.c:2152:            key->zer = 1;
module.c:2159:                key->zer = 1;
module.c:2163:                    key->zer = 1;
module.c:2168:            return 1;
module.c:2175:/* Go to the previous element of the sorted set iterator. Returns 1 if there was
module.c:2188:            key->zer = 1;
module.c:2199:                    key->zer = 1;
module.c:2205:                    key->zer = 1;
module.c:2210:            return 1;
module.c:2215:            key->zer = 1;
module.c:2222:                key->zer = 1;
module.c:2226:                    key->zer = 1;
module.c:2231:            return 1;
module.c:2252: * Example to set the hash argv[1] to the value argv[2]:
module.c:2254: *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);
module.c:2259: *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],
module.c:2302:    while(1) {
module.c:2341:        hashTypeTryConversion(key->value,argv,0,1);
module.c:2366: *      RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&first,
module.c:2387: *      RedisModule_HashGet(mykey,argv[1],&exists,NULL);
module.c:2402:    while(1) {
module.c:2467:    if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')
module.c:2495:    char *p = strchr(proto+1,'\r');
module.c:2497:    string2ll(proto+1,p-proto-1,&reply->val.ll);
module.c:2504:    char *p = strchr(proto+1,'\r');
module.c:2507:    string2ll(proto+1,p-proto-1,&bulklen);
module.c:2508:    if (bulklen == -1) {
module.c:2521:    char *p = strchr(proto+1,'\r');
module.c:2523:    reply->val.str = proto+1;
module.c:2524:    reply->len = p-proto-1;
module.c:2532:    char *p = strchr(proto+1,'\r');
module.c:2535:    string2ll(proto+1,p-proto-1,&arraylen);
module.c:2538:    if (arraylen == -1) {
module.c:2571:                RM_FreeCallReply_Rec(reply->val.array+j,1);
module.c:2669:#define REDISMODULE_ARGV_REPLICATE (1<<0)
module.c:2677:    argv_size = strlen(fmt)+1; /* +1 because of the command name. */
module.c:2707:              * We resize by vector_len-1 elements, because we held
module.c:2709:             argv_size += vlen-1;
module.c:2751:    c = createClient(-1);
module.c:2851:/* Turn a 9 chars name in the specified charset and a 10 bit encver into
module.c:2858: * if encver is outside the unsigned 10 bit integer range, 0 is returned,
module.c:2863: *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)
module.c:2866: * 6 bits value, immediately before the 10 bits integer, is name[8].
module.c:2867: * The last 10 bits are the encoding version.
module.c:2877:             "0123456789-_";
module.c:2884:    if (encver < 0 || encver > 1023) return 0;
module.c:2893:    id = (id << 10) | encver;
module.c:2953:            if (this_mt->id >> 10 == id >> 10) {
module.c:2971: * The buffer pointed by 'name' must be 10 bytes at least. The function will
module.c:2978:    moduleid >>= 10;
module.c:3002: *   and to register the type with encver=1. However this module may
module.c:3005: *   The encver must be a positive value between 0 and 1023.
module.c:3136:    exit(1);
module.c:3146:    if (retval == -1) goto saveerr;
module.c:3150:    if (retval == -1) goto saveerr;
module.c:3155:    io->error = 1;
module.c:3168:    if (retval == -1) goto loaderr;
module.c:3200:    if (retval == -1) goto saveerr;
module.c:3204:    if (retval == -1) goto saveerr;
module.c:3209:    io->error = 1;
module.c:3218:    if (retval == -1) goto saveerr;
module.c:3222:    if (retval == -1) goto saveerr;
module.c:3227:    io->error = 1;
module.c:3267:    return moduleLoadString(io,1,lenptr);
module.c:3277:    if (retval == -1) goto saveerr;
module.c:3281:    if (retval == -1) goto saveerr;
module.c:3286:    io->error = 1;
module.c:3298:    if (retval == -1) goto loaderr;
module.c:3313:    if (retval == -1) goto saveerr;
module.c:3317:    if (retval == -1) goto saveerr;
module.c:3322:    io->error = 1;
module.c:3334:    if (retval == -1) goto loaderr;
module.c:3424:        io->error = 1;
module.c:3438:        io->error = 1;
module.c:3445:        io->error = 1;
module.c:3450:            io->error = 1;
module.c:3625:    bc->reply_client = createClient(-1);
module.c:3656:    if (write(server.module_blocked_pipe[1],"A",1) != 1) {
module.c:3680: * 1. It is not safe to call Reply* family functions here, it is also
module.c:3706:    char buf[1];
module.c:3707:    while (read(server.module_blocked_pipe[0],buf,1) == 1);
module.c:3866:    ctx->client = createClient(-1);
module.c:3994:            sub->active = 1;
module.c:4146:    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
module.c:4289:long long aeTimer = -1; /* Main event loop (ae.c) timer identifier. */
module.c:4313:    while(1) {
module.c:4331:            next_period = (expiretime-now)/1000; /* Scale to milliseconds. */
module.c:4338:    if (next_period <= 0) next_period = 1;
module.c:4351:    uint64_t expiretime = ustime()+period*1000;
module.c:4354:    while(1) {
module.c:4367:    if (aeTimer != -1) {
module.c:4376:            aeTimer = -1;
module.c:4383:    if (aeTimer == -1)
module.c:4416:        *remaining = rem/1000; /* Scale to milliseconds. */
module.c:4433: * 1. Use a NULL context if you plan to retain a reference to this dictionary
module.c:4470:    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
module.c:4477:    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
module.c:4493: * be set by reference to 1 if the key does not exist, or to 0 if the key
module.c:4677:/* Return random bytes using SHA1 in counter mode with a /dev/urandom
module.c:4744: *         if (api_loaded != 0) return 1; // APIs already resolved.
module.c:4749: *         return 1;
module.c:4842: * 1. Invocation by a client.
module.c:4859: * 1. Register a `MODULE.SET` command which implements an extended version of
module.c:4972:    fctx->argv = zrealloc(fctx->argv, (fctx->argc+1)*sizeof(RedisModuleString *));
module.c:4974:        fctx->argv[i] = fctx->argv[i-1];
module.c:5007:    for (i = pos; i < fctx->argc-1; i++) {
module.c:5008:        fctx->argv[i] = fctx->argv[i+1];
module.c:5026:int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {
module.c:5028:    return strcmp(key1,key2) == 0;
module.c:5057:    moduleFreeContextReusedClient = createClient(-1);
module.c:5064:    if (pipe(server.module_blocked_pipe) == -1) {
module.c:5068:        exit(1);
module.c:5073:    anetNonBlock(NULL,server.module_blocked_pipe[1]);
module.c:5105:            exit(1);
module.c:5212:    if (dlclose(module->handle) == -1) {
module.c:5232:    char *subcmd = c->argv[1]->ptr;
modules/helloworld.c:9: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
modules/helloworld.c:65:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:86:    reply = RedisModule_Call(ctx,"RPUSH","ss",argv[1],argv[2]);
modules/helloworld.c:102:    reply = RedisModule_Call(ctx,"RPUSH","ss",argv[1],argv[2]);
modules/helloworld.c:117:    reply = RedisModule_Call(ctx,"LRANGE","sll",argv[1],(long long)0,(long long)-1);
modules/helloworld.c:137:    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:184:    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:224:    if (RedisModule_StringToLongLong(argv[1],&count) != REDISMODULE_OK ||
modules/helloworld.c:240:int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
modules/helloworld.c:274: * a numerical value) by 1, returning the sum of all the elements
modules/helloworld.c:282:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:317:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:359:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:385:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:435:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:466: * The command returns 1 if the copy is performed (srcfield exists) otherwise
modules/helloworld.c:472:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/helloworld.c:493: * was at the center of an issue with the npm modules system in March 2016.
modules/helloworld.c:520:    const char *str = RedisModule_StringPtrLen(argv[1], &strlen);
modules/helloworld.c:526:        return RedisModule_ReplyWithString(ctx,argv[1]);
modules/helloworld.c:529:    if (chlen != 1)
modules/helloworld.c:546:    if (RedisModule_Init(ctx,"helloworld",1,REDISMODULE_APIVER_1)
modules/helloworld.c:560:        HelloPushNative_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:564:        HelloPushCall_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:568:        HelloPushCall2_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:572:        HelloListSumLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:576:        HelloListSplice_RedisCommand,"write deny-oom",1,2,1) == REDISMODULE_ERR)
modules/helloworld.c:581:        "write deny-oom",1,2,1) == REDISMODULE_ERR)
modules/helloworld.c:588:    if (RedisModule_CreateCommand(ctx,"hello.repl1",
modules/helloworld.c:589:        HelloRepl1_RedisCommand,"write",0,0,0) == REDISMODULE_ERR)
modules/helloworld.c:593:        HelloRepl2_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:597:        HelloToggleCase_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:601:        HelloMoreExpire_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:605:        HelloZsumRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:609:        HelloLexRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:613:        HelloHCopy_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/helloworld.c:617:        HelloLeftPad_RedisCommand,"",1,1,1) == REDISMODULE_ERR)
modules/hellotimer.c:5: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
modules/hellotimer.c:52:    for (int j = 0; j < 10; j++) {
modules/hellotimer.c:68:    if (RedisModule_Init(ctx,"hellotimer",1,REDISMODULE_APIVER_1)
modules/testmodule.c:5: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
modules/testmodule.c:60:    RedisModule_Call(ctx,"RPUSH","csl","mylist",mystr,(long long)1234);
modules/testmodule.c:61:    reply = RedisModule_Call(ctx,"LRANGE","ccc","mylist","0","-1");
modules/testmodule.c:65:    RedisModuleCallReply *item0, *item1;
modules/testmodule.c:68:    item1 = RedisModule_CallReplyArrayElement(reply,1);
modules/testmodule.c:70:    if (!TestMatchReply(item1,"1234")) goto fail;
modules/testmodule.c:113:        "Got %d args. argv[1]: %s, argv[2]: %s", 
modules/testmodule.c:115:        RedisModule_StringPtrLen(argv[1], NULL),
modules/testmodule.c:142:    if (!rep || RedisModule_CallReplyInteger(rep) != 1) {
modules/testmodule.c:165:  RedisModule_Call(ctx, "HINCRBY", "csc", "notifications", key, "1");
modules/testmodule.c:198:        if (sz != 1 || *rep != '2') {
modules/testmodule.c:208:        if (sz != 1 || *rep != '2') {
modules/testmodule.c:218:        if (sz != 1 || *rep != '1') {
modules/testmodule.c:219:            FAIL("Got reply '%.*s'. expected '1'", sz, rep);
modules/testmodule.c:244:    int ok = 1;
modules/testmodule.c:270:    RedisModule_Call(ctx, "config", "ccc", "set", "save", "900 1");
modules/testmodule.c:281:    RedisModule_Call(ctx, "config", "ccc", "set", "maxmemory", "100000000");
modules/testmodule.c:308:/* Return 1 if the reply matches the specified string, otherwise log errors
modules/testmodule.c:328:    return 1;
modules/testmodule.c:331:/* Return 1 if the reply matches the specified integer, otherwise log errors
modules/testmodule.c:346:    return 1;
modules/testmodule.c:386:    if (!TestAssertStringReply(ctx,reply,"Got 3 args. argv[1]: foo, argv[2]: bar",38)) goto fail;
modules/testmodule.c:404:    if (RedisModule_Init(ctx,"test",1,REDISMODULE_APIVER_1)
modules/testmodule.c:408:        TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:412:        TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:416:        TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:420:        TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:424:        TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:428:        TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:432:        TestIt,"readonly",1,1,1) == REDISMODULE_ERR)
modules/testmodule.c:441:        TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/gendoc.rb:7:    s = s.gsub(/^ \* {0,1}/,"")
modules/gendoc.rb:9:    s.chop! while s[-1] == "\n" || s[-1] == " "
modules/gendoc.rb:35:        i = i-1
modules/gendoc.rb:47:        if src[i-1] =~ /\*\//
modules/hellocluster.c:5: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
modules/hellocluster.c:40:#define MSGTYPE_PING 1
modules/hellocluster.c:95:    if (RedisModule_Init(ctx,"hellocluster",1,REDISMODULE_APIVER_1)
modules/hellodict.c:8: * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
modules/hellodict.c:50:    RedisModule_DictSet(Keyspace,argv[1],argv[2]);
modules/hellodict.c:63:    RedisModuleString *val = RedisModule_DictGet(Keyspace,argv[1],NULL);
modules/hellodict.c:86:        Keyspace, ">=", argv[1]);
modules/hellodict.c:113:    if (RedisModule_Init(ctx,"hellodict",1,REDISMODULE_APIVER_1)
modules/hellodict.c:117:        cmd_SET,"write deny-oom",1,1,0) == REDISMODULE_ERR)
modules/hellodict.c:121:        cmd_GET,"readonly",1,1,0) == REDISMODULE_ERR)
modules/hellodict.c:125:        cmd_KEYRANGE,"readonly",1,1,0) == REDISMODULE_ERR)
modules/helloblock.c:6: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
modules/helloblock.c:67:    long long delay = (unsigned long)targ[1];
modules/helloblock.c:83: * amount of seconds with a while loop calling sleep(1), so that once we
modules/helloblock.c:102:    if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
modules/helloblock.c:123:    targ[1] = (void*)(unsigned long) delay;
modules/helloblock.c:155:            RedisModule_CallReplyArrayElement(reply,1);
modules/helloblock.c:183:    if (argc != 1) return RedisModule_WrongArity(ctx);
modules/helloblock.c:208:    if (RedisModule_Init(ctx,"helloblock",1,REDISMODULE_APIVER_1)
modules/hellotype.c:10: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
modules/hellotype.c:107:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/hellotype.c:143:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/hellotype.c:179:    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
modules/hellotype.c:257:    if (RedisModule_Init(ctx,"hellotype",1,REDISMODULE_APIVER_1)
modules/hellotype.c:274:        HelloTypeInsert_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
modules/hellotype.c:278:        HelloTypeRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
modules/hellotype.c:282:        HelloTypeLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
multi.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
multi.c:62:            sizeof(multiCmd)*(c->mstate.count+1));
multi.c:111:    propagate(server.multiCommand,c->db->id,&multistring,1,
multi.c:130:     * 1) Some WATCHed key was touched.
multi.c:175:            must_propagate = 1;
multi.c:201:            char *execcmd = "*1\r\n$4\r\nEXEC\r\n";
multi.c:314: * be touched. "dbid" is the DB that's getting the flush. -1 if it is
multi.c:317:    listIter li1, li2;
multi.c:321:    listRewind(server.clients,&li1);
multi.c:322:    while((ln = listNext(&li1))) {
multi.c:331:            if (dbid == -1 || wk->db->id == dbid) {
multi.c:346:    for (j = 1; j < c->argc; j++)
networking.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
networking.c:90:    /* passing -1 as fd it is possible to create a non connected client.
networking.c:94:    if (fd != -1) {
networking.c:112:    atomicGetIncr(server.next_client_id,client_id,1);
networking.c:126:    c->bulklen = -1;
networking.c:162:    if (fd != -1) linkClient(c);
networking.c:212: * 1) The event handler should already be installed since the output buffer
networking.c:268://1.如果有节点则保存在最后一个节点中，如果最后一个节点不能完全保存，则重新创建一个
networking.c:314:   1、状态回复（status reply）的第一个字节是 "+"
networking.c:321:      eg:":1000\r\n"
networking.c:323:   4、批量回复（bulk reply）的第一个字节是 "$",用于返回二进制安全的字符串，最大程度512M
networking.c:328:        :1\r\n
networking.c:398:     *    EVAL 'redis.call("incr",KEYS[1]); redis.call("nonexisting")' 1 x
networking.c:434:    addReplyString(c,"+",1);
networking.c:467:    char lenstr[128];
networking.c:507:    char dbuf[128], sbuf[128];
networking.c:514:        dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
networking.c:524:    robj *o = createStringObjectFromLongDouble(d,1);
networking.c:532:    char buf[128];
networking.c:547:    len = ll2string(buf+1,sizeof(buf)-1,ll);
networking.c:548:    buf[len+1] = '\r';
networking.c:556:    else if (ll == 1)
networking.c:578:        /* Compute how many bytes will take this integer as a radix 10 string */
networking.c:579:        len = 1;
networking.c:584:        while((n = n/10) != 0) {
networking.c:662:        (char*)c->argv[1]->ptr,cmd);
networking.c:698:#define MAX_ACCEPTS_PER_CALL 1000
networking.c:716:        if (write(c->fd,err,strlen(err)) == -1) {
networking.c:734:        if (strcmp(ip,"127.0.0.1") && strcmp(ip,"::1")) {
networking.c:742:                "1) Just disable protected mode sending the command "
networking.c:756:            if (write(c->fd,err,strlen(err)) == -1) {
networking.c:837:     * fd is already set to -1. */
networking.c:838:    if (c->fd != -1) {
networking.c:861:        c->fd = -1;
networking.c:942:    /* Master/slave cleanup Case 1:
networking.c:946:            if (c->repldbfd != -1) close(c->repldbfd);
networking.c:1004: * of registered clients. Note that "fake clients", created with -1 as FD,
networking.c:1076:    if (nwritten == -1) {
networking.c:1110:    writeToClient(fd,privdata,1);
networking.c:1166:    c->bulklen = -1;
networking.c:1192: * 1) It removes the file events. This way it is not possible that an
networking.c:1225:    int argc, j, linefeed_chars = 1;
networking.c:1242:    if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
networking.c:1286:#define PROTO_DUMP_LEN 128
networking.c:1329:        $<参数 1 的字节数量> CR LF
networking.c:1330:        <参数 1 的数据> CR LF
networking.c:1361:        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);
networking.c:1362:        if (!ok || ll > 1024*1024) {
networking.c:1382:        if (c->bulklen == -1) {
networking.c:1406:            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);
networking.c:1425:                    sdsrange(c->querybuf,c->qb_pos,-1);
networking.c:1458:            c->bulklen = -1;
networking.c:1544:        sdsrange(c->querybuf,c->qb_pos,-1);
networking.c:1565:            sdsrange(c->pending_querybuf,applied,-1);
networking.c:1584:    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
networking.c:1598:    if (nread == -1) {
networking.c:1661: * For IPv4 it's in the form x.y.z.k:port, example: "127.0.0.1:1234".
networking.c:1662: * For IPv6 addresses we use [] around the IP part, like in "[::1]:1234".
networking.c:1699:    char flags[16], events[3], *p;
networking.c:1722:    emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
networking.c:1739:        (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,
networking.c:1758:        if (type != -1 && getClientType(client) != type) continue;
networking.c:1760:        o = sdscatlen(o,"\n",1);
networking.c:1770:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
networking.c:1788:    } else if (!strcasecmp(c->argv[1]->ptr,"id") && c->argc == 2) {
networking.c:1791:    } else if (!strcasecmp(c->argv[1]->ptr,"list")) {
networking.c:1793:        int type = -1;
networking.c:1796:            if (type == -1) {
networking.c:1808:    } else if (!strcasecmp(c->argv[1]->ptr,"reply") && c->argc == 3) {
networking.c:1822:    } else if (!strcasecmp(c->argv[1]->ptr,"kill")) {
networking.c:1826:        int type = -1;
networking.c:1828:        int skipme = 1;
networking.c:1840:                int moreargs = c->argc > i+1;
networking.c:1845:                    if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
networking.c:1849:                    type = getClientTypeByName(c->argv[i+1]->ptr);
networking.c:1850:                    if (type == -1) {
networking.c:1852:                            (char*) c->argv[i+1]->ptr);
networking.c:1856:                    addr = c->argv[i+1]->ptr;
networking.c:1858:                    if (!strcasecmp(c->argv[i+1]->ptr,"yes")) {
networking.c:1859:                        skipme = 1;
networking.c:1860:                    } else if (!strcasecmp(c->argv[i+1]->ptr,"no")) {
networking.c:1882:            if (type != -1 && getClientType(client) != type) continue;
networking.c:1888:                close_this_client = 1;
networking.c:1908:    } else if (!strcasecmp(c->argv[1]->ptr,"unblock") && (c->argc == 3 ||
networking.c:1919:                unblock_error = 1;
networking.c:1940:    } else if (!strcasecmp(c->argv[1]->ptr,"setname") && c->argc == 3) {
networking.c:1968:    } else if (!strcasecmp(c->argv[1]->ptr,"getname") && c->argc == 2) {
networking.c:1973:    } else if (!strcasecmp(c->argv[1]->ptr,"pause") && c->argc == 3) {
networking.c:1981:        addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP", (char*)c->argv[1]->ptr);
networking.c:2052: * 1. Make sure there are no "holes" and all the arguments are set.
networking.c:2060:        c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));
networking.c:2061:        c->argc = i+1;
networking.c:2110:    else return -1;
networking.c:2140:        hard = 1;
networking.c:2143:        soft = 1;
networking.c:2176:    if (c->fd == -1) return; /* It is unsafe to free fake clients. */
networking.c:2177:    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
networking.c:2237:    server.clients_paused = 1;
notify.c:2: * Copyright (c) 2013, Salvatore Sanfilippo <antirez at gmail dot com>
notify.c:38: * The function returns -1 if the input contains characters not mapping to
notify.c:58:        default: return -1;
notify.c:73:        res = sdscatlen(res,"A",1);
notify.c:75:        if (flags & NOTIFY_GENERIC) res = sdscatlen(res,"g",1);
notify.c:76:        if (flags & NOTIFY_STRING) res = sdscatlen(res,"$",1);
notify.c:77:        if (flags & NOTIFY_LIST) res = sdscatlen(res,"l",1);
notify.c:78:        if (flags & NOTIFY_SET) res = sdscatlen(res,"s",1);
notify.c:79:        if (flags & NOTIFY_HASH) res = sdscatlen(res,"h",1);
notify.c:80:        if (flags & NOTIFY_ZSET) res = sdscatlen(res,"z",1);
notify.c:81:        if (flags & NOTIFY_EXPIRED) res = sdscatlen(res,"x",1);
notify.c:82:        if (flags & NOTIFY_EVICTED) res = sdscatlen(res,"e",1);
notify.c:83:        if (flags & NOTIFY_STREAM) res = sdscatlen(res,"t",1);
notify.c:85:    if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,"K",1);
notify.c:86:    if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,"E",1);
notify.c:100:    int len = -1;
notify.c:116:        chan = sdsnewlen("__keyspace@",11);
notify.c:129:        chan = sdsnewlen("__keyevent@",11);
notify.c:130:        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);
object.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
object.c:46:    o->refcount = 1;
object.c:70:    serverAssert(o->refcount == 1);
object.c:85:    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
object.c:86:    struct sdshdr8 *sh = (void*)(o+1);
object.c:90:    o->ptr = sh+1;
object.c:91:    o->refcount = 1;
object.c:107:        memset(sh->buf,0,len+1);
object.c:170:    return createStringObjectFromLongLongWithOptions(value,1);
object.c:190: * will always result in a fresh object that is unshared (refcount == 1).
object.c:192: * The resulting object always has refcount set to 1. */
object.c:354:    if (o->refcount == 1) {
object.c:399:        return 1;
object.c:419: * in case there is more than 10% of free space at the end of the SDS
object.c:424:        sdsavail(o->ptr) > sdslen(o->ptr)/10)
object.c:450:     if (o->refcount > 1) return o;
object.c:494:     * is more than 10% of free space at the end of the SDS string.
object.c:533:#define REDIS_COMPARE_BINARY (1<<0)
object.c:534:#define REDIS_COMPARE_COLL (1<<1)
object.c:538:    char bufa[128], bufb[128], *astr, *bstr;
object.c:578:/* Equal string objects return 1 if the two objects are the same from the
object.c:598:        return sdigits10((long)o->ptr);
object.c:756: * approximate it considering 16 bytes of data overhead for each
object.c:874:         * use the average to compute the size of the first N-1 listpacks, and
object.c:889:            asize += lpsize * (s->rax->numele-1);
object.c:1046:        mh->db = zrealloc(mh->db,sizeof(mh->db[0])*(mh->num_dbs+1));
object.c:1065:    mh->peak_perc = (float)zmalloc_used*100/mh->peak_allocated;
object.c:1069:    size_t net_usage = 1;
object.c:1072:    mh->dataset_perc = (float)mh->dataset*100/net_usage;
object.c:1101:    if (mh->total_allocated < (1024*1024*5)) {
object.c:1102:        empty = 1;
object.c:1105:        /* Peak is > 150% of current used memory? */
object.c:1106:        if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
object.c:1107:            big_peak = 1;
object.c:1111:        /* Fragmentation is higher than 1.4 and 10MB ?*/
object.c:1112:        if (mh->total_frag > 1.4 && mh->total_frag_bytes > 10<<20) {
object.c:1113:            high_frag = 1;
object.c:1117:        /* External fragmentation is higher than 1.1 and 10MB? */
object.c:1118:        if (mh->allocator_frag > 1.1 && mh->allocator_frag_bytes > 10<<20) {
object.c:1119:            high_alloc_frag = 1;
object.c:1123:        /* Allocator fss is higher than 1.1 and 10MB ? */
object.c:1124:        if (mh->allocator_rss > 1.1 && mh->allocator_rss_bytes > 10<<20) {
object.c:1125:            high_alloc_rss = 1;
object.c:1129:        /* Non-Allocator fss is higher than 1.1 and 10MB ? */
object.c:1130:        if (mh->rss_extra > 1.1 && mh->rss_extra_bytes > 10<<20) {
object.c:1131:            high_proc_rss = 1;
object.c:1138:        if (mh->clients_normal / numclients > (1024*200)) {
object.c:1139:            big_client_buf = 1;
object.c:1143:        /* Slaves using more than 10 MB each? */
object.c:1144:        if (numslaves > 0 && mh->clients_slaves / numslaves > (1024*1024*10)) {
object.c:1145:            big_slave_buf = 1;
object.c:1150:        if (dictSize(server.lua_scripts) > 1000) {
object.c:1151:            many_scripts = 1;
object.c:1161:    } else if (empty == 1) {
object.c:1171:            s = sdscat(s," * Peak memory: In the past this instance used more than 150% the memory that is currently using. The allocator is normally not able to release memory after a peak, so you can expect to see a big fragmentation ratio, however this is actually harmless and is only due to the memory peak, and if the Redis instance Resident Set Size (RSS) is currently bigger than expected, the memory will be used as soon as you fill the Redis instance with more data. If the memory peak was only occasional and you want to try to reclaim memory, please try the MEMORY PURGE command, otherwise the only other option is to shutdown and restart the instance.\n\n");
object.c:1174:            s = sdscatprintf(s," * High total RSS: This instance has a memory fragmentation and RSS overhead greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the sum of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, then there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is \"%s\".\n\n", ZMALLOC_LIB);
object.c:1177:            s = sdscatprintf(s," * High allocator fragmentation: This instance has an allocator external fragmentation greater than 1.1. This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. You can try enabling 'activedefrag' config option.\n\n");
object.c:1180:            s = sdscatprintf(s," * High allocator RSS overhead: This instance has an RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the allocator is much larger than the sum what the allocator actually holds). This problem is usually due to a large peak memory (check if there is a peak memory entry above in the report), you can try the MEMORY PURGE command to reclaim it.\n\n");
object.c:1183:            s = sdscatprintf(s," * High process RSS overhead: This instance has non-allocator RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the Redis process is much larger than the RSS the allocator holds). This problem may be due to Lua scripts or Modules.\n\n");
object.c:1186:            s = sdscat(s," * Big replica buffers: The replica output buffers in this instance are greater than 10MB for each replica (on average). This likely means that there is some replica instance that is struggling receiving data, either because it is too slow or because of networking issues. As a result, data piles on the master output buffers. Please try to identify what replica is not receiving data correctly and why. You can use the INFO output in order to check the replicas delays and the CLIENT LIST command to check the output buffers of each replica.\n\n");
object.c:1192:            s = sdscat(s," * Many scripts: There seem to be many cached scripts in this instance (more than 1000). This may be because scripts are generated and `EVAL`ed, instead of being parameterized (with KEYS and ARGV), `SCRIPT LOAD`ed and `EVALSHA`ed. Unless `SCRIPT FLUSH` is called periodically, the scripts' caches may end up consuming most of your memory.\n\n");
object.c:1215:         * instance was compiled with (normally 1000 ms, so the
object.c:1216:         * below statement will expand to lru_idle*1000/1000. */
object.c:1217:        lru_idle = lru_idle*1000/LRU_CLOCK_RESOLUTION;
object.c:1253:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
object.c:1262:    } else if (!strcasecmp(c->argv[1]->ptr,"refcount") && c->argc == 3) {
object.c:1266:    } else if (!strcasecmp(c->argv[1]->ptr,"encoding") && c->argc == 3) {
object.c:1270:    } else if (!strcasecmp(c->argv[1]->ptr,"idletime") && c->argc == 3) {
object.c:1277:        addReplyLongLong(c,estimateObjectIdleTime(o)/1000);
object.c:1278:    } else if (!strcasecmp(c->argv[1]->ptr,"freq") && c->argc == 3) {
object.c:1300:    if (!strcasecmp(c->argv[1]->ptr,"help") && c->argc == 2) {
object.c:1310:    } else if (!strcasecmp(c->argv[1]->ptr,"usage") && c->argc >= 3) {
object.c:1315:                j+1 < c->argc)
object.c:1317:                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&samples,NULL)
object.c:1338:    } else if (!strcasecmp(c->argv[1]->ptr,"stats") && c->argc == 2) {
object.c:1432:    } else if (!strcasecmp(c->argv[1]->ptr,"malloc-stats") && c->argc == 2) {
object.c:1440:    } else if (!strcasecmp(c->argv[1]->ptr,"doctor") && c->argc == 2) {
object.c:1443:    } else if (!strcasecmp(c->argv[1]->ptr,"purge") && c->argc == 2) {
object.c:1461:        addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try MEMORY HELP", (char*)c->argv[1]->ptr);
pqsort.c:4: * Copyright(C) 2009-2012 Salvatore Sanfilippo. All rights reserved.
pqsort.c:9:/*	$NetBSD: qsort.c,v 1.19 2009/01/30 23:38:44 lukem Exp $	*/
pqsort.c:12: * Copyright (c) 1992, 1993
pqsort.c:18: * 1. Redistributions of source code must retain the above copyright
pqsort.c:66:	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
pqsort.c:72:	if (swaptype <= 1)
pqsort.c:117:		pn = (char *) a + (n - 1) * es;
pqsort.c:129:	pc = pd = (char *) a + (n - 1) * es;
pqsort.c:158:                void *_l = a, *_r = ((unsigned char*)a)+r-1;
pqsort.c:171:                _r = ((unsigned char*)a)+r-1;
pqsort.c:184:                       ((unsigned char*)a)+((rrange+1)*es)-1);
pqsort.h:4: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
pubsub.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
pubsub.c:56:/* Subscribe a client to a channel. Returns 1 if the operation succeeded, or
pubsub.c:65:        retval = 1;
pubsub.c:86:/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
pubsub.c:99:        retval = 1;
pubsub.c:129:/* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern. */
pubsub.c:134:        retval = 1;
pubsub.c:151:/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
pubsub.c:160:        retval = 1;
pubsub.c:234://        value:pubsubPattern...1.client 2.robj pattern.
pubsub.c:294:    //如果没有注册，增加。同时添加到server.pubsub_channels中返回1.其他返回0
pubsub.c:295:    for (j = 1; j < c->argc; j++)
pubsub.c:301:    if (c->argc == 1) {
pubsub.c:302:        pubsubUnsubscribeAllChannels(c,1);
pubsub.c:306:        for (j = 1; j < c->argc; j++)
pubsub.c:307:            pubsubUnsubscribeChannel(c,c->argv[j],1);
pubsub.c:316:    for (j = 1; j < c->argc; j++)
pubsub.c:322:    if (c->argc == 1) {
pubsub.c:323:        pubsubUnsubscribeAllPatterns(c,1);
pubsub.c:327:        for (j = 1; j < c->argc; j++)
pubsub.c:328:            pubsubUnsubscribePattern(c,c->argv[j],1);
pubsub.c:334:    int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
pubsub.c:336:        clusterPropagatePublish(c->argv[1],c->argv[2]);
pubsub.c:344:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
pubsub.c:348:"NUMSUB [channel-1 .. channel-N] -- Returns the number of subscribers for the specified channels (excluding patterns, default: none).",
pubsub.c:352:    } else if (!strcasecmp(c->argv[1]->ptr,"channels") &&
pubsub.c:376:    } else if (!strcasecmp(c->argv[1]->ptr,"numsub") && c->argc >= 2) {
pubsub.c:377:        /* PUBSUB NUMSUB [Channel_1 ... Channel_N] */
pubsub.c:387:    } else if (!strcasecmp(c->argv[1]->ptr,"numpat") && c->argc == 2) {
quicklist.c:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>
quicklist.c:47:static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};
quicklist.c:51:#define SIZE_SAFETY_LIMIT 8192
quicklist.c:77:        (e)->longval = -123456789;                                             \
quicklist.c:80:        (e)->offset = 123456789;                                               \
quicklist.c:85:#define likely(x) __builtin_expect(!!(x), 1)
quicklist.c:106:#define COMPRESS_MAX (1 << 16)
quicklist.c:116:#define FILL_MAX (1 << 15)
quicklist.c:176: * Returns 1 if ziplist compressed successfully.
quicklist.c:180:    node->attempted_compress = 1;
quicklist.c:204:    return 1;
quicklist.c:216: * Returns 1 on successful decode, 0 on failure to decode. */
quicklist.c:232:    return 1;
quicklist.c:248:            (_node)->recompress = 1;                                           \
quicklist.c:277:    if (quicklist->compress == 1) {
quicklist.c:316:            in_depth = 1;
quicklist.c:350:/* Insert 'new_node' after 'old_node' if 'after' is 1.
quicklist.c:399:    __quicklistInsertNode(quicklist, old_node, new_node, 1);
quicklist.c:408:    size_t offset = (-fill) - 1;
quicklist.c:411:            return 1;
quicklist.c:430:        ziplist_overhead = 1;
quicklist.c:436:        ziplist_overhead += 1;
quicklist.c:437:    else if (likely(sz < 16384))
quicklist.c:445:        return 1;
quicklist.c:449:        return 1;
quicklist.c:460:    /* approximate merged ziplist size (- 11 to remove one ziplist
quicklist.c:462:    unsigned int merge_sz = a->sz + b->sz - 11;
quicklist.c:464:        return 1;
quicklist.c:468:        return 1;
quicklist.c:481: * Returns 1 if new head created. */
quicklist.c:504: * Returns 1 if new tail created. */
quicklist.c:613: * Returns 1 if the entire node was deleted, 0 if node still exists.
quicklist.c:622:        gone = 1;
quicklist.c:629:    return gone ? 1 : 0;
quicklist.c:652:            iter->offset = -1;
quicklist.c:658:     *   - [1, 2, 3] => delete offset 1 => [1, 3]: next element still offset 1
quicklist.c:659:     *   - [1, 2, 3] => delete offset 0 => [2, 3]: next element still offset 0
quicklist.c:661:     *  length of this ziplist is N-1, the next call into
quicklist.c:667: * Returns 1 if replace happened.
quicklist.c:678:        return 1;
quicklist.c:783: * If 'after'==1, returned node has elements after 'offset'.
quicklist.c:788: * If 'after'==1, returned node will have elements _after_ 'offset'.
quicklist.c:789: *                The returned node will have elements [OFFSET+1, END].
quicklist.c:794: *                The input node keeps elements [OFFSET+1, END].
quicklist.c:809:    /* -1 here means "continue deleting until the list ends" */
quicklist.c:810:    int orig_start = after ? offset + 1 : 0;
quicklist.c:811:    int orig_extent = after ? -1 : offset;
quicklist.c:813:    int new_extent = after ? offset + 1 : -1;
quicklist.c:832: * If after==1, the new value is inserted after 'entry', otherwise
quicklist.c:856:        full = 1;
quicklist.c:861:        at_tail = 1;
quicklist.c:864:            full_next = 1;
quicklist.c:870:        at_head = 1;
quicklist.c:873:            full_prev = 1;
quicklist.c:951:    _quicklistInsert(quicklist, entry, value, sz, 1);
quicklist.c:959: * Returns 1 if entries were deleted, 0 if nothing was deleted. */
quicklist.c:992:            delete_entire_node = 1;
quicklist.c:1040:    return 1;
quicklist.c:1044:int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
quicklist.c:1045:    return ziplistCompare(p1, p2, p2_len);
quicklist.c:1060:        iter->offset = -1;
quicklist.c:1146:            offset_update = 1;
quicklist.c:1149:            offset_update = -1;
quicklist.c:1161:        return 1;
quicklist.c:1175:            iter->offset = -1;
quicklist.c:1220: * where 0 is the head, 1 is the element next to head
quicklist.c:1222: * from the tail, -1 is the last element, -2 the penultimate
quicklist.c:1225: * Returns 1 if element found
quicklist.c:1232:    int forward = idx < 0 ? 0 : 1; /* < 0 -> reverse, 0+ -> forward */
quicklist.c:1238:        index = (-idx) - 1;
quicklist.c:1263:      accum, index, index - accum, (-index) - 1 + accum);
quicklist.c:1272:        entry->offset = (-index) - 1 + accum;
quicklist.c:1281:    return 1;
quicklist.c:1286:    if (quicklist->count <= 1)
quicklist.c:1290:    unsigned char *p = ziplistIndex(quicklist->tail->zl, -1);
quicklist.c:1310:    if (quicklist->len == 1) {
quicklist.c:1311:        p = ziplistIndex(quicklist->tail->zl, -1);
quicklist.c:1325: * Return value of 1 means check 'data' and 'sval' for values.
quicklist.c:1334:    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;
quicklist.c:1344:        *sval = -123456789;
quicklist.c:1369:        return 1;
quicklist.c:1473:    ust = ((long long)tv.tv_sec) * 1000000;
quicklist.c:1479:static long long mstime(void) { return ustime() / 1000; }
quicklist.c:1482: * Print the list if 'print' == 1.
quicklist.c:1508:    return _itrprintr(ql, print, 1);
quicklist.c:1625:    int options[] = {0, 1, 2, 3, 4, 5, 6, 10};
quicklist.c:1642:            /* 1 for head and 1 for tail because 1 node = head = tail */
quicklist.c:1643:            ql_verify(ql, 1, 1, 1, 1);
quicklist.c:1650:            /* 1 for head and 1 for tail because 1 node = head = tail */
quicklist.c:1651:            ql_verify(ql, 1, 1, 1, 1);
quicklist.c:1664:                    ql_verify(ql, 1, 5, 5, 5);
quicklist.c:1678:                    ql_verify(ql, 1, 5, 5, 5);
quicklist.c:1683:        for (int f = optimize_start; f < 512; f++) {
quicklist.c:1692:                    ql_verify(ql, 16, 500, 32, 20);
quicklist.c:1697:        for (int f = optimize_start; f < 512; f++) {
quicklist.c:1706:                    ql_verify(ql, 16, 500, 20, 32);
quicklist.c:1725:                ql_verify(ql, 1, 1, 1, 1);
quicklist.c:1736:                quicklistPushHead(ql, "-1200", 5);
quicklist.c:1745:                if (f == 1)
quicklist.c:1746:                    ql_verify(ql, 504, 504, 1, 1);
quicklist.c:1750:                    ql_verify(ql, 16, 504, 32, 24);
quicklist.c:1762:        TEST("pop 1 string from 1") {
quicklist.c:1764:            char *populate = genstr("hello", 331);
quicklist.c:1781:        TEST("pop head 1 number from 1") {
quicklist.c:1783:            quicklistPushHead(ql, "55513", 5);
quicklist.c:1790:            assert(lv == 55513);
quicklist.c:1805:                assert(ret == 1);
quicklist.c:1827:                    assert(ret == 1);
quicklist.c:1861:            ql_verify(ql, 16, 500, 20, 32);
quicklist.c:1883:            ql_verify(ql, 16, 500, 20, 32);
quicklist.c:1893:            ql_verify(ql, 1, 1, 1, 1);
quicklist.c:1902:            ql_verify(ql, 1, 1, 1, 1);
quicklist.c:1906:        TEST("insert after 1 element") {
quicklist.c:1912:            ql_verify(ql, 1, 2, 2, 2);
quicklist.c:1916:        TEST("insert before 1 element") {
quicklist.c:1922:            ql_verify(ql, 1, 2, 2, 2);
quicklist.c:1926:        for (int f = optimize_start; f < 12; f++) {
quicklist.c:1932:                quicklistSetFill(ql, 1);
quicklist.c:1945:                        /* Insert as fill = 1 so it spills into new node. */
quicklist.c:1957:                quicklistIndex(ql, 1, &entry);
quicklist.c:1959:                    ERR("Value 1 didn't match, instead got: %.*s", entry.sz,
quicklist.c:1982:        for (int f = optimize_start; f < 1024; f++) {
quicklist.c:2001:        for (int f = optimize_start; f < 1024; f++) {
quicklist.c:2032:        TEST("duplicate list of 1 element") {
quicklist.c:2035:            ql_verify(ql, 1, 1, 1, 1);
quicklist.c:2037:            ql_verify(copy, 1, 1, 1, 1);
quicklist.c:2047:            ql_verify(ql, 16, 500, 20, 32);
quicklist.c:2050:            ql_verify(copy, 16, 500, 20, 32);
quicklist.c:2055:        for (int f = optimize_start; f < 512; f++) {
quicklist.c:2056:            TEST_DESC("index 1,200 from 500 list at fill %d at compress %d", f,
quicklist.c:2060:                    quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2062:                quicklistIndex(ql, 1, &entry);
quicklist.c:2068:                if (!strcmp((char *)entry.value, "hello201"))
quicklist.c:2075:            TEST_DESC("index -1,-2 from 500 list at fill %d at compress %d", f,
quicklist.c:2079:                    quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2081:                quicklistIndex(ql, -1, &entry);
quicklist.c:2094:            TEST_DESC("index -100 from 500 list at fill %d at compress %d", f,
quicklist.c:2098:                    quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2100:                quicklistIndex(ql, -100, &entry);
quicklist.c:2101:                if (!strcmp((char *)entry.value, "hello401"))
quicklist.c:2108:            TEST_DESC("index too big +1 from 50 list at fill %d at compress %d",
quicklist.c:2112:                    quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2134:            ql_verify(ql, 1, 32, 32, 32);
quicklist.c:2144:            ql_verify(ql, 1, 32, 32, 32);
quicklist.c:2145:            quicklistDelRange(ql, 0, 128);
quicklist.c:2150:        TEST("delete middle 100 of 500 list") {
quicklist.c:2154:                quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2155:            ql_verify(ql, 16, 500, 32, 20);
quicklist.c:2156:            quicklistDelRange(ql, 200, 100);
quicklist.c:2157:            ql_verify(ql, 14, 400, 32, 20);
quicklist.c:2161:        TEST("delete negative 1 from 500 list") {
quicklist.c:2165:                quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2166:            ql_verify(ql, 16, 500, 32, 20);
quicklist.c:2167:            quicklistDelRange(ql, -1, 1);
quicklist.c:2168:            ql_verify(ql, 16, 499, 32, 19);
quicklist.c:2172:        TEST("delete negative 1 from 500 list with overflow counts") {
quicklist.c:2176:                quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2177:            ql_verify(ql, 16, 500, 32, 20);
quicklist.c:2178:            quicklistDelRange(ql, -1, 128);
quicklist.c:2179:            ql_verify(ql, 16, 499, 32, 19);
quicklist.c:2183:        TEST("delete negative 100 from 500 list") {
quicklist.c:2187:                quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2188:            quicklistDelRange(ql, -100, 100);
quicklist.c:2189:            ql_verify(ql, 13, 400, 32, 16);
quicklist.c:2193:        TEST("delete -10 count 5 from 50 list") {
quicklist.c:2197:                quicklistPushTail(ql, genstr("hello", i + 1), 32);
quicklist.c:2198:            ql_verify(ql, 2, 50, 32, 18);
quicklist.c:2199:            quicklistDelRange(ql, -10, 5);
quicklist.c:2200:            ql_verify(ql, 2, 45, 32, 13);
quicklist.c:2206:            quicklistPushTail(ql, "1111", 4);
quicklist.c:2210:            ql_verify(ql, 1, 4, 4, 4);
quicklist.c:2213:            if (entry.longval != 1111)
quicklist.c:2214:                ERR("Not 1111, %lld", entry.longval);
quicklist.c:2215:            quicklistIndex(ql, 1, &entry);
quicklist.c:2226:            quicklistIndex(ql, -1, &entry);
quicklist.c:2236:            if (entry.longval != 1111)
quicklist.c:2237:                ERR("Not 1111 (reverse), %lld", entry.longval);
quicklist.c:2249:                nums[i] = -5157318210846258176 + i;
quicklist.c:2265:            ql_verify(ql, 157, 5001, 32, 9);
quicklist.c:2276:            quicklistReplaceAtIndex(ql, 1, "foo", 3);
quicklist.c:2277:            quicklistReplaceAtIndex(ql, -1, "bar", 3);
quicklist.c:2282:        for (int f = optimize_start; f < 16; f++) {
quicklist.c:2309:                int ok = 1;
quicklist.c:2349:                    if (strncmp((char *)entry.value, resultB[resB - 1 - i],
quicklist.c:2352:                            i, entry.sz, entry.value, resultB[resB - 1 - i]);
quicklist.c:2366:        for (int f = optimize_start; f < 16; f++) {
quicklist.c:2413:                    nums[i] = -5157318210846258176 + i;
quicklist.c:2440:                    nums[i] = -5157318210846258176 + i;
quicklist.c:2445:                    ql_verify(ql, 1, 32, 32, 32);
quicklist.c:2458:                    ql_verify(ql, 1, 7, 7, 7);
quicklist.c:2477:                    ql_verify(ql, 2, 33, 32, 1);
quicklist.c:2478:                /* ltrim 5 16 (keep [5,16] inclusive = 12 remaining) */
quicklist.c:2480:                quicklistDelRange(ql, -16, 16);
quicklist.c:2482:                    ql_verify(ql, 1, 12, 12, 12);
quicklist.c:2489:                quicklistIndex(ql, -1, &entry);
quicklist.c:2490:                if (entry.longval != 16)
quicklist.c:2495:                quicklistIndex(ql, -1, &entry);
quicklist.c:2499:                for (int i = 0; i < 12; i++) {
quicklist.c:2517:                    nums[i] = -5157318210846258176 + i;
quicklist.c:2522:                    ql_verify(ql, 2, 33, 32, 1);
quicklist.c:2523:                /* ltrim 3 3 (keep [3,3] inclusive = 1 remaining) */
quicklist.c:2528:                    ql_verify(ql, 1, 1, 1, 1);
quicklist.c:2531:                if (entry.longval != -5157318210846258173)
quicklist.c:2546:                    nums[i] = -5157318210846258176 + i;
quicklist.c:2551:                    ql_verify(ql, 2, 33, 32, 1);
quicklist.c:2552:                quicklistDelRange(ql, -12, 3);
quicklist.c:2567:                    nums[i] = -5157318210846258176 + i;
quicklist.c:2577:                if (f == 1)
quicklist.c:2578:                    ql_verify(ql, 66, 66, 1, 1);
quicklist.c:2582:                    ql_verify(ql, 1, 66, 66, 66);
quicklist.c:2592:    int list_sizes[] = {250, 251, 500, 999, 1000};
quicklist.c:2596:        for (int f = optimize_start; f < 128; f++) {
quicklist.c:2597:            for (int depth = 1; depth < 40; depth++) {
quicklist.c:2605:                        quicklistPushTail(ql, genstr("hello TAIL", i + 1), 64);
quicklist.c:2606:                        quicklistPushHead(ql, genstr("hello HEAD", i + 1), 64);
quicklist.c:2643:               (float)runtime[i] / 1000);
quicklist.c:2644:    printf("Compressions: %0.2f seconds.\n", (float)(stop - start) / 1000);
quicklist.h:3: * Copyright (c) 2014, Matt Stancliff <matt@genges.com>
quicklist.h:38: * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually < 32k).
quicklist.h:39: * encoding: 2 bits, RAW=1, LZF=2.
quicklist.h:40: * container: 2 bits, NONE=1, ZIPLIST=2.
quicklist.h:41: * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.
quicklist.h:42: * attempted_compress: 1 bit, boolean, used for verifying during testing.
quicklist.h:43: * extra: 10 bits, free for future use; pads out the remainder of 32 bits */
quicklist.h:55:    unsigned int count : 16;     /* count of items in ziplist */
quicklist.h:56:    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
quicklist.h:57:    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */
quicklist.h:58:    unsigned int recompress : 1; /* was this node previous compressed? */
quicklist.h:59:    unsigned int attempted_compress : 1; /* node can't compress; too small */
quicklist.h:60:    unsigned int extra : 10; /* more bits to steal for future usage */
quicklist.h:78: * 'compress' is: -1 if compression disabled, otherwise it's the number
quicklist.h:88:    int fill : 16;              /* fill factor for individual nodes */
quicklist.h:89:    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */
quicklist.h:100://ziplist中能够存储u4 u8 u16 u24 u32 u64 以及字符串
quicklist.h:112:#define QUICKLIST_TAIL -1
quicklist.h:115:#define QUICKLIST_NODE_ENCODING_RAW 1
quicklist.h:122:#define QUICKLIST_NODE_CONTAINER_NONE 1
quicklist.h:169:int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len);
quicklist.h:178:#define AL_START_TAIL 1
rand.c:12: * 1960-style C coding stuff...
rand.c:16: * Copyright (c) 2010-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rand.c:46:#define N	16
rand.c:47:#define MASK	((1 << (N - 1)) + (1 << (N - 1)) - 1)
rand.c:51:		(z)[0] = LOW(l); (z)[1] = HIGH(l); }
rand.c:55:#define X1	0xABCD
rand.c:56:#define X2	0x1234
rand.c:58:#define A1	0xDEEC
rand.c:61:#define SET3(x, x0, x1, x2)	((x)[0] = (x0), (x)[1] = (x1), (x)[2] = (x2))
rand.c:62:#define SETLOW(x, y, n) SET3(x, LOW((y)[n]), LOW((y)[(n)+1]), LOW((y)[(n)+2]))
rand.c:63:#define SEED(x0, x1, x2) (SET3(x, x0, x1, x2), SET3(a, A0, A1, A2), c = C)
rand.c:66:#define HI_BIT	(1L << (2 * N - 1))
rand.c:68:static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;
rand.c:73:    return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
rand.c:81:    uint32_t p[2], q[2], r[2], carry0, carry1;
rand.c:85:    ADDEQU(p[1], carry0, carry1);
rand.c:86:    MUL(a[0], x[1], q);
rand.c:87:    ADDEQU(p[1], q[0], carry0);
rand.c:88:    MUL(a[1], x[0], r);
rand.c:89:    x[2] = LOW(carry0 + carry1 + CARRY(p[1], r[0]) + q[1] + r[1] +
rand.c:90:            a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
rand.c:91:    x[1] = LOW(p[1] + r[0]);
rand.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rax.c:3: * Copyright (c) 2017-2018, Salvatore Sanfilippo <antirez at gmail dot com>
rax.c:74:static int raxDebugMsg = 1;
rax.c:77: * default they are enabled. Set the state to 0 to disable, and 1 to
rax.c:99:/* Push an item into the stack, returns 1 on success, 0 on out of memory. */
rax.c:108:                ts->oom = 1;
rax.c:117:                ts->oom = 1;
rax.c:127:    return 1;
rax.c:144:    return ts->stack[ts->items-1];
rax.c:161:#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) & (sizeof(void*)-1))
rax.c:210://申请一个空的rax。头节点位一个空的node节点.numnodes=1
rax.c:215:    rax->numnodes = 1;
rax.c:229:    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
rax.c:236:    n->iskey = 1;
rax.c:243:        n->isnull = 1;
rax.c:286:    /* After the reallocation, we have up to 8/16 (depending on the system
rax.c:300:     * After the reallocation we need: 1 byte for the new edge character
rax.c:302:     * However after adding 1 byte to the edge char, the header + the edge
rax.c:304:     * In total the reallocation will add 1+4+3 bytes = 8 bytes:
rax.c:337:     * would be always "1", since we are adding a single byte in the string
rax.c:345:    //如果不考虑padding，一直是1.但是如果又padding有可能相差0-8
rax.c:387:    memmove(src+1,src,n->size-pos);
rax.c:441:    n->iscompr = 1;
rax.c:526: * data is updated (only if 'overwrite' is set to 1), and 0 is returned,
rax.c:527: * otherwise the element is inserted and 1 is returned. On out of memory the
rax.c:572:        return 1; /* Element inserted. */
rax.c:597:     * 1) Inserting "ANNIENTARE"
rax.c:609:     * 3) Inserting "AGO" (Like case 1, but set iscompr = 0 into original node)
rax.c:628:     * ============================= ALGO 1 =============================
rax.c:630:     * For the above cases 1 to 4, that is, all cases where we stopped in
rax.c:639:     * 1. Save the current compressed node $NEXT pointer (the pointer to the
rax.c:655:     *     to the split node. If new compressed node len is just 1, set
rax.c:661:     *     set iscompr to 0, otherwise iscompr to 1. Set the postfix node
rax.c:668:     * 6. Set the split node as the current node, set current index at child[1]
rax.c:681:     * 1. Save the current compressed node $NEXT pointer (the pointer to the
rax.c:686:     *    If the postfix node length is 1, set iscompr to 0.
rax.c:691:     *    As usually if the new node length is just 1, set iscompr to 0.
rax.c:696:     *    node created at step 1.
rax.c:703:     * ------------------------- ALGORITHM 1 --------------------------- */
rax.c:711:        debugf("ALGO 1: Stopped at compressed node %.*s (%p)\n",
rax.c:717:        /* 1: Save next pointer. */
rax.c:729:        size_t postfixlen = h->size - j - 1;
rax.c:735:        raxNode *splitnode = raxNewNode(1, split_node_is_key);
rax.c:776:            trimmed->iscompr = j > 1 ? 1 : 0;
rax.c:797:            postfix->iscompr = postfixlen > 1;
rax.c:798:            memcpy(postfix->data,h->data+j+1,postfixlen);
rax.c:839:        /* 1: Save next pointer. */
rax.c:846:        postfix->iscompr = postfixlen > 1;
rax.c:847:        postfix->iskey = 1;
rax.c:857:        trimmed->iscompr = j > 1;
rax.c:876:        return 1; /* Key inserted. */
rax.c:888:        if (h->size == 0 && len-i > 1) {
rax.c:918:    return 1; /* Element inserted. */
rax.c:927:        h->isnull = 1;
rax.c:928:        h->iskey = 1;
rax.c:939:    return raxGenericInsert(rax,s,len,data,old,1);
rax.c:971:    while(1) {
rax.c:1002:     * 1. To start we seek the first element in both the children
rax.c:1012:    while(1) {
rax.c:1023:    int taillen = parent->size - (e - parent->data) - 1;
rax.c:1025:    memmove(e,e+1,taillen);
rax.c:1033:    //获取shift，如果之前是补足了sizeof void* -1个字节。这时候直接移动sizeof(void *)个字节。但是如果是其他的，pendding不用动，因为第3步的时候已经相当于补足了。
rax.c:1034:    size_t shift = ((parent->size+4) % sizeof(void*)) == 1 ? sizeof(void*) : 0;
rax.c:1038:        memmove(((char*)cp)-shift,cp,(parent->size-taillen-1)*sizeof(raxNode**));
rax.c:1042:    memmove(((char*)c)-shift,c+1,taillen*sizeof(raxNode**)+valuelen);
rax.c:1045:    //size-1
rax.c:1059:/* Remove the specified item. Returns 1 if the item was found and
rax.c:1083:    int trycompress = 0; /* Will be set to 1 if we should try to optimize the
rax.c:1098:            if (h->iskey || (!h->iscompr && h->size != 1)) break;
rax.c:1117:            if (new->size == 1 && new->iskey == 0) {
rax.c:1118:                trycompress = 1;
rax.c:1122:    } else if (h->size == 1) {
rax.c:1125:        trycompress = 1;
rax.c:1138:     * 1) A node with a single child was a key and now no longer is a key.
rax.c:1148:     * Example of case "1". A tree stores the keys "FOO" = 1 and
rax.c:1153:     *           (1)
rax.c:1160:     * Example of case "2". A tree stores the keys "FOOBAR" = 1 and
rax.c:1163:     *          |B| -> "AR" -> [] (1)
rax.c:1169:     * "FOO" -> |B| -> "AR" -> [] (1)
rax.c:1173:     * "FOOBAR" -> [] (1)
rax.c:1184:        while(1) {
rax.c:1187:                (!parent->iscompr && parent->size != 1)) break;
rax.c:1195:        int nodes = 1;
rax.c:1199:            if (h->iskey || (!h->iscompr && h->size != 1)) break;
rax.c:1206:        if (nodes > 1) {
rax.c:1215:                return 1;
rax.c:1219:            new->iscompr = 1;
rax.c:1235:                if (h->iskey || (!h->iscompr && h->size != 1)) break;
rax.c:1257:    return 1;
rax.c:1265:    int numchildren = n->iscompr ? 1 : n->size;
rax.c:1311: * the user. Returns 0 on out of memory, otherwise 1 is returned. */
rax.c:1331:    return 1;
rax.c:1353: *上面的意思是如果noup是1的话，直接往下搜索，当前节点已经默认为是上一个带key的节点的父节点。所以往上找父节点的操作将会忽略。这个操作主要是raxSeek()函数直接使用> < 进行查找的时候，因为当前节点并非一个key节点。
rax.c:1354: * The function returns 1 on success or 0 on out of memory. */
rax.c:1359:        return 1;
rax.c:1362:        return 1;
rax.c:1371:    while(1) {
rax.c:1372:        int children = it->node->iscompr ? 1 : it->node->size;
rax.c:1382:                it->node->iscompr ? it->node->size : 1)) return 0;
rax.c:1393:                return 1;
rax.c:1402:            while(1) {
rax.c:1411:                    return 1;
rax.c:1415:                unsigned char prevchild = it->key[it->key_len-1];
rax.c:1424:                int todel = it->node->iscompr ? it->node->size : 1;
rax.c:1431:                //如果old_noup ==1 size至少是1 其他至少是2
rax.c:1432:                if (!it->node->iscompr && it->node->size > (old_noup ? 0 : 1)) {
rax.c:1444:                        raxIteratorAddChars(it,it->node->data+i,1);
rax.c:1453:                            return 1;
rax.c:1464: * out of memory, otherwise 1. This is an helper function for different
rax.c:1476:            if (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
rax.c:1483:    return 1;
rax.c:1492:        return 1;
rax.c:1495:        return 1;
rax.c:1504:    while(1) {
rax.c:1513:            return 1;
rax.c:1516:        unsigned char prevchild = it->key[it->key_len-1];
rax.c:1525:        int todel = it->node->iscompr ? it->node->size : 1;
rax.c:1530:        if (!it->node->iscompr && it->node->size > (old_noup ? 0 : 1)) {
rax.c:1532:            int i = it->node->size-1;
rax.c:1542:            if (i != -1) {
rax.c:1545:                if (!raxIteratorAddChars(it,it->node->data+i,1)) return 0;
rax.c:1559:            return 1;
rax.c:1566: * 1 is returned. When 0 is returned for out of memory, errno is set to
rax.c:1579:        gt = 1;
rax.c:1580:        if (op[1] == '=') eq = 1;
rax.c:1582:        lt = 1;
rax.c:1583:        if (op[1] == '=') eq = 1;
rax.c:1585:        eq = 1;
rax.c:1587:        first = 1;
rax.c:1589:        last = 1;
rax.c:1599:        return 1;
rax.c:1615:        return 1;
rax.c:1641:        for (size_t j = 1; j < it->stack.items; j++) {
rax.c:1642:            raxNode *parent = it->stack.stack[j-1];
rax.c:1650:                while(1) {
rax.c:1657:                if (!raxIteratorAddChars(it,p,1)) return 0;
rax.c:1672:            if (!raxIteratorAddChars(it,ele+i,1)) return 0;
rax.c:1677:            if (lt && !raxIteratorPrevStep(it,1)) return 0;
rax.c:1678:            if (gt && !raxIteratorNextStep(it,1)) return 0;
rax.c:1696:                    if (!raxIteratorNextStep(it,1)) return 0;
rax.c:1710:                    if (!raxIteratorPrevStep(it,1)) return 0;
rax.c:1729:                 * "f" -> "oobar" = 1 -> "" = 2
rax.c:1731:                 * Representing keys "f" = 1, "foobar" = 2. A seek for
rax.c:1745:        return 1;
rax.c:1747:    return 1;
rax.c:1751: * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
rax.c:1762:    return 1;
rax.c:1766: * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
rax.c:1777:    return 1;
rax.c:1781: * Return 0 if the tree is empty or on out of memory. Otherwise 1 is returned
rax.c:1784: * using a random number of steps between 1 and two times the logarithm of
rax.c:1801:        steps = 1 + rand() % fle;
rax.c:1806:        int numchildren = n->iscompr ? 1 : n->size;
rax.c:1812:            int todel = n->iscompr ? n->size : 1;
rax.c:1819:                if (!raxIteratorAddChars(it,n->data+r,1)) return 0;
rax.c:1828:    return 1;
rax.c:1832: * key according to the specified operator. Returns 1 if the comparison is
rax.c:1837:    if (op[0] == '=' || op[1] == '=') eq = 1;
rax.c:1838:    if (op[0] == '>') gt = 1;
rax.c:1839:    else if (op[0] == '<') lt = 1;
rax.c:1840:    else if (op[1] != '=') return 0; /* Syntax error. */
rax.c:1851:        if (eq && key_len == iter->key_len) return 1;
rax.c:1855:        return gt ? 1 : 0;
rax.c:1857:        return lt ? 1 : 0;
rax.c:1890: *  [abc]=0x12345678 (node is a key, pointing to value 0x12345678)
rax.c:1917:    int numchildren = n->iscompr ? 1 : n->size;
rax.c:1921:        lpad += (numchildren > 1) ? 7 : 4;
rax.c:1922:        if (numchildren == 1) lpad += numchars;
rax.c:1927:        if (numchildren > 1) {
rax.c:1936:        raxRecursiveShow(level+1,lpad,child);
rax.c:1952:    int numcld = n->iscompr ? 1 : n->size;
rax.c:1953:    raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);
rax.c:1971: * 1. The rax-test is executed using Valgrind, adding a printf() so that for
rax.c:1988:    int numchildren = n->iscompr ? 1 : n->size;
rax.c:1992:        if (numchildren > 1) {
rax.c:1997:        if (child == (void*)0x65d1760) count++;
rax.c:1998:        if (count > 1) exit(1);
rax.h:3: * Copyright (c) 2017-2018, Salvatore Sanfilippo <antirez at gmail dot com>
rax.h:97:#define RAX_NODE_MAX_SIZE ((1<<29)-1)
rax.h:99:    uint32_t iskey:1;     /* Does this node contain a key? */
rax.h:100:    uint32_t isnull:1;    /* Associated value is NULL (don't store it). */
rax.h:101:    uint32_t iscompr:1;   /* Node is compressed. */
rax.h:112:     * if node is compressed (iscompr bit is 1) the node has 1 children.
rax.h:119:     * [header iscompr=1][xyz][z-ptr](value-ptr?)
rax.h:125:     * If the node has an associated key (iskey=1) and is not NULL
rax.h:168:#define RAX_ITER_STATIC_LEN 128
rax.h:169:#define RAX_ITER_JUST_SEEKED (1<<0) /* Iterator was just seeked. Return current
rax.h:172:#define RAX_ITER_EOF (1<<1)    /* End of iteration reached. */
rax.h:173:#define RAX_ITER_SAFE (1<<2)   /* Safe iterator, allows operations while
rax_malloc.h:3: * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
rax-test.c:11:    ust = ((long long)tv.tv_sec)*1000000;
rax-test.c:17:    return ustime()/1000;
rdb.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rdb.c:53:    char msg[1024];
rdb.c:69:    exit(1);
rdb.c:75:        return -1;
rdb.c:92:    return rdbWriteRaw(rdb,&type,1);
rdb.c:100:    if (rioRead(rdb,&type,1) == 0) return -1;
rdb.c:141://保存整数的长度，1 ，2 ，5，9
rdb.c:147:    if (len < (1<<6)) {
rdb.c:151:        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
rdb.c:152:        nwritten = 1;
rdb.c:153:    } else if (len < (1<<14)) {
rdb.c:154:        /* Save a 14 bit len */
rdb.c:155:        /*01|XXXXXX XXXXXXXX*/
rdb.c:156:        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
rdb.c:157:        buf[1] = len&0xFF;
rdb.c:158:        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
rdb.c:164:        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
rdb.c:166:        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
rdb.c:167:        nwritten = 1+4;
rdb.c:170:        //0x81 [64 bit integer]
rdb.c:172:        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
rdb.c:174:        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
rdb.c:175:        nwritten = 1+8;
rdb.c:184: * is set to 1 and the encoding format is stored at '*lenptr'.
rdb.c:189: * The function returns -1 on error, 0 on success. */
rdb.c:195:    if (rioRead(rdb,buf,1) == 0) return -1;//获得buf[0]
rdb.c:200:        if (isencoded) *isencoded = 1;
rdb.c:205:    } else if (type == RDB_14BITLEN) {
rdb.c:206:        /* Read a 14 bit len. */
rdb.c:207:        if (rioRead(rdb,buf+1,1) == 0) return -1;//获得buf[1]
rdb.c:208:        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
rdb.c:212:        if (rioRead(rdb,&len,4) == 0) return -1;
rdb.c:217:        if (rioRead(rdb,&len,8) == 0) return -1;
rdb.c:222:        return -1; /* Never reached. */
rdb.c:235:    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
rdb.c:239://11|OBKIND 【0,1,2,3】
rdb.c:241://1 16 bit signed integer
rdb.c:250:    if (value >= -(1<<7) && value <= (1<<7)-1) {
rdb.c:252:        enc[1] = value&0xFF;
rdb.c:254:    } else if (value >= -(1<<15) && value <= (1<<15)-1) {
rdb.c:255:        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
rdb.c:256:        enc[1] = value&0xFF;
rdb.c:259:    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {
rdb.c:261:        enc[1] = value&0xFF;
rdb.c:263:        enc[3] = (value>>16)&0xFF;
rdb.c:274://加载有符号的整型。enctype 0 1 2 .整型存储结构0x 12 34 56 78 
rdb.c:275://0x78 0x56 0x34 0x12
rdb.c:276://存储格式11|0 1 2 3 
rdb.c:285:        if (rioRead(rdb,enc,1) == 0) return NULL;
rdb.c:287:    } else if (enctype == RDB_ENC_INT16) {
rdb.c:288:        uint16_t v;
rdb.c:290:        v = enc[0]|(enc[1]<<8);
rdb.c:291:        val = (int16_t)v;
rdb.c:295:        v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
rdb.c:315:/* String objects in the form "2391" "-100" without any space and with a
rdb.c:316: * range of values that can fit in an 8, 16 or 32 bit signed value can be
rdb.c:324:    value = strtoll(s, &endptr, 10);
rdb.c:335://格式:11000011 compress_len [6 ,14, 32 ,64] *2(original_len) raw
rdb.c:337://长度6 bit :11000011 00XXXXXX 00XXXXXX raw
rdb.c:338://长度32 bit: 11000011 10000000 [32 bit] 10000000[32 bit] raw
rdb.c:346:    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
rdb.c:348:    //rdbSaveLen 保存长度编码6字节14字节8字节32字节64字节，同时保存长度
rdb.c:349:    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
rdb.c:352:    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
rdb.c:355:    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
rdb.c:361:    return -1;
rdb.c:371:    if ((out = zmalloc(outlen+1)) == NULL) return 0;
rdb.c:433:    if (len <= 11) {
rdb.c:436:            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
rdb.c:445:        if (n == -1) return -1;
rdb.c:451:    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
rdb.c:454:        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
rdb.c:471:        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
rdb.c:473:        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
rdb.c:516:        case RDB_ENC_INT16:
rdb.c:566:    unsigned char buf[128];
rdb.c:571:        len = 1;
rdb.c:574:        len = 1;
rdb.c:587:        double min = -4503599627370495; /* (2^52)-1 */
rdb.c:590:            ll2string((char*)buf+1,sizeof(buf)-1,(long long)val);
rdb.c:593:            snprintf((char*)buf+1,sizeof(buf)-1,"%.17g",val);
rdb.c:594:        buf[0] = strlen((char*)buf+1);
rdb.c:595:        len = buf[0]+1;
rdb.c:605:    if (rioRead(rdb,&len,1) == 0) return -1;
rdb.c:611:        if (rioRead(rdb,buf,len) == 0) return -1;
rdb.c:622: * Return -1 on error, the size of the serialized value on success. */
rdb.c:629: * more info. On error -1 is returned, otherwise 0. */
rdb.c:631:    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
rdb.c:644:    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
rdb.c:687:    return -1; /* avoid warning */
rdb.c:690:/* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the
rdb.c:694:    if ((type = rdbLoadType(rdb)) == -1) return -1;
rdb.c:695:    if (!rdbIsObjectType(type)) return -1;
rdb.c:706://保存pel信息。key是128位的stream_id.value是streanNack.
rdb.c:712:    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
rdb.c:720:        /* We store IDs in raw form as 128 big big endian numbers, like
rdb.c:722:        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
rdb.c:727:            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
rdb.c:728:                return -1;
rdb.c:730:            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
rdb.c:745://1.消费者组里面的消费者数量
rdb.c:751:    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
rdb.c:762:        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
rdb.c:766:        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
rdb.c:767:            return -1;
rdb.c:774:        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
rdb.c:775:            return -1;
rdb.c:783: * Returns -1 on error, number of bytes written on success. */
rdb.c:791:        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
rdb.c:799:            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
rdb.c:807:                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
rdb.c:810:                    if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;
rdb.c:826:            if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {
rdb.c:828:                return -1;
rdb.c:835:                    == -1)
rdb.c:838:                    return -1;
rdb.c:847:            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
rdb.c:859:            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
rdb.c:865:            if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;
rdb.c:873:             * O(1) instead of O(log(N)). */
rdb.c:877:                    (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)
rdb.c:879:                    return -1;
rdb.c:882:                if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
rdb.c:883:                    return -1;
rdb.c:895:            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
rdb.c:902:            if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {
rdb.c:904:                return -1;
rdb.c:913:                        sdslen(field))) == -1)
rdb.c:916:                    return -1;
rdb.c:920:                        sdslen(value))) == -1)
rdb.c:923:                    return -1;
rdb.c:935:        if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;
rdb.c:947:            if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
rdb.c:949:            if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) return -1;
rdb.c:957:        if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;
rdb.c:960:        if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;
rdb.c:962:        if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;
rdb.c:970:        if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;
rdb.c:981:                if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1)
rdb.c:982:                    return -1;
rdb.c:986:                if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) return -1;
rdb.c:988:                if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) return -1;
rdb.c:992:                if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) return -1;
rdb.c:996:                if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) return -1;
rdb.c:1011:        if (retval == -1) return -1;
rdb.c:1017:        if (retval == -1) return -1;
rdb.c:1024:        return io.error ? -1 : (ssize_t)io.bytes;
rdb.c:1037:    serverAssertWithInfo(NULL,o,len != -1);
rdb.c:1042: * On error -1 is returned.
rdb.c:1043: * On success if the key was actually saved 1 is returned, otherwise 0
rdb.c:1050:    if (expiretime != -1) {
rdb.c:1051:        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
rdb.c:1052:        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
rdb.c:1058:        idletime /= 1000; /* Using seconds is enough and requires less space.*/
rdb.c:1059:        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
rdb.c:1060:        if (rdbSaveLen(rdb,idletime) == -1) return -1;
rdb.c:1065:        uint8_t buf[1];
rdb.c:1071:        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
rdb.c:1072:        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
rdb.c:1076:    if (rdbSaveObjectType(rdb,val) == -1) return -1;
rdb.c:1077:    if (rdbSaveStringObject(rdb,key) == -1) return -1;
rdb.c:1078:    if (rdbSaveObject(rdb,val,key) == -1) return -1;
rdb.c:1079:    return 1;
rdb.c:1085:    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
rdb.c:1087:    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
rdb.c:1089:    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
rdb.c:1113:    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
rdb.c:1114:    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
rdb.c:1115:    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
rdb.c:1116:    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
rdb.c:1121:            == -1) return -1;
rdb.c:1123:            == -1) return -1;
rdb.c:1125:            == -1) return -1;
rdb.c:1127:    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
rdb.c:1128:    return 1;
rdb.c:1142:    char magic[10];
rdb.c:1150:    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
rdb.c:1151:    if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
rdb.c:1160:        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
rdb.c:1161:        if (rdbSaveLen(rdb,j) == -1) goto werr;
rdb.c:1170:        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
rdb.c:1171:        if (rdbSaveLen(rdb,db_size) == -1) goto werr;
rdb.c:1172:        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;
rdb.c:1182:            if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;
rdb.c:1206:            if (rdbSaveAuxField(rdb,"lua",3,body->ptr,sdslen(body->ptr)) == -1)
rdb.c:1214:    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
rdb.c:1288:    if (fsync(fileno(fp)) == -1) goto werr;
rdb.c:1293:    if (rename(tmpfile,filename) == -1) {
rdb.c:1323:    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
rdb.c:1338:            size_t private_dirty = zmalloc_get_private_dirty(-1);
rdb.c:1343:                    private_dirty/(1024*1024));
rdb.c:1349:        exitFromChild((retval == C_OK) ? 0 : 1);
rdb.c:1353:        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
rdb.c:1354:        latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
rdb.c:1355:        if (childpid == -1) {
rdb.c:1390:            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
rdb.c:1403:            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
rdb.c:1409:            if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {
rdb.c:1415:    return createStringObject("module-dummy-value",18);
rdb.c:1510:                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) return NULL;
rdb.c:1512:                if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
rdb.c:1765:                                           1);
rdb.c:1794:        char name[10];
rdb.c:1804:            exit(1);
rdb.c:1808:        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;
rdb.c:1809:        /* Call the rdb_load method of the module providing the 10 bit
rdb.c:1810:         * encoding version in the lower 10 bits of the module ID. */
rdb.c:1811:        void *ptr = mt->rdb_load(&io,moduleid&1023);
rdb.c:1822:                exit(1);
rdb.c:1829:            exit(1);
rdb.c:1844:    server.loading = 1;
rdb.c:1847:    if (fstat(fileno(fp), &sb) == -1) {
rdb.c:1891:    char buf[1024];
rdb.c:1903:    if (rdbver < 1 || rdbver > RDB_VERSION) {
rdb.c:1910:    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
rdb.c:1913:    while(1) {
rdb.c:1917:        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
rdb.c:1925:            expiretime *= 1000;
rdb.c:1935:            if (rioRead(rdb,&byte,1) == 0) goto eoferr;
rdb.c:1955:                exit(1);
rdb.c:1991:                    memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
rdb.c:1992:                    rsi->repl_id_is_set = 1;
rdb.c:1995:                if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
rdb.c:2024:            char name[10];
rdb.c:2030:                exit(1);
rdb.c:2035:                exit(1);
rdb.c:2052:        if (server.masterhost == NULL && !loading_aof && expiretime != -1 && expiretime < now) {
rdb.c:2060:            if (expiretime != -1) setExpire(NULL,db,key,expiretime);
rdb.c:2072:        expiretime = -1;
rdb.c:2073:        lfu_freq = -1;
rdb.c:2074:        lru_idle = -1;
rdb.c:2141:        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
rdb.c:2143:        if (bysignal != SIGUSR1)
rdb.c:2146:    server.rdb_child_pid = -1;
rdb.c:2149:    server.rdb_save_time_start = -1;
rdb.c:2170:    server.rdb_child_pid = -1;
rdb.c:2172:    server.rdb_save_time_start = -1;
rdb.c:2195:                read(server.rdb_pipe_read_result_from_child, ok_slaves+1,
rdb.c:2223:                if (slave->id == ok_slaves[2*j+1]) {
rdb.c:2277:    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
rdb.c:2282:    if (pipe(pipefds) == -1) return C_ERR;
rdb.c:2284:    server.rdb_pipe_write_result_to_parent = pipefds[1];
rdb.c:2307:            anetSendTimeout(NULL,slave->fd,server.repl_timeout*1000);
rdb.c:2330:            size_t private_dirty = zmalloc_get_private_dirty(-1);
rdb.c:2335:                    private_dirty/(1024*1024));
rdb.c:2356:            void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
rdb.c:2358:            uint64_t *ids = len+1;
rdb.c:2371:            msglen = sizeof(uint64_t)*(1+2*numfds);
rdb.c:2382:        exitFromChild((retval == C_OK) ? 0 : 1);
rdb.c:2385:        if (childpid == -1) {
rdb.c:2405:            close(pipefds[1]);
rdb.c:2409:            server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
rdb.c:2410:            latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
rdb.c:2421:        return (childpid == -1) ? C_ERR : C_OK;
rdb.c:2427:    if (server.rdb_child_pid != -1) {
rdb.c:2446:    if (c->argc > 1) {
rdb.c:2447:        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"schedule")) {
rdb.c:2448:            schedule = 1;
rdb.c:2458:    if (server.rdb_child_pid != -1) {
rdb.c:2460:    } else if (server.aof_child_pid != -1) {
rdb.c:2462:            server.rdb_bgsave_scheduled = 1;
rdb.c:2498:        /* Note that when server.slaveseldb is -1, it means that this master
rdb.c:2503:        rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
rdb.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rdb.h:48: * 01|XXXXXX XXXXXXXX =>  01, the len is 14 byes, 6 bits + 8 bits of next byte
rdb.h:49: * 10|000000 [32 bit integer] => A full 32 bit len in net byte order will follow
rdb.h:50: * 10|000001 [64 bit integer] => A full 64 bit len in net byte order will follow
rdb.h:51: * 11|OBKIND this means: specially encoded object will follow. The six bits
rdb.h:58:#define RDB_14BITLEN 1
rdb.h:60:#define RDB_64BITLEN 0x81
rdb.h:68:#define RDB_ENC_INT16 1       /* 16 bit signed integer */
rdb.h:76:#define RDB_TYPE_LIST   1
rdb.h:88:#define RDB_TYPE_LIST_ZIPLIST  10
rdb.h:89:#define RDB_TYPE_SET_INTSET    11
rdb.h:90:#define RDB_TYPE_ZSET_ZIPLIST  12
rdb.h:91:#define RDB_TYPE_HASH_ZIPLIST  13
rdb.h:92:#define RDB_TYPE_LIST_QUICKLIST 14
rdb.h:93:#define RDB_TYPE_STREAM_LISTPACKS 15
rdb.h:97:#define rdbIsObjectType(t) ((t >= 0 && t <= 7) || (t >= 9 && t <= 15))
rdb.h:104:#define RDB_OPCODE_RESIZEDB   251   /* Hash table resize hint. */
rdb.h:112:#define RDB_MODULE_OPCODE_SINT  1   /* Signed integer. */
rdb.h:120:#define RDB_LOAD_ENC    (1<<0)
rdb.h:121:#define RDB_LOAD_PLAIN  (1<<1)
rdb.h:122:#define RDB_LOAD_SDS    (1<<2)
rdb.h:125:#define RDB_SAVE_AOF_PREAMBLE (1<<0)
redisassert.h:10: * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
redisassert.h:43:#define assert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
redisassert.h:44:#define panic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)
匹配到二进制文件 redisassert.h.gch
redis-benchmark.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
redis-benchmark.c:110:    ust = ((long)tv.tv_sec)*1000000;
redis-benchmark.c:120:    mst = ((long long)tv.tv_sec)*1000;
redis-benchmark.c:121:    mst += tv.tv_usec/1000;
redis-benchmark.c:161:        char *p = c->randptr[i]+11;
redis-benchmark.c:165:        for (j = 0; j < 12; j++) {
redis-benchmark.c:166:            *p = '0'+r%10;
redis-benchmark.c:167:            r/=10;
redis-benchmark.c:203:        exit(1);
redis-benchmark.c:208:                exit(1);
redis-benchmark.c:213:                    exit(1);
redis-benchmark.c:234:                        sdsrange(c->obuf, c->prefixlen, -1);
redis-benchmark.c:275:        c->latency = -1;
redis-benchmark.c:281:        if (nwritten == -1) {
redis-benchmark.c:311: * 1) The command line to use.
redis-benchmark.c:331:        exit(1);
redis-benchmark.c:402:                p += 12; /* 12 is strlen("__rand_int__). */
redis-benchmark.c:435:    reqpersec = (float)config.requests_finished/((float)config.totlatency/1000);
redis-benchmark.c:439:            (float)config.totlatency/1000);
redis-benchmark.c:447:            if (config.latency[i]/1000 != curlat || i == (config.requests-1)) {
redis-benchmark.c:448:                curlat = config.latency[i]/1000;
redis-benchmark.c:449:                perc = ((float)(i+1)*100)/config.requests;
redis-benchmark.c:483:    int exit_status = 1;
redis-benchmark.c:485:    for (i = 1; i < argc; i++) {
redis-benchmark.c:486:        lastarg = (i == (argc-1));
redis-benchmark.c:512:            if (config.datasize < 1) config.datasize=1;
redis-benchmark.c:513:            if (config.datasize > 1024*1024*1024) config.datasize = 1024*1024*1024;
redis-benchmark.c:517:            if (config.pipeline <= 0) config.pipeline=1;
redis-benchmark.c:520:            config.randomkeys = 1;
redis-benchmark.c:525:            config.quiet = 1;
redis-benchmark.c:527:            config.csv = 1;
redis-benchmark.c:529:            config.loop = 1;
redis-benchmark.c:531:            config.idlemode = 1;
redis-benchmark.c:533:            config.showerrors = 1;
redis-benchmark.c:569:" -h <hostname>      Server hostname (default 127.0.0.1)\n"
redis-benchmark.c:574:" -n <requests>      Total number of requests (default 100000)\n"
redis-benchmark.c:577:" -k <boolean>       1=keep alive 0=reconnect (default 1)\n"
redis-benchmark.c:580:"  inside an argument with a 12 digits number in the specified range\n"
redis-benchmark.c:581:"  from 0 to keyspacelen-1. The substitution changes every time a command\n"
redis-benchmark.c:584:" -P <numreq>        Pipeline <numreq> requests. Default 1 (no pipeline).\n"
redis-benchmark.c:586:"                    (no more than 1 error per second is displayed)\n"
redis-benchmark.c:594:" Run the benchmark with the default configuration against 127.0.0.1:6379:\n"
redis-benchmark.c:596:" Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:\n"
redis-benchmark.c:597:"   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20\n\n"
redis-benchmark.c:598:" Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:\n"
redis-benchmark.c:599:"   $ redis-benchmark -t set -n 1000000 -r 100000000\n\n"
redis-benchmark.c:600:" Benchmark 127.0.0.1:6379 for a few commands producing CSV output:\n"
redis-benchmark.c:601:"   $ redis-benchmark -t ping,set,get -n 100000 --csv\n\n"
redis-benchmark.c:603:"   $ redis-benchmark -r 10000 -n 10000 eval 'return redis.call(\"ping\")' 0\n\n"
redis-benchmark.c:604:" Fill a list with 10000 random elements:\n"
redis-benchmark.c:605:"   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__\n\n"
redis-benchmark.c:619:        exit(1);
redis-benchmark.c:622:    if (config.idlemode == 1) {
redis-benchmark.c:627:    float dt = (float)(mstime()-config.start)/1000.0;
redis-benchmark.c:640:    if (config.tests == NULL) return 1;
redis-benchmark.c:642:    memcpy(buf+1,name,l);
redis-benchmark.c:643:    buf[l+1] = ',';
redis-benchmark.c:660:    config.requests = 100000;
redis-benchmark.c:662:    config.el = aeCreateEventLoop(1024*10);
redis-benchmark.c:663:    aeCreateTimeEvent(config.el,1,showThroughput,NULL,NULL);
redis-benchmark.c:664:    config.keepalive = 1;
redis-benchmark.c:666:    config.pipeline = 1;
redis-benchmark.c:676:    config.hostip = "127.0.0.1";
redis-benchmark.c:690:        printf("WARNING: keepalive disabled, you probably need 'echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse' for Linux and 'sudo sysctl -w net.inet.tcp.msl=1000' for Mac OS X in order to use a lot of clients/requests\n");
redis-benchmark.c:704:        for (i = 1; i < argc; i++) {
redis-benchmark.c:705:            title = sdscatlen(title, " ", 1);
redis-benchmark.c:719:    data = zmalloc(config.datasize+1);
redis-benchmark.c:796:            test_is_selected("lrange_100") ||
redis-benchmark.c:806:        if (test_is_selected("lrange") || test_is_selected("lrange_100")) {
redis-benchmark.c:808:            benchmark("LRANGE_100 (first 100 elements)",cmd,len);
redis-benchmark.c:831:            const char *argv[21];
redis-benchmark.c:833:            for (i = 1; i < 21; i += 2) {
redis-benchmark.c:835:                argv[i+1] = data;
redis-benchmark.c:837:            len = redisFormatCommandArgv(&cmd,21,argv,NULL);
redis-benchmark.c:838:            benchmark("MSET (10 keys)",cmd,len);
redis-check-aof.c:2: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
redis-check-aof.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
redis-check-aof.c:35:    char __buf[1024]; \
redis-check-aof.c:37:    snprintf(error, sizeof(error), "0x%16llx: %s", (long long)epos, __buf); \
redis-check-aof.c:40:static char error[1044];
redis-check-aof.c:45:        ERROR("Expected \\r\\n, got: %02x%02x",buf[0],buf[1]);
redis-check-aof.c:48:    return 1;
redis-check-aof.c:52:    char buf[128], *eptr;
redis-check-aof.c:61:    *target = strtol(buf+1,&eptr,10);
redis-check-aof.c:68:    real = fread(target,1,length,fp);
redis-check-aof.c:73:    return 1;
redis-check-aof.c:93:    return 1;
redis-check-aof.c:106:    while(1) {
redis-check-aof.c:150:        exit(1);
redis-check-aof.c:152:        filename = argv[1];
redis-check-aof.c:154:        if (strcmp(argv[1],"--fix") != 0) {
redis-check-aof.c:155:            printf("Invalid argument: %s\n", argv[1]);
redis-check-aof.c:156:            exit(1);
redis-check-aof.c:159:        fix = 1;
redis-check-aof.c:162:        exit(1);
redis-check-aof.c:168:        exit(1);
redis-check-aof.c:172:    if (redis_fstat(fileno(fp),&sb) == -1) {
redis-check-aof.c:174:        exit(1);
redis-check-aof.c:180:        exit(1);
redis-check-aof.c:187:        int has_preamble = fread(sig,sizeof(sig),1,fp) == 1 &&
redis-check-aof.c:195:                exit(1);
redis-check-aof.c:212:                strncasecmp(buf,"y",1) != 0) {
redis-check-aof.c:214:                    exit(1);
redis-check-aof.c:216:            if (ftruncate(fileno(fp), pos) == -1) {
redis-check-aof.c:218:                exit(1);
redis-check-aof.c:225:            exit(1);
redis-check-rdb.c:2: * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
redis-check-rdb.c:42:    int key_type;                   /* Current key type if != -1. */
redis-check-rdb.c:48:    char error[1024];
redis-check-rdb.c:54:#define RDB_CHECK_DOING_READ_TYPE 1
redis-check-rdb.c:77:    "zset-v1",
redis-check-rdb.c:101:    char msg[1024];
redis-check-rdb.c:117:    if (rdbstate.key_type != -1)
redis-check-rdb.c:128:    char msg[1024];
redis-check-rdb.c:148:    rdbstate.error_set = 1;
redis-check-rdb.c:160:    exit(1);
redis-check-rdb.c:176: * 1 is returned.
redis-check-rdb.c:182:    char buf[1024];
redis-check-rdb.c:187:    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) return 1;
redis-check-rdb.c:199:    if (rdbver < 1 || rdbver > RDB_VERSION) {
redis-check-rdb.c:204:    expiretime = -1;
redis-check-rdb.c:206:    while(1) {
redis-check-rdb.c:211:        if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
redis-check-rdb.c:219:            if ((expiretime = rdbLoadTime(&rdb)) == -1) goto eoferr;
redis-check-rdb.c:220:            expiretime *= 1000;
redis-check-rdb.c:226:            if ((expiretime = rdbLoadMillisecondTime(&rdb, rdbver)) == -1) goto eoferr;
redis-check-rdb.c:231:            if (rioRead(&rdb,&byte,1) == 0) goto eoferr;
redis-check-rdb.c:290:        if (expiretime != -1 && expiretime < now)
redis-check-rdb.c:292:        if (expiretime != -1) rdbstate.expires++;
redis-check-rdb.c:296:        rdbstate.key_type = -1;
redis-check-rdb.c:297:        expiretime = -1;
redis-check-rdb.c:327:    return 1;
redis-check-rdb.c:345:        exit(1);
redis-check-rdb.c:353:    rdbCheckMode = 1;
redis-check-rdb.c:354:    rdbCheckInfo("Checking RDB file %s", argv[1]);
redis-check-rdb.c:356:    int retval = redis_check_rdb(argv[1],fp);
redis-cli.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
redis-cli.c:62:#define OUTPUT_RAW 1
redis-cli.c:64:#define REDIS_CLI_KEEPALIVE_INTERVAL 15 /* seconds */
redis-cli.c:73:#define CLUSTER_MANAGER_SLOTS               16384
redis-cli.c:75:#define CLUSTER_MANAGER_MIGRATE_PIPELINE    10
redis-cli.c:80:    "address (ie. 120.0.0.1:7000) or space separated IP " \
redis-cli.c:81:    "and port (ie. 120.0.0.1 7000)\n"
redis-cli.c:83:#define CLUSTER_MANAGER_MASTERS_COUNT(nodes, replicas) (nodes/(replicas + 1))
redis-cli.c:105:#define CLUSTER_MANAGER_FLAG_MYSELF     1 << 0
redis-cli.c:106:#define CLUSTER_MANAGER_FLAG_SLAVE      1 << 1
redis-cli.c:107:#define CLUSTER_MANAGER_FLAG_FRIEND     1 << 2
redis-cli.c:108:#define CLUSTER_MANAGER_FLAG_NOADDR     1 << 3
redis-cli.c:109:#define CLUSTER_MANAGER_FLAG_DISCONNECT 1 << 4
redis-cli.c:110:#define CLUSTER_MANAGER_FLAG_FAIL       1 << 5
redis-cli.c:112:#define CLUSTER_MANAGER_CMD_FLAG_FIX            1 << 0
redis-cli.c:113:#define CLUSTER_MANAGER_CMD_FLAG_SLAVE          1 << 1
redis-cli.c:114:#define CLUSTER_MANAGER_CMD_FLAG_YES            1 << 2
redis-cli.c:115:#define CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS    1 << 3
redis-cli.c:116:#define CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER    1 << 4
redis-cli.c:117:#define CLUSTER_MANAGER_CMD_FLAG_SIMULATE       1 << 5
redis-cli.c:118:#define CLUSTER_MANAGER_CMD_FLAG_REPLACE        1 << 6
redis-cli.c:119:#define CLUSTER_MANAGER_CMD_FLAG_COPY           1 << 7
redis-cli.c:120:#define CLUSTER_MANAGER_CMD_FLAG_COLOR          1 << 8
redis-cli.c:121:#define CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS   1 << 9
redis-cli.c:123:#define CLUSTER_MANAGER_OPT_GETFRIENDS  1 << 0
redis-cli.c:124:#define CLUSTER_MANAGER_OPT_COLD        1 << 1
redis-cli.c:125:#define CLUSTER_MANAGER_OPT_UPDATE      1 << 2
redis-cli.c:126:#define CLUSTER_MANAGER_OPT_QUIET       1 << 6
redis-cli.c:127:#define CLUSTER_MANAGER_OPT_VERBOSE     1 << 7
redis-cli.c:129:#define CLUSTER_MANAGER_LOG_LVL_INFO    1
redis-cli.c:134:#define LOG_COLOR_BOLD      "29;1m"
redis-cli.c:135:#define LOG_COLOR_RED       "31;1m"
redis-cli.c:136:#define LOG_COLOR_GREEN     "32;1m"
redis-cli.c:137:#define LOG_COLOR_YELLOW    "33;1m"
redis-cli.c:141:#define CC_FORCE (1<<0)         /* Re-connect if already connected. */
redis-cli.c:142:#define CC_QUIET (1<<1)         /* Don't log connecting errors. */
redis-cli.c:145:int spectrum_palette_color_size = 19;
redis-cli.c:146:int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
redis-cli.c:148:int spectrum_palette_mono_size = 13;
redis-cli.c:149:int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};
redis-cli.c:158:static int dictSdsKeyCompare(void *privdata, const void *key1,
redis-cli.c:221:    char prompt[128];
redis-cli.c:241:char *redisGitSHA1(void);
redis-cli.c:252:uint16_t crc16(const char *buf, int len);
redis-cli.c:259:    ust = ((long long)tv.tv_sec)*1000000;
redis-cli.c:265:    return ustime()/1000;
redis-cli.c:323:#define decodeHexChar(c) (isdigit(c) ? c - '0' : c - 'a' + 10)
redis-cli.c:335:                exit(1);
redis-cli.c:342:                exit(1);
redis-cli.c:345:            ret = sdscatlen(ret, &c, 1);
redis-cli.c:348:            ret = sdscatlen(ret, curr++, 1);
redis-cli.c:356: * URI scheme is based on the the provisional specification[1] excluding support
redis-cli.c:362: *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */
redis-cli.c:373:        exit(1);
redis-cli.c:382:            curr = username + 1;
redis-cli.c:386:        curr = userinfo + 1;
redis-cli.c:393:        host = path ? path - 1 : end;
redis-cli.c:395:            config.hostport = atoi(port + 1);
redis-cli.c:396:            host = port - 1;
redis-cli.c:398:        config.hostip = sdsnewlen(curr, host - curr + 1);
redis-cli.c:400:    curr = path ? path + 1 : end;
redis-cli.c:411:static int dictSdsKeyCompare(void *privdata, const void *key1,
redis-cli.c:414:    int l1,l2;
redis-cli.c:417:    l1 = sdslen((sds)key1);
redis-cli.c:419:    if (l1 != l2) return 0;
redis-cli.c:420:    return memcmp(key1, key2, l1) == 0;
redis-cli.c:439:    *((char*)-1) = 'x';
redis-cli.c:446:#define CLI_HELP_COMMAND 1
redis-cli.c:467:    if (strtoll(redisGitSHA1(),NULL,16)) {
redis-cli.c:468:        version = sdscatprintf(version, " (git:%s", redisGitSHA1());
redis-cli.c:469:        if (strtoll(redisGitDirty(),NULL,10))
redis-cli.c:486:        tmp.argc = 1;
redis-cli.c:521:            entry->element[1]->type != REDIS_REPLY_INTEGER ||
redis-cli.c:535:        helpEntry *new = helpEntries+(helpEntriesLen-1);
redis-cli.c:537:        new->argc = 1;
redis-cli.c:547:        int args = llabs(entry->element[1]->integer);
redis-cli.c:549:        if (entry->element[3]->integer == 1) {
redis-cli.c:554:        if (entry->element[1]->integer < 0)
redis-cli.c:566:    printf("\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n", help->name, help->params);
redis-cli.c:567:    printf("  \x1b[33msummary:\x1b[0m %s\r\n", help->summary);
redis-cli.c:568:    printf("  \x1b[33msince:\x1b[0m %s\r\n", help->since);
redis-cli.c:570:        printf("  \x1b[33mgroup:\x1b[0m %s\r\n", commandGroups[help->group]);
redis-cli.c:597:    int group = -1;
redis-cli.c:607:            if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {
redis-cli.c:620:        if (group == -1) {
redis-cli.c:627:                    cliOutputCommandHelp(help,1);
redis-cli.c:674:    int endspace = buflen && isspace(buf[buflen-1]);
redis-cli.c:693:            int toremove = argc-1;
redis-cli.c:697:                sdsrange(hint,1,-1);
redis-cli.c:702:                sds newhint = sdsnewlen(" ",1);
redis-cli.c:830:            char _prefixlen[16];
redis-cli.c:831:            char _prefixfmt[16];
redis-cli.c:839:                i /= 10;
redis-cli.c:853:                out = sdscatprintf(out,_prefixfmt,i == 0 ? "" : prefix,i+1);
redis-cli.c:865:        exit(1);
redis-cli.c:882:    if (strstr(color,"red")) ccode = 31;
redis-cli.c:908:        if (s[1] == '>') color = "yellow"; /* Current line. */
redis-cli.c:924:        out = sdscatlen(out,"\n",1);
redis-cli.c:937:                config.eval_ldb_end = 1; /* Signal the caller session ended. */
redis-cli.c:960:        exit(1);
redis-cli.c:990:            if (i != r->elements-1) out = sdscat(out,",");
redis-cli.c:996:        exit(1);
redis-cli.c:1005:    int output = 1;
redis-cli.c:1022:        exit(1);
redis-cli.c:1044:        s = strchr(p,' ');      /* MOVED[S]3999 127.0.0.1:6381 */
redis-cli.c:1045:        p = strchr(s+1,' ');    /* MOVED[S]3999[P]127.0.0.1:6381 */
redis-cli.c:1047:        slot = atoi(s+1);
redis-cli.c:1048:        s = strrchr(p+1,':');    /* MOVED 3999[P]127.0.0.1[S]6381 */
redis-cli.c:1051:        config.hostip = sdsnew(p+1);
redis-cli.c:1052:        config.hostport = atoi(s+1);
redis-cli.c:1056:        config.cluster_reissue_command = 1;
redis-cli.c:1074:        fwrite(out,sdslen(out),1,stdout);
redis-cli.c:1098:                       !strcasecmp(argv[1],"htstats")) ||
redis-cli.c:1100:                       !strcasecmp(argv[1],"htstats-key")) ||
redis-cli.c:1102:                      (!strcasecmp(argv[1],"malloc-stats") ||
redis-cli.c:1103:                       !strcasecmp(argv[1],"doctor"))) ||
redis-cli.c:1105:                      (!strcasecmp(argv[1],"nodes") ||
redis-cli.c:1106:                       !strcasecmp(argv[1],"info"))) ||
redis-cli.c:1108:                       !strcasecmp(argv[1],"list")) ||
redis-cli.c:1110:                       !strcasecmp(argv[1],"graph")) ||
redis-cli.c:1112:                       !strcasecmp(argv[1],"doctor")))
redis-cli.c:1114:        output_raw = 1;
redis-cli.c:1117:    if (!strcasecmp(command,"shutdown")) config.shutdown = 1;
redis-cli.c:1118:    if (!strcasecmp(command,"monitor")) config.monitor_mode = 1;
redis-cli.c:1120:        !strcasecmp(command,"psubscribe")) config.pubsub_mode = 1;
redis-cli.c:1122:        !strcasecmp(command,"psync")) config.slave_mode = 1;
redis-cli.c:1127:                     !strcasecmp(argv[1],"debug"))
redis-cli.c:1130:            config.enable_ldb_on_eval = 1;
redis-cli.c:1138:        config.eval_ldb = 1;
redis-cli.c:1150:            if (cliReadReply(output_raw) != REDIS_OK) exit(1);
redis-cli.c:1157:            while (1) {
redis-cli.c:1158:                if (cliReadReply(output_raw) != REDIS_OK) exit(1);
redis-cli.c:1176:                config.dbnum = atoi(argv[1]);
redis-cli.c:1199:            printf("\r\x1b[0K"); /* Cursor to left edge + clear line. */
redis-cli.c:1205:            usleep(1000000);
redis-cli.c:1214:            exit(1);
redis-cli.c:1216:            printf("\r\x1b[0K"); /* Cursor to left edge + clear line. */
redis-cli.c:1231:    for (i = 1; i < argc; i++) {
redis-cli.c:1232:        int lastarg = i==argc-1;
redis-cli.c:1242:            config.stdinarg = 1;
redis-cli.c:1248:            config.repeat = strtoll(argv[++i],NULL,10);
redis-cli.c:1251:            config.interval = seconds*1000000;
redis-cli.c:1255:            config.no_auth_warning = 1;
redis-cli.c:1267:            config.latency_mode = 1;
redis-cli.c:1269:            config.latency_dist_mode = 1;
redis-cli.c:1274:            config.latency_mode = 1;
redis-cli.c:1275:            config.latency_history = 1;
redis-cli.c:1277:            config.lru_test_mode = 1;
redis-cli.c:1278:            config.lru_test_sample_size = strtoll(argv[++i],NULL,10);
redis-cli.c:1280:            config.slave_mode = 1;
redis-cli.c:1282:            config.slave_mode = 1;
redis-cli.c:1284:            config.stat_mode = 1;
redis-cli.c:1286:            config.scan_mode = 1;
redis-cli.c:1290:            config.intrinsic_latency_mode = 1;
redis-cli.c:1293:            config.getrdb_mode = 1;
redis-cli.c:1296:            config.pipe_mode = 1;
redis-cli.c:1300:            config.bigkeys = 1;
redis-cli.c:1302:            config.memkeys = 1;
redis-cli.c:1305:            config.memkeys = 1;
redis-cli.c:1308:            config.hotkeys = 1;
redis-cli.c:1312:            config.eval_ldb = 1;
redis-cli.c:1315:            config.eval_ldb = 1;
redis-cli.c:1316:            config.eval_ldb_sync = 1;
redis-cli.c:1319:            config.cluster_mode = 1;
redis-cli.c:1324:            config.verbose = 1;
redis-cli.c:1331:            createClusterManagerCommand(cmd, j - i, argv + i + 1);
redis-cli.c:1349:                                "--cluster-weight n1=w n2=w\n");
redis-cli.c:1350:                exit(1);
redis-cli.c:1352:            int widx = i + 1;
redis-cli.c:1401:                int j = i + 1;
redis-cli.c:1406:                if (cmd_argc > 1) i = j - 1;
redis-cli.c:1413:                exit(1);
redis-cli.c:1425:        exit(1);
redis-cli.c:1444:    if (cluster_yes != NULL && !strcmp(cluster_yes, "1")) {
redis-cli.c:1450:    char buf[1024];
redis-cli.c:1453:    while(1) {
redis-cli.c:1454:        int nread = read(fileno(stdin),buf,1024);
redis-cli.c:1457:        else if (nread == -1) {
redis-cli.c:1459:            exit(1);
redis-cli.c:1472:"  -h <hostname>      Server hostname (default: 127.0.0.1).\n"
redis-cli.c:1482:"                     It is possible to specify sub-second times like -i 0.1.\n"
redis-cli.c:1496:"                     TTY, it samples the latency for 1 second (you can use\n"
redis-cli.c:1500:"                     Default time interval is 15 sec. Change it using -i.\n"
redis-cli.c:1502:"                     Default time interval is 1 sec. Change it using -i.\n"
redis-cli.c:1542:"  redis-cli -r 100 lpush mylist x\n"
redis-cli.c:1543:"  redis-cli -r 100 -i 1 info | grep used_memory_human:\n"
redis-cli.c:1544:"  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"
redis-cli.c:1545:"  redis-cli --scan --pattern '*:12345*'\n"
redis-cli.c:1554:    exit(1);
redis-cli.c:1559:        return 1;
redis-cli.c:1581:    while (1) {
redis-cli.c:1620:        int elen = line[1] == ' ' ? 2 : 5; /* "e " or "eval "? */
redis-cli.c:1621:        argv[0] = sdsnewlen(line,elen-1);
redis-cli.c:1622:        argv[1] = sdsnewlen(line+elen,len-elen);
redis-cli.c:1634:        if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
redis-cli.c:1635:        else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
redis-cli.c:1639:                argv[1]);
redis-cli.c:1653:    char buf[1024];
redis-cli.c:1681:    config.interactive = 1;
redis-cli.c:1682:    linenoiseSetMultiLine(1);
redis-cli.c:1691:        history = 1;
redis-cli.c:1701:            long repeat = 1;
redis-cli.c:1711:                repeat = strtol(argv[0], &endptr, 10);
redis-cli.c:1712:                if (argc > 1 && *endptr == '\0') {
redis-cli.c:1719:                    skipargs = 1;
redis-cli.c:1721:                    repeat = 1;
redis-cli.c:1741:                    cliSetPreferences(argv,argc,1);
redis-cli.c:1747:                        config.eval_ldb = 1;
redis-cli.c:1755:                    config.hostip = sdsnew(argv[1]);
redis-cli.c:1759:                } else if (argc == 1 && !strcasecmp(argv[0],"clear")) {
redis-cli.c:1780:                        printf("(%.2fs)\n",(double)elapsed/1000);
redis-cli.c:1796:        argv = zrealloc(argv, (argc+1)*sizeof(char*));
redis-cli.c:1798:        retval = issueCommand(argc+1, argv);
redis-cli.c:1812:    char buf[1024];
redis-cli.c:1818:    while(1) {
redis-cli.c:1838:            exit(1);
redis-cli.c:1840:        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
redis-cli.c:1856:        argv2[1] = script;
redis-cli.c:1858:            if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {
redis-cli.c:1859:                got_comma = 1;
redis-cli.c:2015:    {"create", clusterManagerCommandCreate, -2, "host1:port1 ... hostN:portN",
redis-cli.c:2017:    {"check", clusterManagerCommandCheck, -1, "host:port",
redis-cli.c:2019:    {"info", clusterManagerCommandInfo, -1, "host:port", NULL},
redis-cli.c:2020:    {"fix", clusterManagerCommandFix, -1, "host:port",
redis-cli.c:2022:    {"reshard", clusterManagerCommandReshard, -1, "host:port",
redis-cli.c:2025:    {"rebalance", clusterManagerCommandRebalance, -1, "host:port",
redis-cli.c:2026:     "weight <node1=w1...nodeN=wN>,use-empty-masters,"
redis-cli.c:2035:    {"import", clusterManagerCommandImport, 1, "host:port",
redis-cli.c:2060:                (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
redis-cli.c:2075: * If host and port can be detected, it returns 1 and it stores host and
redis-cli.c:2082:    if (argc == 1) {
redis-cli.c:2094:        port = atoi(argv[1]);
redis-cli.c:2101:    return 1;
redis-cli.c:2192:    node->weight = 1.0f;
redis-cli.c:2209:                *err = zmalloc((r->len + 1) * sizeof(char));
redis-cli.c:2215:    return 1;
redis-cli.c:2278:    return 1;
redis-cli.c:2355:            *err = zmalloc((info->len + 1) * sizeof(char));
redis-cli.c:2376:    int is_empty = 1;
redis-cli.c:2390:    is_empty = (known_nodes == 1);
redis-cli.c:2404: * SAME_AS_MASTER = 10000 * each slave in the same IP of its master.
redis-cli.c:2405: * SAME_AS_SLAVE  = 1 * each slave having the same IP as another slave
redis-cli.c:2414: * not be in the same host as the master, we assign 10000 times the score
redis-cli.c:2468:            if (types[0] == 'm') score += (10000 * (typeslen - 1));
redis-cli.c:2469:            else score += (1 * typeslen);
redis-cli.c:2521:        clusterManagerNode **other_replicas = zcalloc((node_len - 1) *
redis-cli.c:2540:        first->replicate = second_master, first->dirty = 1;
redis-cli.c:2541:        second->replicate = first_master, second->dirty = 1;
redis-cli.c:2561:    else if (score >= 10000)
redis-cli.c:2574:    int empty = 1;
redis-cli.c:2591:    int first_range_idx = -1, last_slot_idx = -1, i;
redis-cli.c:2595:            if (first_range_idx == -1) {
redis-cli.c:2607:            last_slot_idx = -1;
redis-cli.c:2608:            first_range_idx = -1;
redis-cli.c:2622:/* We have 16384 hash slots. The hash slot of a given key is obtained
redis-cli.c:2623: * as the least significant 14 bits of the crc16 of the key.
redis-cli.c:2635:    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
redis-cli.c:2638:    for (e = s+1; e < keylen; e++)
redis-cli.c:2642:    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
redis-cli.c:2646:    return crc16(key+s+1,e-s-1) & 0x3FFF;
redis-cli.c:2704:            int dbsize = -1;
redis-cli.c:2747:    int success = 1;
redis-cli.c:2753:    argv[1] = "ADDSLOTS";
redis-cli.c:2755:    argvlen[1] = 8;
redis-cli.c:2788:static int clusterManagerSetSlot(clusterManagerNode *node1,
redis-cli.c:2791:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, "CLUSTER "
redis-cli.c:2797:    int success = 1;
redis-cli.c:2801:            *err = zmalloc((reply->len + 1) * sizeof(char));
redis-cli.c:2803:        } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
redis-cli.c:2828:        strstr(reply->str, "already unassigned") != NULL) success = 1;
redis-cli.c:2850:    int count = -1;
redis-cli.c:2879:    clusterManagerDelSlot(owner, slot, 1);
redis-cli.c:2909:    snprintf(portstr, 10, "%d", target->port);
redis-cli.c:2910:    snprintf(timeoutstr, 10, "%d", timeout);
redis-cli.c:2913:    argv[1] = target->ip;
redis-cli.c:2914:    argv_len[1] = strlen(target->ip);
redis-cli.c:2920:    argv_len[4] = 1;
redis-cli.c:2968:    int success = 1;
redis-cli.c:2971:    while (1) {
redis-cli.c:2982:                *err = zmalloc((reply->len + 1) * sizeof(char));
redis-cli.c:2994:        if (verbose) dots = zmalloc((count+1) * sizeof(char));
redis-cli.c:3025:                        *err = zmalloc((migrate_reply->len + 1) * sizeof(char));
redis-cli.c:3071:        success = 1;
redis-cli.c:3101:                    *err = zmalloc((r->len + 1) * sizeof(char));
redis-cli.c:3113:        target->slots[slot] = 1;
redis-cli.c:3115:    return 1;
redis-cli.c:3123:    int is_err = 0, success = 1;
redis-cli.c:3130:                *err = zmalloc((reply->len + 1) * sizeof(char));
redis-cli.c:3156:        sleep(1);
redis-cli.c:3170:    int success = 1;
redis-cli.c:3181:        lines = p + 1;
redis-cli.c:3190:            line = p + 1;
redis-cli.c:3193:            case 1: addr = token; break;
redis-cli.c:3223:                        line = p + 1;
redis-cli.c:3241:                            node->migrating[node->migrating_count - 1] =
redis-cli.c:3255:                            node->importing[node->importing_count - 1] =
redis-cli.c:3263:                        stop = atoi(p + 1);
redis-cli.c:3264:                        node->slots_count += (stop - (start - 1));
redis-cli.c:3265:                        while (start <= stop) node->slots[start++] = 1;
redis-cli.c:3267:                        node->slots[atoi(slotsdef)] = 1;
redis-cli.c:3311:                flags = fp + 1;
redis-cli.c:3418:    return 1;
redis-cli.c:3422:int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
redis-cli.c:3423:    const char **i1 = (const char **)slot1;
redis-cli.c:3425:    return strcmp(*i1, *i2);
redis-cli.c:3428:int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
redis-cli.c:3429:    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
redis-cli.c:3431:    return node2->slots_count - node1->slots_count;
redis-cli.c:3434:int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
redis-cli.c:3435:    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
redis-cli.c:3437:    return node1->balance - node2->balance;
redis-cli.c:3452:        lines = p + 1;
redis-cli.c:3458:            line = p + 1;
redis-cli.c:3481:                line = p + 1;
redis-cli.c:3487:                slots[c - 1] = slotsdef;
redis-cli.c:3491:            if (c > 1)
redis-cli.c:3497:            tot_size += (sizeof(char) * (c - 1));
redis-cli.c:3498:            char *cfg = zmalloc((sizeof(char) * tot_size) + 1);
redis-cli.c:3509:            node_configs[node_count - 1] = cfg;
redis-cli.c:3514:        if (node_count > 1) {
redis-cli.c:3535:    int consistent = (listLength(cluster_manager.nodes) <= 1);
redis-cli.c:3537:    if (consistent) return 1;
redis-cli.c:3569: * and array of 16384 bytes. Every covered slot will be set to 1 in the
redis-cli.c:3581:                all_slots[i] = 1;
redis-cli.c:3712:                    "CLUSTER GETKEYSINSLOT %d %d", i, 1);
redis-cli.c:3714:                    fixed = -1;
redis-cli.c:3721:                    if (listLength(slot_nodes) > 1)
redis-cli.c:3736:     * 1) No node has keys for this slot.
redis-cli.c:3749:        case 1: listAddNodeTail(single, slot); break;
redis-cli.c:3755:    /*  Handle case "1": keys in no node. */
redis-cli.c:3771:                    fixed = -1;
redis-cli.c:3776:                n->slots[s] = 1;
redis-cli.c:3802:                    fixed = -1;
redis-cli.c:3807:                n->slots[atoi(slot)] = 1;
redis-cli.c:3831:                    fixed = -1;
redis-cli.c:3837:                if (!clusterManagerSetSlotOwner(target, s, 1)) {
redis-cli.c:3838:                    fixed = -1;
redis-cli.c:3843:                target->slots[atoi(slot)] = 1;
redis-cli.c:3852:                        fixed = -1;
redis-cli.c:3859:                                               "IMPORTING", NULL)) fixed = -1;
redis-cli.c:3864:                        fixed = -1;
redis-cli.c:3868:                        fixed = -1;
redis-cli.c:3890:    int success = 1;
redis-cli.c:3918:    if (listLength(owners) == 1) owner = listFirst(owners)->value;
redis-cli.c:3932:                    is_migrating = 1;
redis-cli.c:3945:                    is_importing = 1;
redis-cli.c:3998:        owner->slots[slot] = 1;
redis-cli.c:4017:    if (listLength(owners) > 1) {
redis-cli.c:4025:            success = clusterManagerDelSlot(n, slot, 1);
redis-cli.c:4041:    /* Case 1: The slot is in migrating state in one node, and in
redis-cli.c:4042:     *         importing state in 1 node. That's trivial to address. */
redis-cli.c:4043:    if (listLength(migrating) == 1 && listLength(importing) == 1) {
redis-cli.c:4046:        clusterManagerLogInfo(">>> Case 1: Moving slot %d from "
redis-cli.c:4091:    else if (listLength(migrating) == 1 && listLength(importing) > 1) {
redis-cli.c:4092:        int try_to_fix = 1;
redis-cli.c:4099:                target_id = src->migrating[i + 1];
redis-cli.c:4150:                                 listLength(migrating) == 1);
redis-cli.c:4155:                    "CLUSTER GETKEYSINSLOT %d %d", slot, 10);
redis-cli.c:4199:    assert(listLength(owners) > 1);
redis-cli.c:4221:        clusterManagerDelSlot(n, slot, 1);
redis-cli.c:4239:    int result = 1, consistent = 0;
redis-cli.c:4271:                dictAdd(open_slots, slot, sdsdup(n->migrating[i + 1]));
redis-cli.c:4289:                dictAdd(open_slots, slot, sdsdup(n->importing[i + 1]));
redis-cli.c:4343:            if (fixed > 0) result = 1;
redis-cli.c:4369:            if (listLength(owners) > 1) {
redis-cli.c:4405:        *raise_err = 1;
redis-cli.c:4575:    exit(1);
redis-cli.c:4581:    int i, j, success = 1;
redis-cli.c:4635:                             3 * (replicas + 1));
redis-cli.c:4653:                found = 1;
redis-cli.c:4683:        long last = lround(cursor + slots_per_node - 1);
redis-cli.c:4684:        if (last > CLUSTER_MANAGER_SLOTS || i == (masters_count - 1))
redis-cli.c:4685:            last = CLUSTER_MANAGER_SLOTS - 1;
redis-cli.c:4690:            master->slots[j] = 1;
redis-cli.c:4693:        master->dirty = 1;
redis-cli.c:4694:        first = last + 1;
redis-cli.c:4701:    for (i = 0; i < (interleaved_len - 1); i++)
redis-cli.c:4702:        interleaved[i] = interleaved[i + 1];
redis-cli.c:4703:    interleaved[interleaved_len - 1] = first_node;
redis-cli.c:4712:            int firstNodeIdx = -1;
redis-cli.c:4727:                interleaved += (firstNodeIdx + 1);
redis-cli.c:4734:                slave->dirty = 1;
redis-cli.c:4742:        assign_unused = 1;
redis-cli.c:4770:        int config_epoch = 1;
redis-cli.c:4799:                is_err = 1;
redis-cli.c:4810:        sleep(1);
redis-cli.c:4856:    int success = 1;
redis-cli.c:4860:    if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))
redis-cli.c:4862:    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))
redis-cli.c:4920:    added = 1;
redis-cli.c:4932:        sleep(1);
redis-cli.c:4954:    int success = 1;
redis-cli.c:4957:    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
redis-cli.c:4958:    char *node_id = argv[1];
redis-cli.c:5025:    return 1;
redis-cli.c:5065:            printf("How many slots do you want to move (from 1 to %d)? ",
redis-cli.c:5071:            int last_idx = nread - 1;
redis-cli.c:5088:        int last_idx = nread - 1;
redis-cli.c:5101:    int all = 0, result = 1;
redis-cli.c:5107:        while (1) {
redis-cli.c:5108:            printf("Source node #%lu: ", listLength(sources) + 1);
redis-cli.c:5112:            int last_idx = nread - 1;
redis-cli.c:5120:                all = 1;
redis-cli.c:5137:                all = 1;
redis-cli.c:5148:            from = p + 1;
redis-cli.c:5152:            if (!strcmp(from, "all")) all = 1;
redis-cli.c:5244:    int result = 1, i;
redis-cli.c:5288:    clusterManagerCheckCluster(1);
redis-cli.c:5315:                float err_perc = fabs((100-(100.0*expected/n->slots_count)));
redis-cli.c:5316:                if (err_perc > threshold) over_threshold = 1;
redis-cli.c:5317:            } else if (expected > 1) {
redis-cli.c:5318:                over_threshold = 1;
redis-cli.c:5321:        if (over_threshold) threshold_reached = 1;
redis-cli.c:5360:    int src_idx = nodes_involved - 1;
redis-cli.c:5429:    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
redis-cli.c:5430:    int timeout = atoi(argv[1]);
redis-cli.c:5431:    if (timeout < 100) {
redis-cli.c:5432:        fprintf(stderr, "Setting a node timeout of less than 100 "
redis-cli.c:5469:        else need_free = 1;
redis-cli.c:5477:    return 1;
redis-cli.c:5484:    int success = 1;
redis-cli.c:5498:    if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {
redis-cli.c:5500:                           "pass a valid address (ie. 120.0.0.1:7000).\n";
redis-cli.c:5572:                                             cursor, 1000);
redis-cli.c:5580:        assert(src_reply->element[1]->type == REDIS_REPLY_ARRAY);
redis-cli.c:5585:        int keycount = src_reply->element[1]->elements;
redis-cli.c:5587:            redisReply *kr = src_reply->element[1]->element[i];
redis-cli.c:5590:            uint16_t slot = clusterManagerKeyHashSlot(key, kr->len);
redis-cli.c:5625:    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
redis-cli.c:5656:    return 1;
redis-cli.c:5669:    int padding = 15;
redis-cli.c:5687:                p = comma + 1;
redis-cli.c:5718:#define LATENCY_SAMPLE_RATE 10 /* milliseconds. */
redis-cli.c:5719:#define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 /* milliseconds. */
redis-cli.c:5724:        config.interval ? config.interval/1000 :
redis-cli.c:5732:        config.interval = 1000;
redis-cli.c:5734:        config.interval /= 1000; /* We need to convert to milliseconds. */
redis-cli.c:5737:    if (!context) exit(1);
redis-cli.c:5738:    while(1) {
redis-cli.c:5743:            exit(1);
redis-cli.c:5748:        if (count == 1) {
redis-cli.c:5759:            printf("\x1b[0G\x1b[2K"); /* Clear the line. */
redis-cli.c:5772:            printf(" -- %.2f seconds range\n", (float)(mstime()-history_start)/1000);
redis-cli.c:5776:        usleep(LATENCY_SAMPLE_RATE * 1000);
redis-cli.c:5784:#define LATENCY_DIST_DEFAULT_INTERVAL 1000 /* milliseconds. */
redis-cli.c:5815:            ceil((float) samples[j].count / tot * (spectrum_palette_size-1));
redis-cli.c:5831:    printf(". - * #          .01 .125 .25 .5 milliseconds\n");
redis-cli.c:5832:    printf("1,2,3,...,9      from 1 to 9     milliseconds\n");
redis-cli.c:5833:    printf("A,B,C,D,E        10,20,30,40,50  milliseconds\n");
redis-cli.c:5834:    printf("F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n");
redis-cli.c:5835:    printf("K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n");
redis-cli.c:5836:    printf("From 0 to 100%%: ");
redis-cli.c:5848:        config.interval ? config.interval/1000 :
redis-cli.c:5855:         * which are more interesting than others, like 1-10 milliseconds
redis-cli.c:5857:        {10,0,'.'},         /* 0.01 ms */
redis-cli.c:5858:        {125,0,'-'},        /* 0.125 ms */
redis-cli.c:5861:        {1000,0,'1'},       /* 1 ms */
redis-cli.c:5870:        {10000,0,'A'},      /* 10 ms */
redis-cli.c:5875:        {100000,0,'F'},     /* 0.1 s */
redis-cli.c:5880:        {1000000,0,'K'},    /* 1 s */
redis-cli.c:5884:        {16000000,0,'O'},   /* 16 s */
redis-cli.c:5886:        {60000000,0,'Q'},   /* 1 minute */
redis-cli.c:5887:        {0,0,'?'},          /* > 1 minute */
redis-cli.c:5890:    if (!context) exit(1);
redis-cli.c:5891:    while(1) {
redis-cli.c:5896:            exit(1);
redis-cli.c:5911:        if (count && (ustime()-history_start)/1000 > history_interval) {
redis-cli.c:5918:        usleep(LATENCY_SAMPLE_RATE * 1000);
redis-cli.c:5939:        exit(1);
redis-cli.c:5944:    while(1) {
redis-cli.c:5945:        nread = read(fd,p,1);
redis-cli.c:5948:            exit(1);
redis-cli.c:5956:        exit(1);
redis-cli.c:5958:    return strtoull(buf+1,NULL,10);
redis-cli.c:5964:    char buf[1024];
redis-cli.c:5977:            exit(1);
redis-cli.c:6009:        if (fd == -1) {
redis-cli.c:6012:            exit(1);
redis-cli.c:6022:            exit(1);
redis-cli.c:6027:                (nwritten == -1) ? strerror(errno) : "short write");
redis-cli.c:6028:            exit(1);
redis-cli.c:6043:#define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
redis-cli.c:6047:    char ibuf[1024*16], obuf[1024*16]; /* Input and output buffers */
redis-cli.c:6062:        exit(1);
redis-cli.c:6071:        mask = aeWait(fd,mask,1000);
redis-cli.c:6080:                if (nread == -1 && errno != EAGAIN && errno != EINTR) {
redis-cli.c:6083:                    exit(1);
redis-cli.c:6095:                    exit(1);
redis-cli.c:6108:                            done = 1;
redis-cli.c:6122:            while(1) {
redis-cli.c:6127:                    if (nwritten == -1) {
redis-cli.c:6131:                            exit(1);
redis-cli.c:6151:                        "\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n";
redis-cli.c:6154:                        eof = 1;
redis-cli.c:6160:                        memcpy(echo+21,magic,20);
redis-cli.c:6161:                        memcpy(obuf,echo,sizeof(echo)-1);
redis-cli.c:6162:                        obuf_len = sizeof(echo)-1;
redis-cli.c:6165:                    } else if (nread == -1) {
redis-cli.c:6168:                        exit(1);
redis-cli.c:6194:        exit(1);
redis-cli.c:6209:        exit(1);
redis-cli.c:6212:        exit(1);
redis-cli.c:6215:        exit(1);
redis-cli.c:6218:        exit(1);
redis-cli.c:6223:    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);
redis-cli.c:6226:    *it = strtoull(reply->element[0]->str, NULL, 10);
redis-cli.c:6239:        exit(1);
redis-cli.c:6307:            exit(1);
redis-cli.c:6316:            exit(1);
redis-cli.c:6368:            exit(1);
redis-cli.c:6407:    printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
redis-cli.c:6408:    printf("# per 100 SCAN commands (not usually needed).\n\n");
redis-cli.c:6413:        pct = 100 * (double)sampled/total_keys;
redis-cli.c:6417:        keys  = reply->element[1];
redis-cli.c:6426:                exit(1);
redis-cli.c:6460:                    exit(1);
redis-cli.c:6468:            if(sampled % 1000000 == 0) {
redis-cli.c:6474:        if(sampled && (sampled %100) == 0 && config.interval) {
redis-cli.c:6509:           sampled ? 100 * (double)type->count/sampled : 0,
redis-cli.c:6534:            exit(1);
redis-cli.c:6538:                exit(1);
redis-cli.c:6550:#define HOTKEYS_SAMPLE 16
redis-cli.c:6564:    printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
redis-cli.c:6565:    printf("# per 100 SCAN commands (not usually needed).\n\n");
redis-cli.c:6570:        pct = 100 * (double)sampled/total_keys;
redis-cli.c:6574:        keys  = reply->element[1];
redis-cli.c:6582:                exit(1);
redis-cli.c:6594:            if(sampled % 1000000 == 0) {
redis-cli.c:6607:                memmove(counters,counters+1,sizeof(counters[0])*k);
redis-cli.c:6608:                memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);
redis-cli.c:6618:        if(sampled && (sampled %100) == 0 && config.interval) {
redis-cli.c:6632:    for (i=1; i<= HOTKEYS_SAMPLE; i++) {
redis-cli.c:6652:    char *n1, *n2;
redis-cli.c:6656:    p += strlen(field)+1;
redis-cli.c:6657:    n1 = strchr(p,'\r');
redis-cli.c:6659:    if (n2 && n2 < n1) n1 = n2;
redis-cli.c:6660:    result = zmalloc(sizeof(char)*(n1-p)+1);
redis-cli.c:6661:    memcpy(result,p,(n1-p));
redis-cli.c:6662:    result[n1-p] = '\0';
redis-cli.c:6673:    l = strtol(value,NULL,10);
redis-cli.c:6679: * 100B, 2G, 100M, 4K, and so forth. */
redis-cli.c:6688:    if (n < 1024) {
redis-cli.c:6692:    } else if (n < (1024*1024)) {
redis-cli.c:6693:        d = (double)n/(1024);
redis-cli.c:6695:    } else if (n < (1024LL*1024*1024)) {
redis-cli.c:6696:        d = (double)n/(1024*1024);
redis-cli.c:6698:    } else if (n < (1024LL*1024*1024*1024)) {
redis-cli.c:6699:        d = (double)n/(1024LL*1024*1024);
redis-cli.c:6709:    while(1) {
redis-cli.c:6716:            exit(1);
redis-cli.c:6736:        printf("%-11s",buf);
redis-cli.c:6756:        printf("%-19s",buf);
redis-cli.c:6762:        printf(" %-12s",buf);
redis-cli.c:6766:        aux |= getLongInfoField(reply->str,"aof_rewrite_in_progress") << 1;
redis-cli.c:6770:        case 1:
redis-cli.c:6806:            exit(1);
redis-cli.c:6809:            exit(1);
redis-cli.c:6813:            cur = strtoull(reply->element[0]->str,NULL,10);
redis-cli.c:6814:            for (j = 0; j < reply->element[1]->elements; j++)
redis-cli.c:6815:                printf("%s\n", reply->element[1]->element[j]->str);
redis-cli.c:6836:    max += 1;
redis-cli.c:6839:        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
redis-cli.c:6840:        (1.0/(alpha+1)));
redis-cli.c:6841:    return (max-1-(long long)pl)+min;
redis-cli.c:6848:        powerLawRand(1, config.lru_test_sample_size, 6.2));
redis-cli.c:6851:#define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */
redis-cli.c:6855:    char key[128];
redis-cli.c:6860:    while(1) {
redis-cli.c:6861:        /* Perform cycles of 1 second with 50% writes and 50% reads.
redis-cli.c:6866:        while(mstime() - start_cycle < 1000) {
redis-cli.c:6901:                exit(1);
redis-cli.c:6908:            hits, (double)hits/(hits+misses)*100,
redis-cli.c:6909:            misses, (double)misses/(hits+misses)*100);
redis-cli.c:6923: * Should run in less than 100-200 microseconds even using very
redis-cli.c:6924: * slow hardware. Runs in less than 10 microseconds in modern HW. */
redis-cli.c:6927:    int count = 1000, k;
redis-cli.c:6947:    force_cancel_loop = 1;
redis-cli.c:6953:    run_time = config.intrinsic_latency_duration*1000000;
redis-cli.c:6957:    while(1) {
redis-cli.c:6974:        double avg_ns = avg_us * 1e3;
redis-cli.c:6994:    config.hostip = sdsnew("127.0.0.1");
redis-cli.c:6997:    config.repeat = 1;
redis-cli.c:7028:    config.last_cmd_type = -1;
redis-cli.c:7045:    pref.hints = 1;
redis-cli.c:7068:            exit(1);
redis-cli.c:7075:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7081:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7087:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7093:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7099:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7105:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7111:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7112:        findBigKeys(1, config.memkeys_samples);
redis-cli.c:7117:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7123:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7124:        if (config.interval == 0) config.interval = 1000000;
redis-cli.c:7130:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7136:        if (cliConnect(0) == REDIS_ERR) exit(1);
redis-cli.c:7155:    if (cliConnect(0) != REDIS_OK) exit(1);
redismodule.h:12:#define REDISMODULE_ERR 1
redismodule.h:15:#define REDISMODULE_APIVER_1 1
redismodule.h:18:#define REDISMODULE_READ (1<<0)
redismodule.h:19:#define REDISMODULE_WRITE (1<<1)
redismodule.h:22:#define REDISMODULE_LIST_TAIL 1
redismodule.h:26:#define REDISMODULE_KEYTYPE_STRING 1
redismodule.h:34:#define REDISMODULE_REPLY_UNKNOWN -1
redismodule.h:36:#define REDISMODULE_REPLY_ERROR 1
redismodule.h:42:#define REDISMODULE_POSTPONED_ARRAY_LEN -1
redismodule.h:45:#define REDISMODULE_NO_EXPIRE -1
redismodule.h:48:#define REDISMODULE_ZADD_XX      (1<<0)
redismodule.h:49:#define REDISMODULE_ZADD_NX      (1<<1)
redismodule.h:50:#define REDISMODULE_ZADD_ADDED   (1<<2)
redismodule.h:51:#define REDISMODULE_ZADD_UPDATED (1<<3)
redismodule.h:52:#define REDISMODULE_ZADD_NOP     (1<<4)
redismodule.h:56:#define REDISMODULE_HASH_NX         (1<<0)
redismodule.h:57:#define REDISMODULE_HASH_XX         (1<<1)
redismodule.h:58:#define REDISMODULE_HASH_CFIELDS    (1<<2)
redismodule.h:59:#define REDISMODULE_HASH_EXISTS     (1<<3)
redismodule.h:65:#define REDISMODULE_CTX_FLAGS_LUA (1<<0)
redismodule.h:67:#define REDISMODULE_CTX_FLAGS_MULTI (1<<1)
redismodule.h:69:#define REDISMODULE_CTX_FLAGS_MASTER (1<<2)
redismodule.h:71:#define REDISMODULE_CTX_FLAGS_SLAVE (1<<3)
redismodule.h:73:#define REDISMODULE_CTX_FLAGS_READONLY (1<<4)
redismodule.h:75:#define REDISMODULE_CTX_FLAGS_CLUSTER (1<<5)
redismodule.h:77:#define REDISMODULE_CTX_FLAGS_AOF (1<<6)
redismodule.h:79:#define REDISMODULE_CTX_FLAGS_RDB (1<<7)
redismodule.h:81:#define REDISMODULE_CTX_FLAGS_MAXMEMORY (1<<8)
redismodule.h:83:#define REDISMODULE_CTX_FLAGS_EVICT (1<<9)
redismodule.h:85:#define REDISMODULE_CTX_FLAGS_OOM (1<<10)
redismodule.h:87:#define REDISMODULE_CTX_FLAGS_OOM_WARNING (1<<11)
redismodule.h:89:#define REDISMODULE_CTX_FLAGS_REPLICATED (1<<12)
redismodule.h:92:#define REDISMODULE_NOTIFY_GENERIC (1<<2)     /* g */
redismodule.h:93:#define REDISMODULE_NOTIFY_STRING (1<<3)      /* $ */
redismodule.h:94:#define REDISMODULE_NOTIFY_LIST (1<<4)        /* l */
redismodule.h:95:#define REDISMODULE_NOTIFY_SET (1<<5)         /* s */
redismodule.h:96:#define REDISMODULE_NOTIFY_HASH (1<<6)        /* h */
redismodule.h:97:#define REDISMODULE_NOTIFY_ZSET (1<<7)        /* z */
redismodule.h:98:#define REDISMODULE_NOTIFY_EXPIRED (1<<8)     /* x */
redismodule.h:99:#define REDISMODULE_NOTIFY_EVICTED (1<<9)     /* e */
redismodule.h:100:#define REDISMODULE_NOTIFY_STREAM (1<<10)     /* t */
redismodule.h:106:#define REDISMODULE_HASH_DELETE ((RedisModuleString*)(long)1)
redismodule.h:111:#define REDISMODULE_POSITIVE_INFINITE (1.0/0.0)
redismodule.h:112:#define REDISMODULE_NEGATIVE_INFINITE (-1.0/0.0)
redismodule.h:116:#define REDISMODULE_NODE_MYSELF     (1<<0)
redismodule.h:117:#define REDISMODULE_NODE_MASTER     (1<<1)
redismodule.h:118:#define REDISMODULE_NODE_SLAVE      (1<<2)
redismodule.h:119:#define REDISMODULE_NODE_PFAIL      (1<<3)
redismodule.h:120:#define REDISMODULE_NODE_FAIL       (1<<4)
redismodule.h:121:#define REDISMODULE_NODE_NOFAILOVER (1<<5)
redismodule.h:124:#define REDISMODULE_CLUSTER_FLAG_NO_FAILOVER (1<<1)
redismodule.h:125:#define REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION (1<<2)
redismodule.h:138:#define REDISMODULE_CMDFILTER_NOSELF    (1<<0)
redismodule.h:174:#define REDISMODULE_TYPE_METHOD_VERSION 1
redis-trib.rb:7:        bold: '29;1',
redis-trib.rb:9:        red: 31,
redis-trib.rb:50:        if arg[0..1] == "--"
redis-trib.rb:51:            option = arg[2..-1]
redis-trib.rb:78:            next if arg[0,1] == '-'
redis-trib.rb:122:    example = "redis-cli --cluster info 127.0.0.1:7000"
redis-trib.rb:129:exit 1
release.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
release.c:30:/* Every time the Redis Git SHA1 or Dirty status changes only this small
release.c:40:char *redisGitSHA1(void) {
release.c:41:    return REDIS_GIT_SHA1;
release.c:49:    char *buildid = REDIS_VERSION REDIS_BUILD_ID REDIS_GIT_DIRTY REDIS_GIT_SHA1;
replication.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
replication.c:52: * example: "Closing connection with replica 10.1.2.3:6380". */
replication.c:61:        anetPeerToString(c->fd,ip,sizeof(ip),NULL) != -1)
replication.c:78://repl_backlog.circular buffer。1M ..一个server只有一个，当有一个slave client的时候创建
replication.c:88:    server.repl_backlog_off = server.master_repl_offset+1;
replication.c:114:        server.repl_backlog_off = server.master_repl_offset+1;
replication.c:150:                              server.repl_backlog_histlen + 1;
replication.c:237:        len = ll2string(aux+1,sizeof(aux)-1,argc);
replication.c:238:        aux[len+1] = '\r';
replication.c:251:            len = ll2string(aux+1,sizeof(aux)-1,objlen);
replication.c:252:            aux[len+1] = '\r';
replication.c:256:            feedReplicationBacklog(aux+len+1,2);
replication.c:334:        if (j != argc-1)
replication.c:335:            cmdrepr = sdscatlen(cmdrepr," ",1);
replication.c:413: * 1) Remember, into the slave client structure, the replication offset
replication.c:427://设置selectdb=-1重新选择正确的db
replication.c:430:    char buf[128];
replication.c:436:     * slave as well. Set slaveseldb to -1 in order to force to re-emit
replication.c:438:    server.slaveseldb = -1;
replication.c:460:    char *master_replid = c->argv[1]->ptr;
replication.c:461:    char buf[128];
replication.c:474:     * Note that there are two potentially valid replication IDs: the ID1
replication.c:517:     * 1) Set client state to make it a slave.
replication.c:545:     * to -1 to force the master to emit SELECT, since the slave already
replication.c:569: * 1) Handle the slaves in WAIT_START state, by preparing them for a full
replication.c:685:            char *master_replid = c->argv[1]->ptr;
replication.c:710:    c->repldbfd = -1;
replication.c:715:    if (listLength(server.slaves) == 1 && server.repl_backlog == NULL) {
replication.c:724:    /* CASE 1: BGSAVE is in progress, with disk target. */
replication.c:725:    if (server.rdb_child_pid != -1 &&
replication.c:758:    } else if (server.rdb_child_pid != -1 &&
replication.c:780:            if (server.aof_child_pid == -1) {
replication.c:815:    for (j = 1; j < c->argc; j+=2) {
replication.c:819:            if ((getLongFromObjectOrReply(c,c->argv[j+1],
replication.c:824:            sds ip = c->argv[j+1]->ptr;
replication.c:826:                memcpy(c->slave_ip,ip,sdslen(ip)+1);
replication.c:834:            if (!strcasecmp(c->argv[j+1]->ptr,"eof"))
replication.c:836:            else if (!strcasecmp(c->argv[j+1]->ptr,"psync2"))
replication.c:846:            if ((getLongLongFromObject(c->argv[j+1], &offset) != C_OK))
replication.c:878: * 1) Put the slave in ONLINE state (useless when the function is called
replication.c:911:        if (nwritten == -1) {
replication.c:918:        sdsrange(slave->replpreamble,nwritten,-1);
replication.c:937:    if ((nwritten = write(fd,buf,buflen)) == -1) {
replication.c:949:        slave->repldbfd = -1;
replication.c:973:    int mincapa = -1;
replication.c:979:        //如果时start表示时bgsave之间上来的，则置位1，后面开始重新bgsave。同时能力为最小值
replication.c:981:            startbgsave = 1;
replication.c:982:            mincapa = (mincapa == -1) ? slave->slave_capa :
replication.c:1004:                slave->repl_put_online_on_ack = 1;//这里置位1，接收 replicate ack后，发送字节流
replication.c:1012:                if ((slave->repldbfd = open(server.rdb_filename,O_RDONLY)) == -1 ||
replication.c:1013:                    redis_fstat(slave->repldbfd,&buf) == -1) {
replication.c:1052:    server.second_replid_offset = -1;
replication.c:1062:    /* We set the second replid offset to the master offset + 1, since
replication.c:1067:     * 51, since the slave asking has the same history up to the 50th
replication.c:1068:     * byte, and is asking for the new bytes starting at offset 51. */
replication.c:1069:    server.second_replid_offset = server.master_repl_offset+1;
replication.c:1076:/* Returns 1 if the given replication state is a handshake state,
replication.c:1095:        if (write(server.repl_transfer_s,"\n",1) == -1) {
replication.c:1114:    server.master->authenticated = 1;
replication.c:1119:    /* If master offset is set to -1, this master is old and is not
replication.c:1121:    if (server.master->reploff == -1)
replication.c:1123:    if (dbid != -1) selectDb(server.master,dbid);
replication.c:1131:    unsigned int tries, max_tries = 10;
replication.c:1137:        sleep(1);
replication.c:1143:        exit(1);
replication.c:1148:#define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) /* 8 MB */
replication.c:1163:    /* If repl_transfer_size == -1 we still have to read the bulk length
replication.c:1165:    if (server.repl_transfer_size == -1) {
replication.c:1166:        if (syncReadLine(fd,buf,1024,server.repl_syncio_timeout*1000) == -1) {
replication.c:1176:                buf+1);
replication.c:1199:        if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= CONFIG_RUN_ID_SIZE) {
replication.c:1200:            usemark = 1;
replication.c:1210:            server.repl_transfer_size = strtol(buf+1,NULL,10);
replication.c:1229:            (nread == -1) ? strerror(errno) : "connection lost");
replication.c:1248:        if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
replication.c:1254:            (nwritten == -1) ? strerror(errno) : "short write");
replication.c:1262:            server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
replication.c:1285:            eof_reached = 1;
replication.c:1292:        if (server.rdb_child_pid != -1) {
replication.c:1299:            kill(server.rdb_child_pid,SIGUSR1);
replication.c:1303:        if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
replication.c:1312:        signalFlushedDb(-1);
replication.c:1314:            -1,
replication.c:1369:#define SYNC_CMD_READ (1<<0)
replication.c:1370:#define SYNC_CMD_WRITE (1<<1)
replication.c:1385:        while(1) {
replication.c:1400:        if (syncWrite(fd,cmd,sdslen(cmd),server.repl_syncio_timeout*1000)
replication.c:1401:            == -1)
replication.c:1414:        if (syncReadLine(fd,buf,sizeof(buf),server.repl_syncio_timeout*1000)
replication.c:1415:            == -1)
replication.c:1428: * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC
replication.c:1435: * 1) We pass the function an already connected socket "fd".
replication.c:1442: * needed, with read_reply set to 1, in order to read the reply of the
replication.c:1448: * with read_reply set to 1. However even when read_reply is set to 1
replication.c:1462: * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.
replication.c:1467: * 1) As a side effect of the function call the function removes the readable
replication.c:1475:#define PSYNC_WAIT_REPLY 1
replication.c:1487:        /* Initially set master_initial_offset to -1 to mark the current
replication.c:1492:        server.master_initial_offset = -1;
replication.c:1496:            snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
replication.c:1501:            memcpy(psync_offset,"-1",3);
replication.c:1526:    if (!strncmp(reply,"+FULLRESYNC",11)) {
replication.c:1537:        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
replication.c:1544:            memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
replication.c:1546:            memcpy(server.master_replid, replid, offset-replid-1);
replication.c:1548:            server.master_initial_offset = strtoll(offset,NULL,10);
replication.c:1569:        char *start = reply+10;
replication.c:1573:            char new[CONFIG_RUN_ID_SIZE+1];
replication.c:1581:                /* Set the old ID as our ID2, up to the current offset+1. */
replication.c:1584:                server.second_replid_offset = server.master_repl_offset+1;
replication.c:1614:    if (!strncmp(reply,"-NOMASTERLINK",13) ||
replication.c:1642:    int dfd = -1, maxtries = 5;
replication.c:1658:    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
replication.c:1836:    psync_result = slaveTryPartialResynchronization(fd,1);
replication.c:1865:        if (syncWrite(fd,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
replication.c:1877:        if (dfd != -1) break;
replication.c:1878:        sleep(1);
replication.c:1880:    if (dfd == -1) {
replication.c:1896:    server.repl_transfer_size = -1;
replication.c:1906:    if (dfd != -1) close(dfd);
replication.c:1908:    server.repl_transfer_s = -1;
replication.c:1923:    if (fd == -1) {
replication.c:1952:    server.repl_transfer_s = -1;
replication.c:1970: * If there was a replication handshake in progress 1 is returned and
replication.c:1986:    return 1;
replication.c:2035:    server.slaveseldb = -1;
replication.c:2065:    if (!strcasecmp(c->argv[1]->ptr,"no") &&
replication.c:2090:        if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr)
replication.c:2098:        replicationSetMaster(c->argv[1]->ptr, port);
replication.c:2127:                if (anetPeerToString(slave->fd,ip,sizeof(ip),NULL) == -1)
replication.c:2159:        addReplyLongLong(c,server.master ? server.master->reploff : -1);
replication.c:2249:    replicationCreateMasterClient(-1,-1);
replication.c:2283:    server.master->authenticated = 1;
replication.c:2349: * 1) Every time a new slave connects, we flush the whole script cache.
replication.c:2353: *    corresponding SHA1 of the script into the cache as we are sure every
replication.c:2364:    server.repl_scriptcache_size = 10000;
replication.c:2374: * 1) Every time a new slave reconnects to this master and performs a
replication.c:2388:void replicationScriptCacheAdd(sds sha1) {
replication.c:2390:    sds key = sdsdup(sha1);
replication.c:2410: * if all the slaves are aware of this script SHA1. */
replication.c:2411:int replicationScriptCacheExists(sds sha1) {
replication.c:2412:    return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
replication.c:2446:    server.get_ack_from_slaves = 1;
replication.c:2479:    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
replication.c:2561:    /* offset may be -1 when the master does not support it at all, however
replication.c:2571:/* Replication cron function, called 1 time per second. */
replication.c:2628:    robj *ping_argv[1];
replication.c:2647:                ping_argv, 1);
replication.c:2677:            if (write(slave->fd, "\n", 1) == -1) {
replication.c:2722:             * 1. We are a master instance.
replication.c:2757:    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
replication.c:2760:        int mincapa = -1;
replication.c:2771:                mincapa = (mincapa == -1) ? slave->slave_capa :
replication.c:2789:    replication_cron_loops++; /* Incremented with frequency 1 HZ. */
rio.c:18: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
rio.c:19: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rio.c:60:/* Returns 1 or 0 for success/failure. */
rio.c:64:    return 1;
rio.c:67:/* Returns 1 or 0 for success/failure. */
rio.c:73:    return 1;
rio.c:81:/* Flushes any buffer to target device if applicable. Returns 1 on success
rio.c:85:    return 1; /* Nothing to do, our write just appends to the buffer. */
rio.c:108:/* Returns 1 or 0 for success/failure. */
rio.c:112:    retval = fwrite(buf,len,1,r->io.file.fp);
rio.c:125:/* Returns 1 or 0 for success/failure. */
rio.c:127:    return fread(buf,len,1,r->io.file.fp);
rio.c:135:/* Flushes any buffer to target device if applicable. Returns 1 on success
rio.c:138:    return (fflush(r->io.file.fp) == 0) ? 1 : 0;
rio.c:162:/* Returns 1 or 0 for success/failure.
rio.c:180:        if (sdslen(r->io.fdset.buf) > PROTO_IOBUF_LEN) doflush = 1;
rio.c:192:        size_t count = len < 1024 ? len : 1024;
rio.c:211:                    if (retval == -1 && errno == EWOULDBLOCK) errno = ETIMEDOUT;
rio.c:230:    return 1;
rio.c:233:/* Returns 1 or 0 for success/failure. */
rio.c:246:/* Flushes any buffer to target device if applicable. Returns 1 on success
rio.c:314:    char cbuf[128];
rio.c:318:    clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
rio.c:346:    char dbuf[128];
rio.c:349:    dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
rio.h:2: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
rio.h:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
rio.h:103:    return 1;
rio.h:116:    return 1;
scripting.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
scripting.c:31:#include "sha1.h"
scripting.c:83:/* Perform the SHA1 of the input string. We use this both for hashing script
scripting.c:85: * of redis.sha1().
scripting.c:87: * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an
scripting.c:88: * hexadecimal number, plus 1 byte for null term. */
scripting.c:89:void sha1hex(char *digest, char *script, size_t len) {
scripting.c:90:    SHA1_CTX ctx;
scripting.c:92:    char *cset = "0123456789abcdef";
scripting.c:95:    SHA1Init(&ctx);
scripting.c:96:    SHA1Update(&ctx,(unsigned char*)script,len);
scripting.c:97:    SHA1Final(hash,&ctx);
scripting.c:101:        digest[j*2+1] = cset[(hash[j]&0xF)];
scripting.c:141:    char *p = strchr(reply+1,'\r');
scripting.c:144:    string2ll(reply+1,p-reply-1,&value);
scripting.c:150:    char *p = strchr(reply+1,'\r');
scripting.c:153:    string2ll(reply+1,p-reply-1,&bulklen);
scripting.c:154:    if (bulklen == -1) {
scripting.c:164:    char *p = strchr(reply+1,'\r');
scripting.c:168:    lua_pushlstring(lua,reply+1,p-reply-1);
scripting.c:174:    char *p = strchr(reply+1,'\r');
scripting.c:178:    lua_pushlstring(lua,reply+1,p-reply-1);
scripting.c:184:    char *p = strchr(reply+1,'\r');
scripting.c:188:    string2ll(reply+1,p-reply-1,&mbulklen);
scripting.c:190:    if (mbulklen == -1) {
scripting.c:196:        lua_pushnumber(lua,j+1);
scripting.c:221:    if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg)) {
scripting.c:254:    if (lua_pcall(lua,1,0,0)) {
scripting.c:261:        lua_pop(lua,1);             /* Stack: array, table */
scripting.c:270:    lua_pop(lua,1);             /* Stack: array (sorted) */
scripting.c:278:    int t = lua_type(lua,-1);
scripting.c:282:        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
scripting.c:285:        addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
scripting.c:288:        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));
scripting.c:297:        t = lua_type(lua,-1);
scripting.c:299:            sds err = sdsnew(lua_tostring(lua,-1));
scripting.c:307:        lua_pop(lua,1);
scripting.c:310:        t = lua_type(lua,-1);
scripting.c:312:            sds ok = sdsnew(lua_tostring(lua,-1));
scripting.c:316:            lua_pop(lua,1);
scripting.c:319:            int j = 1, mbulklen = 0;
scripting.c:321:            lua_pop(lua,1); /* Discard the 'ok' field value we popped */
scripting.c:322:            while(1) {
scripting.c:325:                t = lua_type(lua,-1);
scripting.c:327:                    lua_pop(lua,1);
scripting.c:339:    lua_pop(lua,1);
scripting.c:378:        return 1;
scripting.c:387:        return raise_error ? luaRaiseError(lua) : 1;
scripting.c:401:        if (lua_type(lua,j+1) == LUA_TNUMBER) {
scripting.c:404:            lua_Number num = lua_tonumber(lua,j+1);
scripting.c:406:            obj_len = snprintf(dbuf,sizeof(dbuf),"%.17g",(double)num);
scripting.c:409:            obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);
scripting.c:420:            memcpy(s,obj_s,obj_len+1);
scripting.c:439:        return raise_error ? luaRaiseError(lua) : 1;
scripting.c:455:            if (j == 10) {
scripting.c:457:                    c->argc-j-1);
scripting.c:460:                cmdlog = sdscatlen(cmdlog," ",1);
scripting.c:532:    if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;
scripting.c:533:    if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;
scripting.c:564:        server.lua_multi_emitted = 1;
scripting.c:609:        (reply[0] == '*' && reply[1] != '-')) {
scripting.c:622:         * The object must be small, SDS-encoded, and with refcount = 1
scripting.c:625:            o->refcount == 1 &&
scripting.c:653:    return 1;
scripting.c:659:    return luaRedisGenericCommand(lua,1);
scripting.c:667:/* This adds redis.sha1hex(string) to Lua scripts using the same hashing
scripting.c:668: * function used for sha1ing lua scripts. */
scripting.c:669:int luaRedisSha1hexCommand(lua_State *lua) {
scripting.c:671:    char digest[41];
scripting.c:675:    if (argc != 1) {
scripting.c:680:    s = (char*)lua_tolstring(lua,1,&len);
scripting.c:681:    sha1hex(digest,s,len);
scripting.c:683:    return 1;
scripting.c:694:    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
scripting.c:696:        return 1;
scripting.c:703:    return 1;
scripting.c:726:        server.lua_replicate_commands = 1;
scripting.c:731:        lua_pushboolean(lua,1);
scripting.c:733:    return 1;
scripting.c:743:        ldb.luabp = 1;
scripting.c:744:        lua_pushboolean(lua,1);
scripting.c:748:    return 1;
scripting.c:761:        log = ldbCatStackValue(log,lua,-1 - argc);
scripting.c:779:    } else if (argc != 1) {
scripting.c:784:    flags = lua_tonumber(lua,-1);
scripting.c:814:    for (j = 1; j < argc; j++) {
scripting.c:820:            if (j != 1) log = sdscatlen(log," ",1);
scripting.c:836:  lua_call(lua, 1, 0);
scripting.c:912: * the 'setup' argument set to 1.
scripting.c:973:    /* redis.sha1hex */
scripting.c:974:    lua_pushstring(lua, "sha1hex");
scripting.c:975:    lua_pushcfunction(lua, luaRedisSha1hexCommand);
scripting.c:1081:        server.lua_client = createClient(-1);
scripting.c:1114:        lua_rawseti(lua,-2,j+1);
scripting.c:1130:  /* the `%' avoids the (rare) case of r==1, and is needed also because on
scripting.c:1136:      lua_pushnumber(L, r);  /* Number between 0 and 1 */
scripting.c:1139:    case 1: {  /* only upper limit */
scripting.c:1140:      int u = luaL_checkint(L, 1);
scripting.c:1141:      luaL_argcheck(L, 1<=u, 1, "interval is empty");
scripting.c:1142:      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
scripting.c:1146:      int l = luaL_checkint(L, 1);
scripting.c:1149:      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
scripting.c:1154:  return 1;
scripting.c:1158:  redisSrand48(luaL_checkint(L, 1));
scripting.c:1169: *   f_<hex sha1 sum>
scripting.c:1174: * On success a pointer to an SDS string representing the function SHA1 of the
scripting.c:1188:    funcname[1] = '_';
scripting.c:1189:    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));
scripting.c:1208:                lua_tostring(lua,-1));
scripting.c:1210:        lua_pop(lua,1);
scripting.c:1220:                lua_tostring(lua,-1));
scripting.c:1222:        lua_pop(lua,1);
scripting.c:1227:    /* We also save a SHA1 -> Original script map in a dictionary
scripting.c:1247:        server.lua_timedout = 1;
scripting.c:1299:    /* We obtain the script SHA1, then check if this function is already
scripting.c:1302:    funcname[1] = '_';
scripting.c:1305:        sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));
scripting.c:1309:        char *sha = c->argv[1]->ptr;
scripting.c:1325:    if (lua_isnil(lua,-1)) {
scripting.c:1326:        lua_pop(lua,1); /* remove the nil from the stack */
scripting.c:1331:            lua_pop(lua,1); /* remove the error handler from the stack. */
scripting.c:1335:        if (luaCreateFunction(c,lua,c->argv[1]) == NULL) {
scripting.c:1336:            lua_pop(lua,1); /* remove the error handler from the stack. */
scripting.c:1343:        serverAssert(!lua_isnil(lua,-1));
scripting.c:1365:        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
scripting.c:1366:        delhook = 1;
scripting.c:1368:        lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
scripting.c:1369:        delhook = 1;
scripting.c:1375:    err = lua_pcall(lua,0,1,-2);
scripting.c:1408:            funcname, lua_tostring(lua,-1));
scripting.c:1414:        lua_pop(lua,1); /* Remove the error handler. */
scripting.c:1422:            robj *propargv[1];
scripting.c:1424:            alsoPropagate(server.execCommand,c->db->id,propargv,1,
scripting.c:1434:     * To do so we use a cache of SHA1s of scripts that we already propagated
scripting.c:1441:        if (!replicationScriptCacheExists(c->argv[1]->ptr)) {
scripting.c:1445:            robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
scripting.c:1447:            replicationScriptCacheAdd(c->argv[1]->ptr);
scripting.c:1462:                rewriteClientCommandArgument(c,1,script);
scripting.c:1477:    if (sdslen(c->argv[1]->ptr) != 40) {
scripting.c:1486:        evalGenericCommand(c,1);
scripting.c:1494:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
scripting.c:1497:"EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.",
scripting.c:1504:    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"flush")) {
scripting.c:1509:    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,"exists")) {
scripting.c:1519:    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"load")) {
scripting.c:1524:    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"kill")) {
scripting.c:1532:            server.lua_kill = 1;
scripting.c:1535:    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"debug")) {
scripting.c:1565:    ldb.fd = -1;
scripting.c:1588:    ldb.step = 1;
scripting.c:1616:        sdsrange(entry,0,ldb.maxlen-1);
scripting.c:1618:        trimmed = 1;
scripting.c:1622:        ldb.maxlen_hint_sent = 1;
scripting.c:1636:        proto = sdscatlen(proto,"+",1);
scripting.c:1642:    if (write(ldb.fd,proto,sdslen(proto)) == -1) {
scripting.c:1655: * The function returns 1 if the caller should proceed to call EVAL,
scripting.c:1661: * returned 1. */
scripting.c:1666:        if (cp == -1) {
scripting.c:1697:    ldb.active = 1;
scripting.c:1701:    sds srcstring = sdsdup(c->argv[1]->ptr);
scripting.c:1703:    while(srclen && (srcstring[srclen-1] == '\n' ||
scripting.c:1704:                     srcstring[srclen-1] == '\r'))
scripting.c:1709:    ldb.src = sdssplitlen(srcstring,sdslen(srcstring),"\n",1,&ldb.lines);
scripting.c:1711:    return 1;
scripting.c:1752:        return 1;
scripting.c:1792:    int idx = line-1;
scripting.c:1802:        if (ldb.bp[j] == line) return 1;
scripting.c:1807: * Returns 1 if the breakpoint was added (or was already set). 0 if there is
scripting.c:1813:        return 1;
scripting.c:1818:/* Remove the specified breakpoint, returning 1 if the operation was
scripting.c:1826:            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
scripting.c:1827:            return 1;
scripting.c:1852:    char *plen = p+1; /* Multi bulk len pointer. */
scripting.c:1856:    if (*argcp <= 0 || *argcp > 1024) goto protoerr;
scripting.c:1863:        plen = p+1; /* Bulk string len pointer. */
scripting.c:1867:        if (slen <= 0 || slen > 1024) goto protoerr;
scripting.c:1870:        if (p[0] != '\r' || p[1] != '\n') goto protoerr;
scripting.c:1909:    for (j = 1; j <= ldb.lines; j++) {
scripting.c:1948:        int expected_index = 1; /* First index we expect in an array. */
scripting.c:1949:        int is_array = 1; /* Will be set to null if check fails. */
scripting.c:1953:        sds repr1 = sdsempty();
scripting.c:1956:        while (lua_next(lua,idx-1)) {
scripting.c:1963:            repr1 = ldbCatStackValueRec(repr1,lua,-1,level);
scripting.c:1964:            repr1 = sdscatlen(repr1,"; ",2);
scripting.c:1966:            repr2 = sdscatlen(repr2,"[",1);
scripting.c:1969:            repr2 = ldbCatStackValueRec(repr2,lua,-1,level);
scripting.c:1971:            lua_pop(lua,1); /* Stack: table, key. Ready for next iteration. */
scripting.c:1975:        if (sdslen(repr1)) sdsrange(repr1,0,-3);
scripting.c:1978:        s = sdscatlen(s,"{",1);
scripting.c:1979:        s = sdscatsds(s,is_array ? repr1 : repr2);
scripting.c:1980:        s = sdscatlen(s,"}",1);
scripting.c:1981:        sdsfree(repr1);
scripting.c:2017:    s = ldbCatStackValue(s,lua,-1);
scripting.c:2047:    char *p = strchr(reply+1,'\r');
scripting.c:2048:    *o = sdscatlen(*o,reply+1,p-reply-1);
scripting.c:2053:    char *p = strchr(reply+1,'\r');
scripting.c:2056:    string2ll(reply+1,p-reply-1,&bulklen);
scripting.c:2057:    if (bulklen == -1) {
scripting.c:2067:    char *p = strchr(reply+1,'\r');
scripting.c:2074:    char *p = strchr(reply+1,'\r');
scripting.c:2078:    string2ll(reply+1,p-reply-1,&mbulklen);
scripting.c:2080:    if (mbulklen == -1) {
scripting.c:2084:    *o = sdscatlen(*o,"[",1);
scripting.c:2087:        if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
scripting.c:2089:    *o = sdscatlen(*o,"]",1);
scripting.c:2112:        int i = 1; /* Variable index. */
scripting.c:2117:                lua_pop(lua,1);
scripting.c:2120:                lua_pop(lua,1); /* Discard the var name on the stack. */
scripting.c:2129:        lua_pop(lua,1);
scripting.c:2143:        int i = 1; /* Variable index. */
scripting.c:2152:            lua_pop(lua,1);
scripting.c:2163:    if (argc == 1) {
scripting.c:2175:        for (j = 1; j < argc; j++) {
scripting.c:2188:                        ldbList(line,1);
scripting.c:2208:    sds code = sdsjoinsds(argv+1,argc-1," ",1);
scripting.c:2213:        lua_pop(lua,1);
scripting.c:2216:            ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
scripting.c:2217:            lua_pop(lua,1);
scripting.c:2226:    if (lua_pcall(lua,0,1,0)) {
scripting.c:2227:        ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
scripting.c:2228:        lua_pop(lua,1);
scripting.c:2232:    lua_pop(lua,1);
scripting.c:2245:    for (j = 1; j < argc; j++)
scripting.c:2247:    ldb.step = 1;               /* Force redis.call() to log. */
scripting.c:2248:    server.lua_replicate_commands = 1;
scripting.c:2249:    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */
scripting.c:2280:        int newval = atoi(argv[1]);
scripting.c:2281:        ldb.maxlen_hint_sent = 1; /* User knows about this command. */
scripting.c:2301:    while(1) {
scripting.c:2303:            char buf[1024];
scripting.c:2331:ldbLog(sdsnew("[w]hole              List all source code. Alias for 'list 1 1000000'."));
scripting.c:2354:            ldb.step = 1;
scripting.c:2373:        } else if (argc > 1 &&
scripting.c:2379:                ldbPrint(lua,argv[1]);
scripting.c:2385:            if (argc > 1) {
scripting.c:2386:                int num = atoi(argv[1]);
scripting.c:2393:            ldbList(1,1000000);
scripting.c:2429:            timeout = 1;
scripting.c:2430:            ldb.step = 1;
sdsalloc.h:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
sdsalloc.h:4: * Copyright (c) 2015, Redis Labs, Inc
sds.c:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
sds.c:4: * Copyright (c) 2015, Oran Agra
sds.c:5: * Copyright (c) 2015, Redis Labs, Inc
sds.c:50:        case SDS_TYPE_16:
sds.c:51:            return sizeof(struct sdshdr16);
sds.c:61:    if (string_size < 1<<5)
sds.c:63:    if (string_size < 1<<8)
sds.c:65:    if (string_size < 1<<16)
sds.c:66:        return SDS_TYPE_16;
sds.c:68:    if (string_size < 1ll<<32)
sds.c:99:    sh = s_malloc(hdrlen+initlen+1);
sds.c:103:        memset(sh, 0, hdrlen+initlen+1);
sds.c:106:    fp = ((unsigned char*)s)-1;
sds.c:119:        case SDS_TYPE_16: {
sds.c:120:            SDS_HDR_VAR(16,s);
sds.c:167:    s_free((char*)s-sdsHdrSize(s[-1]));
sds.c:208:    char type, oldtype = s[-1] & SDS_TYPE_MASK;
sds.c:231:        newsh = s_realloc(sh, hdrlen+newlen+1);
sds.c:237:        newsh = s_malloc(hdrlen+newlen+1);
sds.c:239:        memcpy((char*)newsh+hdrlen, s, len+1);
sds.c:242:        s[-1] = type;
sds.c:257:    char type, oldtype = s[-1] & SDS_TYPE_MASK;
sds.c:276:        newsh = s_realloc(sh, oldhdrlen+len+1);
sds.c:280:        newsh = s_malloc(hdrlen+len+1);
sds.c:282:        memcpy((char*)newsh+hdrlen, s, len+1);
sds.c:285:        s[-1] = type;
sds.c:294: * 1) The sds header before the pointer.
sds.c:301:    return sdsHdrSize(s[-1])+alloc+1;
sds.c:307:    return (void*) (s-sdsHdrSize(s[-1]));
sds.c:334:    unsigned char flags = s[-1];
sds.c:338:            unsigned char *fp = ((unsigned char*)s)-1;
sds.c:351:        case SDS_TYPE_16: {
sds.c:352:            SDS_HDR_VAR(16,s);
sds.c:387:    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
sds.c:449:#define SDS_LLSTR_SIZE 21
sds.c:460:        *p++ = '0'+(v%10);
sds.c:461:        v /= 10;
sds.c:490:        *p++ = '0'+(v%10);
sds.c:491:        v /= 10;
sds.c:524:    char staticbuf[1024], *buf = staticbuf, *t;
sds.c:538:    while(1) {
sds.c:615:        /* Make sure there is always space for at least 1 char. */
sds.c:617:            s = sdsMakeRoomFor(s,1);
sds.c:622:            next = *(f+1);
sds.c:672:                sdsinclen(s,1);
sds.c:678:            sdsinclen(s,1);
sds.c:709:    ep = end = s+sdslen(s)-1;
sds.c:712:    len = (sp > ep) ? 0 : ((ep-sp)+1);
sds.c:722: * start and end can be negative, where -1 means the last character of the
sds.c:733: * sdsrange(s,1,-1); => "ello World"
sds.c:747:    newlen = (start > end) ? 0 : (end-start)+1;
sds.c:752:            end = len-1;
sds.c:753:            newlen = (start > end) ? 0 : (end-start)+1;
sds.c:777:/* Compare two sds strings s1 and s2 with memcmp().
sds.c:781: *     positive if s1 > s2.
sds.c:782: *     negative if s1 < s2.
sds.c:783: *     0 if s1 and s2 are exactly the same binary string.
sds.c:788:int sdscmp(const sds s1, const sds s2) {
sds.c:789:    size_t l1, l2, minlen;
sds.c:792:    l1 = sdslen(s1);
sds.c:794:    minlen = (l1 < l2) ? l1 : l2;
sds.c:795:    cmp = memcmp(s1,s2,minlen);
sds.c:796:    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
sds.c:821:    if (seplen < 1 || len < 0) return NULL;
sds.c:830:    for (j = 0; j < (len-(seplen-1)); j++) {
sds.c:841:        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
sds.c:846:            j = j+seplen-1; /* skip the separator */
sds.c:881:    s = sdscatlen(s,"\"",1);
sds.c:902:    return sdscatlen(s,"\"",1);
sds.c:913: * integer from 0 to 15 */
sds.c:917:    case '1': return 1;
sds.c:926:    case 'a': case 'A': return 10;
sds.c:927:    case 'b': case 'B': return 11;
sds.c:928:    case 'c': case 'C': return 12;
sds.c:929:    case 'd': case 'D': return 13;
sds.c:930:    case 'e': case 'E': return 14;
sds.c:931:    case 'f': case 'F': return 15;
sds.c:961:    while(1) {
sds.c:966:            int inq=0;  /* set to 1 if we are in "quotes" */
sds.c:967:            int insq=0; /* set to 1 if we are in 'single quotes' */
sds.c:973:                    if (*p == '\\' && *(p+1) == 'x' &&
sds.c:979:                        byte = (hex_digit_to_int(*(p+2))*16)+
sds.c:981:                        current = sdscatlen(current,(char*)&byte,1);
sds.c:983:                    } else if (*p == '\\' && *(p+1)) {
sds.c:995:                        current = sdscatlen(current,&c,1);
sds.c:999:                        if (*(p+1) && !isspace(*(p+1))) goto err;
sds.c:1000:                        done=1;
sds.c:1005:                        current = sdscatlen(current,p,1);
sds.c:1008:                    if (*p == '\\' && *(p+1) == '\'') {
sds.c:1010:                        current = sdscatlen(current,"'",1);
sds.c:1014:                        if (*(p+1) && !isspace(*(p+1))) goto err;
sds.c:1015:                        done=1;
sds.c:1020:                        current = sdscatlen(current,p,1);
sds.c:1029:                        done=1;
sds.c:1032:                        inq=1;
sds.c:1035:                        insq=1;
sds.c:1038:                        current = sdscatlen(current,p,1);
sds.c:1045:            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));
sds.c:1069: * For instance: sdsmapchars(mystring, "ho", "01", 2)
sds.c:1070: * will have the effect of turning the string "hello" into "0ell1".
sds.c:1096:        if (j != argc-1) join = sdscat(join,sep);
sds.c:1108:        if (j != argc-1) join = sdscatlen(join,sep,seplen);
sds.c:1146:            sdslen(x) == 1 && memcmp(x,"a\0",2) == 0)
sds.c:1154:        x = sdscatprintf(sdsempty(),"%d",123);
sds.c:1156:            sdslen(x) == 3 && memcmp(x,"123\0",4) == 0)
sds.c:1172:            memcmp(x,"--4294967295,18446744073709551615--",35) == 0)
sds.c:1184:            sdslen(x) == 1 && x[0] == 'x')
sds.c:1193:        sdsrange(y,1,1);
sds.c:1194:        test_cond("sdsrange(...,1,1)",
sds.c:1195:            sdslen(y) == 1 && memcmp(y,"i\0",2) == 0)
sds.c:1199:        sdsrange(y,1,-1);
sds.c:1200:        test_cond("sdsrange(...,1,-1)",
sds.c:1205:        sdsrange(y,-2,-1);
sds.c:1206:        test_cond("sdsrange(...,-2,-1)",
sds.c:1211:        sdsrange(y,2,1);
sds.c:1212:        test_cond("sdsrange(...,2,1)",
sds.c:1213:            sdslen(y) == 0 && memcmp(y,"\0",1) == 0)
sds.c:1217:        sdsrange(y,1,100);
sds.c:1218:        test_cond("sdsrange(...,1,100)",
sds.c:1223:        sdsrange(y,100,100);
sds.c:1224:        test_cond("sdsrange(...,100,100)",
sds.c:1225:            sdslen(y) == 0 && memcmp(y,"\0",1) == 0)
sds.c:1250:            memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0)
sds.c:1255:            int step = 10, j, i;
sds.c:1260:            test_cond("sdsnew() free/len buffers", sdslen(x) == 1 && sdsavail(x) == 0);
sds.c:1264:            for (i = 0; i < 10; i++) {
sds.c:1267:                int type = x[-1]&SDS_TYPE_MASK;
sds.c:1281:                memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0);
sds.c:1282:            test_cond("sdsMakeRoomFor() final length",sdslen(x)==101);
sds.h:3: * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
sds.h:4: * Copyright (c) 2015, Oran Agra
sds.h:5: * Copyright (c) 2015, Redis Labs, Inc
sds.h:36:#define SDS_MAX_PREALLOC (1024*1024)
sds.h:57:struct __attribute__ ((__packed__)) sdshdr16 {
sds.h:58:    uint16_t len; /* used */
sds.h:59:    uint16_t alloc; /* excluding the header and null terminator */
sds.h:77:#define SDS_TYPE_8  1
sds.h:78:#define SDS_TYPE_16 2
sds.h:88:    unsigned char flags = s[-1];
sds.h:94:        case SDS_TYPE_16:
sds.h:95:            return SDS_HDR(16,s)->len;
sds.h:105:    unsigned char flags = s[-1];
sds.h:114:        case SDS_TYPE_16: {
sds.h:115:            SDS_HDR_VAR(16,s);
sds.h:131:    unsigned char flags = s[-1];
sds.h:135:                unsigned char *fp = ((unsigned char*)s)-1;
sds.h:142:        case SDS_TYPE_16:
sds.h:143:            SDS_HDR(16,s)->len = newlen;
sds.h:155:    unsigned char flags = s[-1];
sds.h:159:                unsigned char *fp = ((unsigned char*)s)-1;
sds.h:167:        case SDS_TYPE_16:
sds.h:168:            SDS_HDR(16,s)->len += inc;
sds.h:181:    unsigned char flags = s[-1];
sds.h:187:        case SDS_TYPE_16:
sds.h:188:            return SDS_HDR(16,s)->alloc;
sds.h:198:    unsigned char flags = s[-1];
sds.h:206:        case SDS_TYPE_16:
sds.h:207:            SDS_HDR(16,s)->alloc = newlen;
sds.h:243:int sdscmp(const sds s1, const sds s2);
sentinel.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
sentinel.c:54:#define SRI_MASTER  (1<<0)
sentinel.c:55:#define SRI_SLAVE   (1<<1)
sentinel.c:56:#define SRI_SENTINEL (1<<2)
sentinel.c:57:#define SRI_S_DOWN (1<<3)   /* Subjectively down (no quorum). */
sentinel.c:58:#define SRI_O_DOWN (1<<4)   /* Objectively down (confirmed by others). */
sentinel.c:59:#define SRI_MASTER_DOWN (1<<5) /* A Sentinel with this flag set thinks that
sentinel.c:61:#define SRI_FAILOVER_IN_PROGRESS (1<<6) /* Failover is in progress for
sentinel.c:63:#define SRI_PROMOTED (1<<7)            /* Slave selected for promotion. */
sentinel.c:64:#define SRI_RECONF_SENT (1<<8)     /* SLAVEOF <newmaster> sent. */
sentinel.c:65:#define SRI_RECONF_INPROG (1<<9)   /* Slave synchronization in progress. */
sentinel.c:66:#define SRI_RECONF_DONE (1<<10)     /* Slave synchronized with new master. */
sentinel.c:67:#define SRI_FORCE_FAILOVER (1<<11)  /* Force failover with master up. */
sentinel.c:68:#define SRI_SCRIPT_KILL_SENT (1<<12) /* SCRIPT KILL already sent on -BUSY */
sentinel.c:71:#define SENTINEL_INFO_PERIOD 10000
sentinel.c:72:#define SENTINEL_PING_PERIOD 1000
sentinel.c:73:#define SENTINEL_ASK_PERIOD 1000
sentinel.c:79:#define SENTINEL_DEFAULT_SLAVE_PRIORITY 100
sentinel.c:80:#define SENTINEL_SLAVE_RECONF_TIMEOUT 10000
sentinel.c:81:#define SENTINEL_DEFAULT_PARALLEL_SYNCS 1
sentinel.c:82:#define SENTINEL_MIN_LINK_RECONNECT_PERIOD 15000
sentinel.c:83:#define SENTINEL_DEFAULT_FAILOVER_TIMEOUT (60*3*1000)
sentinel.c:84:#define SENTINEL_MAX_PENDING_COMMANDS 100
sentinel.c:85:#define SENTINEL_ELECTION_TIMEOUT 10000
sentinel.c:86:#define SENTINEL_MAX_DESYNC 1000
sentinel.c:87:#define SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG 1
sentinel.c:91:#define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/
sentinel.c:99:#define SENTINEL_MASTER_LINK_STATUS_DOWN 1
sentinel.c:105:#define SENTINEL_GENERATE_EVENT (1<<16)
sentinel.c:106:#define SENTINEL_LEADER (1<<17)
sentinel.c:107:#define SENTINEL_OBSERVER (1<<18)
sentinel.c:111:#define SENTINEL_SCRIPT_RUNNING 1
sentinel.c:113:#define SENTINEL_SCRIPT_MAX_RUNNING 16
sentinel.c:115:#define SENTINEL_SCRIPT_MAX_RETRY 10
sentinel.c:120:#define SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION (1<<0)
sentinel.c:121:#define SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION (1<<1)
sentinel.c:126: * among them. Oherwise if 5 Sentinels are monitoring 100 masters we create
sentinel.c:136: * a link with refcount = 1, always. */
sentinel.c:235:    char myid[CONFIG_RUN_ID_SIZE+1]; /* This sentinel ID. */
sentinel.c:301:        e->reading = 1;
sentinel.c:319:        e->writing = 1;
sentinel.c:396:int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
sentinel.c:397:int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
sentinel.c:450:    {"ping",pingCommand,1,"",0,NULL,0,0,0,0,0},
sentinel.c:453:    {"unsubscribe",unsubscribeCommand,-1,"",0,NULL,0,0,0,0,0},
sentinel.c:455:    {"punsubscribe",punsubscribeCommand,-1,"",0,NULL,0,0,0,0,0},
sentinel.c:457:    {"info",sentinelInfoCommand,-1,"",0,NULL,0,0,0,0,0},
sentinel.c:458:    {"role",sentinelRoleCommand,1,"l",0,NULL,0,0,0,0,0},
sentinel.c:460:    {"shutdown",shutdownCommand,-1,"",0,NULL,0,0,0,0,0},
sentinel.c:509:        exit(1);
sentinel.c:510:    } else if (access(server.configfile,W_OK) == -1) {
sentinel.c:514:        exit(1);
sentinel.c:616:    if (fmt[0] == '%' && fmt[1] == '@') {
sentinel.c:693:#define SENTINEL_SCRIPT_MAX_ARGS 16
sentinel.c:696:    char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
sentinel.c:697:    int argc = 1;
sentinel.c:713:    sj->argv = zmalloc(sizeof(char*)*(argc+1));
sentinel.c:716:    memcpy(sj->argv,argv,sizeof(char*)*(argc+1));
sentinel.c:783:        if (pid == -1) {
sentinel.c:808: * if RETRY_DELAY is set to 30 seconds and the max number of retries is 10
sentinel.c:810: * 30 sec, 60 sec, 2 min, 4 min, 8 min, 16 min, 32 min, 64 min, 128 min. */
sentinel.c:814:    while (retry_num-- > 1) delay *= 2;
sentinel.c:820: * a signal, or returned exit code "1", it is scheduled to run again if
sentinel.c:844:         * exit code of "1" (that means: please retry), we reschedule it
sentinel.c:846:        if ((bysignal || exitcode == 1) &&
sentinel.c:899:        addReplyMultiBulkLen(c,10);
sentinel.c:959:    link->refcount = 1;
sentinel.c:960:    link->disconnected = 1;
sentinel.c:989:    link->disconnected = 1;
sentinel.c:1051:    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */
sentinel.c:1134:    link->disconnected = 1;
sentinel.c:1331: * The function returns 1 if the matching Sentinel was removed, otherwise
sentinel.c:1420: * 1) Remove all slaves.
sentinel.c:1430:#define SENTINEL_RESET_NO_SENTINELS (1<<0)
sentinel.c:1510:        slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
sentinel.c:1522:        slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
sentinel.c:1631:        if (quorum <= 0) return "Quorum must be 1 or greater.";
sentinel.c:1633:        if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
sentinel.c:1644:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1652:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1659:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1664:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1666:        if (access(argv[2],X_OK) == -1)
sentinel.c:1671:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1673:        if (access(argv[2],X_OK) == -1)
sentinel.c:1679:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1684:        unsigned long long current_epoch = strtoull(argv[1],NULL,10);
sentinel.c:1688:        if (strlen(argv[1]) != CONFIG_RUN_ID_SIZE)
sentinel.c:1690:        memcpy(sentinel.myid,argv[1],CONFIG_RUN_ID_SIZE);
sentinel.c:1693:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1695:        ri->config_epoch = strtoull(argv[2],NULL,10);
sentinel.c:1703:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1705:        ri->leader_epoch = strtoull(argv[2],NULL,10);
sentinel.c:1712:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1725:            ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1737:        ri = sentinelGetMasterByName(argv[1]);
sentinel.c:1748:        if (strlen(argv[1]))
sentinel.c:1749:            sentinel.announce_ip = sdsnew(argv[1]);
sentinel.c:1752:        sentinel.announce_port = atoi(argv[1]);
sentinel.c:1755:        if ((sentinel.deny_scripts_reconfig = yesnotoi(argv[1])) == -1) {
sentinel.c:1777:    rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1797:        rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1804:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1812:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1820:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1828:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1836:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1844:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1851:        rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1857:        rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1877:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1889:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1901:            rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1909:    rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1915:        rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1922:        rewriteConfigRewriteLine(state,"sentinel",line,1);
sentinel.c:1936:    int fd = -1;
sentinel.c:1944:    if (rewrite_status == -1) goto werr;
sentinel.c:1945:    if ((fd = open(server.configfile,O_RDONLY)) == -1) goto werr;
sentinel.c:1946:    if (fsync(fd) == -1) goto werr;
sentinel.c:1951:    if (fd != -1) close(fd);
sentinel.c:2086: * 1) It is actually a master in the current configuration.
sentinel.c:2135:         * new versions: slave0:ip=127.0.0.1,port=9999,... */
sentinel.c:2179:            ri->master_link_down_time = strtoll(l+31,NULL,10)*1000;
sentinel.c:2184:        if (!memcmp(l,"role:master",11)) role = SRI_MASTER;
sentinel.c:2185:        else if (!memcmp(l,"role:slave",10)) role = SRI_SLAVE;
sentinel.c:2190:            if (sdslen(l) >= 12 && !memcmp(l,"master_host:",12)) {
sentinel.c:2192:                    strcasecmp(l+12,ri->slave_master_host))
sentinel.c:2195:                    ri->slave_master_host = sdsnew(l+12);
sentinel.c:2201:            if (sdslen(l) >= 12 && !memcmp(l,"master_port:",12)) {
sentinel.c:2202:                int slave_master_port = atoi(l+12);
sentinel.c:2211:            if (sdslen(l) >= 19 && !memcmp(l,"master_link_status:",19)) {
sentinel.c:2213:                    (strcasecmp(l+19,"up") == 0) ?
sentinel.c:2219:            if (sdslen(l) >= 15 && !memcmp(l,"slave_priority:",15))
sentinel.c:2220:                ri->slave_priority = atoi(l+15);
sentinel.c:2223:            if (sdslen(l) >= 18 && !memcmp(l,"slave_repl_offset:",18))
sentinel.c:2224:                ri->slave_repl_offset = strtoull(l+18,NULL,10);
sentinel.c:2400:            strncmp(r->str,"MASTERDOWN",10) == 0)
sentinel.c:2439:     * we'll retry again in 100 milliseconds. */
sentinel.c:2451:     * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
sentinel.c:2455:    char **token = sdssplitlen(hello, hello_len, ",", 1, &numtokens);
sentinel.c:2467:        port = atoi(token[1]);
sentinel.c:2471:        current_epoch = strtoull(token[3],NULL,10);
sentinel.c:2472:        master_config_epoch = strtoull(token[7],NULL,10);
sentinel.c:2578:        r->element[1]->type != REDIS_REPLY_STRING ||
sentinel.c:2602:    char payload[NET_IP_STR_LEN+1024];
sentinel.c:2616:        if (anetSockName(ri->link->cc->c.fd,ip,sizeof(ip),NULL) == -1)
sentinel.c:2651:        if (ri->last_pub_time >= (SENTINEL_PUBLISH_PERIOD+1))
sentinel.c:2652:            ri->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
sentinel.c:2667:    if (master->last_pub_time >= (SENTINEL_PUBLISH_PERIOD+1))
sentinel.c:2668:        master->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
sentinel.c:2691:        return 1;
sentinel.c:2725:    //如果检测时主观下线改为1000ms一次发送info消息。如果不是则10s一次的发送info消息
sentinel.c:2731:        info_period = 1000;
sentinel.c:2738:     * anyway if 'down-after-milliseconds' is greater than 1 second. */
sentinel.c:3003:#define SENTINEL_ISQR_NOQUORUM (1<<0)
sentinel.c:3004:#define SENTINEL_ISQR_NOAUTH (1<<1)
sentinel.c:3008:    int usable = 1; /* Number of usable Sentinels. Init to 1 to count myself. */
sentinel.c:3010:    int voters = dictSize(master->sentinels)+1; /* Known Sentinels + myself. */
sentinel.c:3022:    if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
sentinel.c:3028:    if (!strcasecmp(c->argv[1]->ptr,"masters")) {
sentinel.c:3032:    } else if (!strcasecmp(c->argv[1]->ptr,"master")) {
sentinel.c:3040:    } else if (!strcasecmp(c->argv[1]->ptr,"slaves") ||
sentinel.c:3041:               !strcasecmp(c->argv[1]->ptr,"replicas"))
sentinel.c:3050:    } else if (!strcasecmp(c->argv[1]->ptr,"sentinels")) {
sentinel.c:3059:    } else if (!strcasecmp(c->argv[1]->ptr,"is-master-down-by-addr")) {
sentinel.c:3096:            isdown = 1;
sentinel.c:3114:    } else if (!strcasecmp(c->argv[1]->ptr,"reset")) {
sentinel.c:3118:    } else if (!strcasecmp(c->argv[1]->ptr,"get-master-addr-by-name")) {
sentinel.c:3133:    } else if (!strcasecmp(c->argv[1]->ptr,"failover")) {
sentinel.c:3153:    } else if (!strcasecmp(c->argv[1]->ptr,"pending-scripts")) {
sentinel.c:3158:    } else if (!strcasecmp(c->argv[1]->ptr,"monitor")) {
sentinel.c:3171:            addReplyError(c, "Quorum must be 1 or greater.");
sentinel.c:3203:    } else if (!strcasecmp(c->argv[1]->ptr,"flushconfig")) {
sentinel.c:3208:    } else if (!strcasecmp(c->argv[1]->ptr,"remove")) {
sentinel.c:3219:    } else if (!strcasecmp(c->argv[1]->ptr,"ckquorum")) {
sentinel.c:3246:    } else if (!strcasecmp(c->argv[1]->ptr,"set")) {
sentinel.c:3249:    } else if (!strcasecmp(c->argv[1]->ptr,"info-cache")) {
sentinel.c:3272:         *   1.) master name
sentinel.c:3273:         *   2.) 1.) info from master
sentinel.c:3287:            addReplyMultiBulkLen(c,dictSize(ri->slaves) + 1); /* +1 for self */
sentinel.c:3311:    } else if (!strcasecmp(c->argv[1]->ptr,"simulate-failure")) {
sentinel.c:3340:                               (char*)c->argv[1]->ptr);
sentinel.c:3346:                          (char*)c->argv[1]->ptr);
sentinel.c:3367:    char *section = c->argc == 2 ? c->argv[1]->ptr : NULL;
sentinel.c:3372:        defsections = 1;
sentinel.c:3415:                dictSize(ri->sentinels)+1);
sentinel.c:3454:        int moreargs = (c->argc-1) - j;
sentinel.c:3498:            if (strlen(value) && access(value,X_OK) == -1) {
sentinel.c:3518:            if (strlen(value) && access(value,X_OK) == -1) {
sentinel.c:3543:        } else if (!strcasecmp(option,"rename-command") && moreargs > 1) {
sentinel.c:3549:                badarg = sdslen(newname) ? j-1 : j;
sentinel.c:3572:        int numargs = j-old_j+1;
sentinel.c:3576:                                                          c->argv[old_j+1]->ptr);
sentinel.c:3580:                                                             c->argv[old_j+1]->ptr,
sentinel.c:3606:    if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
sentinel.c:3611:    addReplyLongLong(c,1);
sentinel.c:3631:     * 1) Check if the command link seems connected, was connected not less
sentinel.c:3670:     * 1) It is not replying.
sentinel.c:3712:        quorum = 1; /* the current sentinel. */
sentinel.c:3721:        if (quorum >= master->quorum) odown = 1;
sentinel.c:3762:        r->element[1]->type == REDIS_REPLY_STRING &&
sentinel.c:3766:        if (r->element[0]->integer == 1) {
sentinel.c:3771:        if (strcmp(r->element[1]->str,"*")) {
sentinel.c:3778:                    r->element[1]->str,
sentinel.c:3781:            ri->leader = sdsnew(r->element[1]->str);
sentinel.c:3791:#define SENTINEL_ASK_FORCED (1<<0)
sentinel.c:3812:         * 1) We believe it is down, or there is a failover in progress.
sentinel.c:3896:        dictSetUnsignedIntegerVal(existing,oldval+1);
sentinel.c:3897:        return oldval+1;
sentinel.c:3900:        dictSetUnsignedIntegerVal(de,1);
sentinel.c:3901:        return 1;
sentinel.c:3924:    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me.*/
sentinel.c:3936:     * 1) Absolute majority between voters (50% + 1).
sentinel.c:3966:    voters_quorum = voters/2+1;
sentinel.c:4001:     * 1) Reconfigure the instance according to the specified host/port params.
sentinel.c:4028:    /* CLIENT KILL TYPE <type> is only supported starting from Redis 2.8.12,
sentinel.c:4058:    //这里增加随机值，实际上1是为了防止两个哨兵同时对一个主节点进行故障迁移，这里的时间其实也就是等待的时间
sentinel.c:4066: * 1) Master must be in ODOWN condition.
sentinel.c:4088:                            master->failover_timeout*2) / 1000;
sentinel.c:4102:    return 1;
sentinel.c:4108: * 1) None of the following conditions: S_DOWN, O_DOWN, DISCONNECTED.
sentinel.c:4112: *     (now - master->s_down_since_time) + (master->down_after_period * 10).
sentinel.c:4114: *    to be disconnected no more than 10 times the configured down-after-period.
sentinel.c:4148:        return -1; /* a < b */
sentinel.c:4150:        return 1; /* a > b */
sentinel.c:4160:    else if (sa_runid == NULL) return 1;  /* a > b */
sentinel.c:4161:    else if (sb_runid == NULL) return -1; /* a < b */
sentinel.c:4176:    max_master_down_time += master->down_after_period * 10;
sentinel.c:4327:        timeout = 1;
sentinel.c:4452:        case SENTINEL_FAILOVER_STATE_WAIT_START://状态1选举leader并设置下一个状态
sentinel.c:4564: * Note that we expect that more or less just 100 milliseconds will pass
sentinel.c:4569: * 1) The Sentiel process for some time is blocked, for every kind of
sentinel.c:4584:        sentinel.tilt = 1;
server.c:2: * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>
server.c:122: * F: Fast command: O(1) or O(log(N)) command that should never delay
server.c:129:    {"get",getCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:130:    {"set",setCommand,-3,"wm",0,NULL,1,1,1,0,0},
server.c:131:    {"setnx",setnxCommand,3,"wmF",0,NULL,1,1,1,0,0},
server.c:132:    {"setex",setexCommand,4,"wm",0,NULL,1,1,1,0,0},
server.c:133:    {"psetex",psetexCommand,4,"wm",0,NULL,1,1,1,0,0},
server.c:134:    {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
server.c:135:    {"strlen",strlenCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:136:    {"del",delCommand,-2,"w",0,NULL,1,-1,1,0,0},
server.c:137:    {"unlink",unlinkCommand,-2,"wF",0,NULL,1,-1,1,0,0},
server.c:138:    {"exists",existsCommand,-2,"rF",0,NULL,1,-1,1,0,0},
server.c:139:    {"setbit",setbitCommand,4,"wm",0,NULL,1,1,1,0,0},
server.c:140:    {"getbit",getbitCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:141:    {"bitfield",bitfieldCommand,-2,"wm",0,NULL,1,1,1,0,0},
server.c:142:    {"setrange",setrangeCommand,4,"wm",0,NULL,1,1,1,0,0},
server.c:143:    {"getrange",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
server.c:144:    {"substr",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
server.c:145:    {"incr",incrCommand,2,"wmF",0,NULL,1,1,1,0,0},
server.c:146:    {"decr",decrCommand,2,"wmF",0,NULL,1,1,1,0,0},
server.c:147:    {"mget",mgetCommand,-2,"rF",0,NULL,1,-1,1,0,0},
server.c:148:    {"rpush",rpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
server.c:149:    {"lpush",lpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
server.c:150:    {"rpushx",rpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
server.c:151:    {"lpushx",lpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
server.c:152:    {"linsert",linsertCommand,5,"wm",0,NULL,1,1,1,0,0},
server.c:153:    {"rpop",rpopCommand,2,"wF",0,NULL,1,1,1,0,0},
server.c:154:    {"lpop",lpopCommand,2,"wF",0,NULL,1,1,1,0,0},
server.c:155:    {"brpop",brpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
server.c:156:    {"brpoplpush",brpoplpushCommand,4,"wms",0,NULL,1,2,1,0,0},
server.c:157:    {"blpop",blpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
server.c:158:    {"llen",llenCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:159:    {"lindex",lindexCommand,3,"r",0,NULL,1,1,1,0,0},
server.c:160:    {"lset",lsetCommand,4,"wm",0,NULL,1,1,1,0,0},
server.c:161:    {"lrange",lrangeCommand,4,"r",0,NULL,1,1,1,0,0},
server.c:162:    {"ltrim",ltrimCommand,4,"w",0,NULL,1,1,1,0,0},
server.c:163:    {"lrem",lremCommand,4,"w",0,NULL,1,1,1,0,0},
server.c:164:    {"rpoplpush",rpoplpushCommand,3,"wm",0,NULL,1,2,1,0,0},
server.c:165:    {"sadd",saddCommand,-3,"wmF",0,NULL,1,1,1,0,0},
server.c:166:    {"srem",sremCommand,-3,"wF",0,NULL,1,1,1,0,0},
server.c:167:    {"smove",smoveCommand,4,"wF",0,NULL,1,2,1,0,0},
server.c:168:    {"sismember",sismemberCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:169:    {"scard",scardCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:170:    {"spop",spopCommand,-2,"wRF",0,NULL,1,1,1,0,0},
server.c:171:    {"srandmember",srandmemberCommand,-2,"rR",0,NULL,1,1,1,0,0},
server.c:172:    {"sinter",sinterCommand,-2,"rS",0,NULL,1,-1,1,0,0},
server.c:173:    {"sinterstore",sinterstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
server.c:174:    {"sunion",sunionCommand,-2,"rS",0,NULL,1,-1,1,0,0},
server.c:175:    {"sunionstore",sunionstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
server.c:176:    {"sdiff",sdiffCommand,-2,"rS",0,NULL,1,-1,1,0,0},
server.c:177:    {"sdiffstore",sdiffstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
server.c:178:    {"smembers",sinterCommand,2,"rS",0,NULL,1,1,1,0,0},
server.c:179:    {"sscan",sscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
server.c:180:    {"zadd",zaddCommand,-4,"wmF",0,NULL,1,1,1,0,0},
server.c:181:    {"zincrby",zincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
server.c:182:    {"zrem",zremCommand,-3,"wF",0,NULL,1,1,1,0,0},
server.c:183:    {"zremrangebyscore",zremrangebyscoreCommand,4,"w",0,NULL,1,1,1,0,0},
server.c:184:    {"zremrangebyrank",zremrangebyrankCommand,4,"w",0,NULL,1,1,1,0,0},
server.c:185:    {"zremrangebylex",zremrangebylexCommand,4,"w",0,NULL,1,1,1,0,0},
server.c:188:    {"zrange",zrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:189:    {"zrangebyscore",zrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:190:    {"zrevrangebyscore",zrevrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:191:    {"zrangebylex",zrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:192:    {"zrevrangebylex",zrevrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:193:    {"zcount",zcountCommand,4,"rF",0,NULL,1,1,1,0,0},
server.c:194:    {"zlexcount",zlexcountCommand,4,"rF",0,NULL,1,1,1,0,0},
server.c:195:    {"zrevrange",zrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:196:    {"zcard",zcardCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:197:    {"zscore",zscoreCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:198:    {"zrank",zrankCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:199:    {"zrevrank",zrevrankCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:200:    {"zscan",zscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
server.c:201:    {"zpopmin",zpopminCommand,-2,"wF",0,NULL,1,1,1,0,0},
server.c:202:    {"zpopmax",zpopmaxCommand,-2,"wF",0,NULL,1,1,1,0,0},
server.c:203:    {"bzpopmin",bzpopminCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
server.c:204:    {"bzpopmax",bzpopmaxCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
server.c:205:    {"hset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
server.c:206:    {"hsetnx",hsetnxCommand,4,"wmF",0,NULL,1,1,1,0,0},
server.c:207:    {"hget",hgetCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:208:    {"hmset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
server.c:209:    {"hmget",hmgetCommand,-3,"rF",0,NULL,1,1,1,0,0},
server.c:210:    {"hincrby",hincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
server.c:211:    {"hincrbyfloat",hincrbyfloatCommand,4,"wmF",0,NULL,1,1,1,0,0},
server.c:212:    {"hdel",hdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
server.c:213:    {"hlen",hlenCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:214:    {"hstrlen",hstrlenCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:215:    {"hkeys",hkeysCommand,2,"rS",0,NULL,1,1,1,0,0},
server.c:216:    {"hvals",hvalsCommand,2,"rS",0,NULL,1,1,1,0,0},
server.c:217:    {"hgetall",hgetallCommand,2,"rR",0,NULL,1,1,1,0,0},
server.c:218:    {"hexists",hexistsCommand,3,"rF",0,NULL,1,1,1,0,0},
server.c:219:    {"hscan",hscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
server.c:220:    {"incrby",incrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
server.c:221:    {"decrby",decrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
server.c:222:    {"incrbyfloat",incrbyfloatCommand,3,"wmF",0,NULL,1,1,1,0,0},
server.c:223:    {"getset",getsetCommand,3,"wm",0,NULL,1,1,1,0,0},
server.c:224:    {"mset",msetCommand,-3,"wm",0,NULL,1,-1,2,0,0},
server.c:225:    {"msetnx",msetnxCommand,-3,"wm",0,NULL,1,-1,2,0,0},
server.c:226:    {"randomkey",randomkeyCommand,1,"rR",0,NULL,0,0,0,0,0},
server.c:229:    {"move",moveCommand,3,"wF",0,NULL,1,1,1,0,0},
server.c:230:    {"rename",renameCommand,3,"w",0,NULL,1,2,1,0,0},
server.c:231:    {"renamenx",renamenxCommand,3,"wF",0,NULL,1,2,1,0,0},
server.c:232:    {"expire",expireCommand,3,"wF",0,NULL,1,1,1,0,0},
server.c:233:    {"expireat",expireatCommand,3,"wF",0,NULL,1,1,1,0,0},
server.c:234:    {"pexpire",pexpireCommand,3,"wF",0,NULL,1,1,1,0,0},
server.c:235:    {"pexpireat",pexpireatCommand,3,"wF",0,NULL,1,1,1,0,0},
server.c:238:    {"dbsize",dbsizeCommand,1,"rF",0,NULL,0,0,0,0,0},
server.c:240:    {"ping",pingCommand,-1,"tF",0,NULL,0,0,0,0,0},
server.c:242:    {"save",saveCommand,1,"as",0,NULL,0,0,0,0,0},
server.c:243:    {"bgsave",bgsaveCommand,-1,"as",0,NULL,0,0,0,0,0},
server.c:244:    {"bgrewriteaof",bgrewriteaofCommand,1,"as",0,NULL,0,0,0,0,0},
server.c:245:    {"shutdown",shutdownCommand,-1,"aslt",0,NULL,0,0,0,0,0},
server.c:246:    {"lastsave",lastsaveCommand,1,"RF",0,NULL,0,0,0,0,0},
server.c:247:    {"type",typeCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:248:    {"multi",multiCommand,1,"sF",0,NULL,0,0,0,0,0},
server.c:249:    {"exec",execCommand,1,"sM",0,NULL,0,0,0,0,0},
server.c:250:    {"discard",discardCommand,1,"sF",0,NULL,0,0,0,0,0},
server.c:251:    {"sync",syncCommand,1,"ars",0,NULL,0,0,0,0,0},
server.c:253:    {"replconf",replconfCommand,-1,"aslt",0,NULL,0,0,0,0,0},
server.c:254:    {"flushdb",flushdbCommand,-1,"w",0,NULL,0,0,0,0,0},
server.c:255:    {"flushall",flushallCommand,-1,"w",0,NULL,0,0,0,0,0},
server.c:256:    {"sort",sortCommand,-2,"wm",0,sortGetKeys,1,1,1,0,0},
server.c:257:    {"info",infoCommand,-1,"ltR",0,NULL,0,0,0,0,0},
server.c:258:    {"monitor",monitorCommand,1,"as",0,NULL,0,0,0,0,0},
server.c:259:    {"ttl",ttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
server.c:260:    {"touch",touchCommand,-2,"rF",0,NULL,1,1,1,0,0},
server.c:261:    {"pttl",pttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
server.c:262:    {"persist",persistCommand,2,"wF",0,NULL,1,1,1,0,0},
server.c:265:    {"role",roleCommand,1,"lst",0,NULL,0,0,0,0,0},
server.c:269:    {"unsubscribe",unsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
server.c:271:    {"punsubscribe",punsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
server.c:274:    {"watch",watchCommand,-2,"sF",0,NULL,1,-1,1,0,0},
server.c:275:    {"unwatch",unwatchCommand,1,"sF",0,NULL,0,0,0,0,0},
server.c:277:    {"restore",restoreCommand,-4,"wm",0,NULL,1,1,1,0,0},
server.c:278:    {"restore-asking",restoreCommand,-4,"wmk",0,NULL,1,1,1,0,0},
server.c:280:    {"asking",askingCommand,1,"F",0,NULL,0,0,0,0,0},
server.c:281:    {"readonly",readonlyCommand,1,"F",0,NULL,0,0,0,0,0},
server.c:282:    {"readwrite",readwriteCommand,1,"F",0,NULL,0,0,0,0,0},
server.c:283:    {"dump",dumpCommand,2,"rR",0,NULL,1,1,1,0,0},
server.c:284:    {"object",objectCommand,-2,"rR",0,NULL,2,2,1,0,0},
server.c:291:    {"time",timeCommand,1,"RF",0,NULL,0,0,0,0,0},
server.c:292:    {"bitop",bitopCommand,-4,"wm",0,NULL,2,-1,1,0,0},
server.c:293:    {"bitcount",bitcountCommand,-2,"r",0,NULL,1,1,1,0,0},
server.c:294:    {"bitpos",bitposCommand,-3,"r",0,NULL,1,1,1,0,0},
server.c:297:    {"geoadd",geoaddCommand,-5,"wm",0,NULL,1,1,1,0,0},
server.c:298:    {"georadius",georadiusCommand,-6,"w",0,georadiusGetKeys,1,1,1,0,0},
server.c:299:    {"georadius_ro",georadiusroCommand,-6,"r",0,georadiusGetKeys,1,1,1,0,0},
server.c:300:    {"georadiusbymember",georadiusbymemberCommand,-5,"w",0,georadiusGetKeys,1,1,1,0,0},
server.c:301:    {"georadiusbymember_ro",georadiusbymemberroCommand,-5,"r",0,georadiusGetKeys,1,1,1,0,0},
server.c:302:    {"geohash",geohashCommand,-2,"r",0,NULL,1,1,1,0,0},
server.c:303:    {"geopos",geoposCommand,-2,"r",0,NULL,1,1,1,0,0},
server.c:304:    {"geodist",geodistCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:305:    {"pfselftest",pfselftestCommand,1,"a",0,NULL,0,0,0,0,0},
server.c:306:    {"pfadd",pfaddCommand,-2,"wmF",0,NULL,1,1,1,0,0},
server.c:307:    {"pfcount",pfcountCommand,-2,"r",0,NULL,1,-1,1,0,0},
server.c:308:    {"pfmerge",pfmergeCommand,-2,"wm",0,NULL,1,-1,1,0,0},
server.c:310:    {"xadd",xaddCommand,-5,"wmFR",0,NULL,1,1,1,0,0},
server.c:311:    {"xrange",xrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:312:    {"xrevrange",xrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
server.c:313:    {"xlen",xlenCommand,2,"rF",0,NULL,1,1,1,0,0},
server.c:314:    {"xread",xreadCommand,-4,"rs",0,xreadGetKeys,1,1,1,0,0},
server.c:315:    {"xreadgroup",xreadCommand,-7,"ws",0,xreadGetKeys,1,1,1,0,0},
server.c:316:    {"xgroup",xgroupCommand,-2,"wm",0,NULL,2,2,1,0,0},
server.c:317:    {"xsetid",xsetidCommand,3,"wmF",0,NULL,1,1,1,0,0},
server.c:318:    {"xack",xackCommand,-4,"wF",0,NULL,1,1,1,0,0},
server.c:319:    {"xpending",xpendingCommand,-3,"rR",0,NULL,1,1,1,0,0},
server.c:320:    {"xclaim",xclaimCommand,-6,"wRF",0,NULL,1,1,1,0,0},
server.c:321:    {"xinfo",xinfoCommand,-2,"rR",0,NULL,2,2,1,0,0},
server.c:322:    {"xdel",xdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
server.c:323:    {"xtrim",xtrimCommand,-2,"wFR",0,NULL,1,1,1,0,0},
server.c:324:    {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
server.c:325:    {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
server.c:327:    {"lolwut",lolwutCommand,-1,"r",0,NULL,0,0,0,0,0}
server.c:364:        snprintf(buf+off,sizeof(buf)-off,"%03d",(int)tv.tv_usec/1000);
server.c:412:    if (fd == -1) return;
server.c:414:    if (write(fd,buf,strlen(buf)) == -1) goto err;
server.c:415:    if (write(fd,":signal-handler (",17) == -1) goto err;
server.c:417:    if (write(fd,buf,strlen(buf)) == -1) goto err;
server.c:418:    if (write(fd,") ",2) == -1) goto err;
server.c:419:    if (write(fd,msg,strlen(msg)) == -1) goto err;
server.c:420:    if (write(fd,"\n",1) == -1) goto err;
server.c:431:    ust = ((long long)tv.tv_sec)*1000000;
server.c:438:    return ustime()/1000;
server.c:471:int dictSdsKeyCompare(void *privdata, const void *key1,
server.c:474:    int l1,l2;
server.c:477:    l1 = sdslen((sds)key1);
server.c:479:    if (l1 != l2) return 0;
server.c:480:    return memcmp(key1, key2, l1) == 0;
server.c:485:int dictSdsKeyCaseCompare(void *privdata, const void *key1,
server.c:490:    return strcasecmp(key1, key2) == 0;
server.c:508:int dictObjKeyCompare(void *privdata, const void *key1,
server.c:511:    const robj *o1 = key1, *o2 = key2;
server.c:512:    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
server.c:528:int dictEncObjKeyCompare(void *privdata, const void *key1,
server.c:531:    robj *o1 = (robj*) key1, *o2 = (robj*) key2;
server.c:534:    if (o1->encoding == OBJ_ENCODING_INT &&
server.c:536:            return o1->ptr == o2->ptr;
server.c:538:    o1 = getDecodedObject(o1);
server.c:540:    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
server.c:541:    decrRefCount(o1);
server.c:673:/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to
server.c:719: * Keys are sds SHA1 strings, while values are not used at all in the current
server.c:736:            (used*100/size < HASHTABLE_MIN_FILL));
server.c:750: * table will use two tables for a long time. So we try to use 1 millisecond
server.c:753: * The function returns 1 if some rehashing was performed, otherwise 0
server.c:758:        dictRehashMilliseconds(server.db[dbid].dict,1);
server.c:759:        return 1; /* already used our millisecond for this loop... */
server.c:763:        dictRehashMilliseconds(server.db[dbid].expires,1);
server.c:764:        return 1; /* already used our millisecond for this loop... */
server.c:776:    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1)
server.c:782:/* ======================= Cron: called every 100 ms ======================== */
server.c:791:    ops_sec = t > 0 ? (ops*1000/t) : 0;
server.c:816:    time_t now = now_ms/1000;
server.c:827:        return 1;
server.c:856:     * 1) Query buffer is > BIG_ARG and too big for latest peak.
server.c:859:         ((querybuf_size/(c->querybuf_peak+1)) > 2 ||
server.c:864:        if (sdsavail(c->querybuf) > 1024*4) {
server.c:879:         * 1) Pending Query buffer is > LIMIT_PENDING_QUERYBUF.
server.c:911:    int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;
server.c:958: * default server.hz value is 10, so sometimes here we need to process thousands
server.c:966:     * process all the clients in 1 second. */
server.c:1018:    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
server.c:1119:    run_with_period(100) {
server.c:1145:    run_with_period(100) {
server.c:1164:            size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;
server.c:1215:    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
server.c:1222:    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
server.c:1234:            if (pid == -1) {
server.c:1283:            server.rdb_child_pid == -1 &&
server.c:1284:            server.aof_child_pid == -1 &&
server.c:1289:                server.aof_rewrite_base_size : 1;
server.c:1290:            long long growth = (server.aof_current_size*100/base) - 100;
server.c:1307:    run_with_period(1000) {
server.c:1320:    run_with_period(1000) replicationCron();
server.c:1323:    run_with_period(100) {
server.c:1331:    run_with_period(1000) {
server.c:1342:    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
server.c:1354:    return 1000/server.hz;
server.c:1381:        argv[1] = createStringObject("GETACK",6);
server.c:1382:        argv[2] = createStringObject("*",1); /* Not used argument. */
server.c:1385:        decrRefCount(argv[1]);
server.c:1433:    shared.cone = createObject(OBJ_STRING,sdsnew(":1\r\n"));
server.c:1434:    shared.cnegone = createObject(OBJ_STRING,sdsnew(":-1\r\n"));
server.c:1435:    shared.nullbulk = createObject(OBJ_STRING,sdsnew("$-1\r\n"));
server.c:1436:    shared.nullmultibulk = createObject(OBJ_STRING,sdsnew("*-1\r\n"));
server.c:1440:    shared.emptyscan = createObject(OBJ_STRING,sdsnew("*2\r\n$1\r\n0\r\n*0\r\n"));
server.c:1487:    shared.messagebulk = createStringObject("$7\r\nmessage\r\n",13);
server.c:1488:    shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
server.c:1489:    shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
server.c:1490:    shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
server.c:1491:    shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
server.c:1492:    shared.punsubscribebulk = createStringObject("$12\r\npunsubscribe\r\n",19);
server.c:1544:    server.sofd = -1;
server.c:1550:    server.active_expire_enabled = 1;
server.c:1577:    server.aof_rewrite_time_last = -1;
server.c:1578:    server.aof_rewrite_time_start = -1;
server.c:1581:    server.aof_fd = -1;
server.c:1582:    server.aof_selected_db = -1; /* Make sure the first time will not match */
server.c:1630:    server.next_client_id = 1; /* Client IDs, start from 1 .*/
server.c:1631:    server.loading_process_events_interval_bytes = (1024*1024*2);
server.c:1642:    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */
server.c:1643:    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */
server.c:1644:    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */
server.c:1652:    server.master_initial_offset = -1;
server.c:1687:    R_PosInf = 1.0/R_Zero;
server.c:1688:    R_NegInf = -1.0/R_Zero;
server.c:1729:    server.lua_always_replicate_commands = 1;
server.c:1754:    if (access(server.executable,X_OK) == -1) {
server.c:1763:        rewriteConfig(server.configfile) == -1)
server.c:1780:    for (j = 3; j < (int)server.maxclients + 1024; j++) {
server.c:1783:        if (fcntl(j,F_GETFD) != -1) close(j);
server.c:1787:    if (delay) usleep(delay*1000);
server.c:1793:    _exit(1);
server.c:1810:    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
server.c:1811:        serverLog(LL_WARNING,"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.",
server.c:1813:        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
server.c:1827:                rlim_t decr_step = 16;
server.c:1831:                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;
server.c:1848:                 * to check if maxclients is now logically less than 1
server.c:1857:                    exit(1);
server.c:1886:    char buf[1024];
server.c:1937:            if (*count == 1 || unsupported) {
server.c:2037:    server.slaveseldb = -1; /* Force to emit the first SELECT command. */
server.c:2052:        exit(1);
server.c:2059:        exit(1);
server.c:2068:            exit(1);
server.c:2076:        exit(1);
server.c:2096:    server.rdb_child_pid = -1;
server.c:2097:    server.aof_child_pid = -1;
server.c:2100:    server.child_info_pipe[0] = -1;
server.c:2101:    server.child_info_pipe[1] = -1;
server.c:2107:    server.rdb_save_time_last = -1;
server.c:2108:    server.rdb_save_time_start = -1;
server.c:2129:    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
server.c:2131:        exit(1);
server.c:2162:        if (server.aof_fd == -1) {
server.c:2165:            exit(1);
server.c:2175:        server.maxmemory = 3072LL*(1024*1024); /* 3 GB */
server.c:2181:    scriptingInit(1);
server.c:2197:        int retval1, retval2;
server.c:2219:        retval1 = dictAdd(server.commands, sdsnew(c->name), c);
server.c:2223:        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
server.c:2254:    oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));
server.c:2397: * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set
server.c:2468:        latencyAddSampleIfNeeded(latency_event,duration/1000);
server.c:2569:        for (i=1; i < c->argc && sdslen(args) < 128; i++)
server.c:2570:            args = sdscatprintf(args, "`%.*s`, ", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
server.c:2593:     * 1) The sender of this command is our master.
server.c:2720:          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
server.c:2723:          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
server.c:2754:    if (server.sofd != -1) close(server.sofd);
server.c:2775:    if (server.rdb_child_pid != -1) {
server.c:2777:        kill(server.rdb_child_pid,SIGUSR1);
server.c:2784:        if (server.aof_child_pid != -1) {
server.c:2793:            kill(server.aof_child_pid,SIGUSR1);
server.c:2797:        flushAppendOnlyFile(1);
server.c:2829:    closeListeningSockets(1);
server.c:2868: * Note that limiting the comparison length to strings up to 512 bytes we
server.c:2886:    if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;
server.c:2908:    } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
server.c:2909:      c->authenticated = 1;
server.c:2930:        if (c->argc == 1)
server.c:2933:            addReplyBulk(c,c->argv[1]);
server.c:2935:        if (c->argc == 1)
server.c:2938:            addReplyBulk(c,c->argv[1]);
server.c:2943:    addReplyBulk(c,c->argv[1]);
server.c:2961:        return 1;
server.c:2995:            flagcount += 1;
server.c:3010:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
server.c:3019:    } else if (c->argc == 1) {
server.c:3026:    } else if (!strcasecmp(c->argv[1]->ptr, "info")) {
server.c:3032:    } else if (!strcasecmp(c->argv[1]->ptr, "count") && c->argc == 2) {
server.c:3034:    } else if (!strcasecmp(c->argv[1]->ptr,"getkeys") && c->argc >= 3) {
server.c:3065: * of 100B, 2G, 100M, 4K, and so forth. */
server.c:3069:    if (n < 1024) {
server.c:3072:    } else if (n < (1024*1024)) {
server.c:3073:        d = (double)n/(1024);
server.c:3075:    } else if (n < (1024LL*1024*1024)) {
server.c:3076:        d = (double)n/(1024*1024);
server.c:3078:    } else if (n < (1024LL*1024*1024*1024)) {
server.c:3079:        d = (double)n/(1024LL*1024*1024);
server.c:3081:    } else if (n < (1024LL*1024*1024*1024*1024)) {
server.c:3082:        d = (double)n/(1024LL*1024*1024*1024);
server.c:3084:    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
server.c:3085:        d = (double)n/(1024LL*1024*1024*1024*1024);
server.c:3113:        static int call_uname = 1;
server.c:3134:            "redis_git_sha1:%s\r\n"
server.c:3154:            redisGitSHA1(),
server.c:3155:            strtol(redisGitDirty(),NULL,10) > 0,
server.c:3207:        long long memory_lua = (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;
server.c:3335:            server.rdb_child_pid != -1,
server.c:3339:            (intmax_t)((server.rdb_child_pid == -1) ?
server.c:3340:                -1 : time(NULL)-server.rdb_save_time_start),
server.c:3343:            server.aof_child_pid != -1,
server.c:3346:            (intmax_t)((server.aof_child_pid == -1) ?
server.c:3347:                -1 : time(NULL)-server.aof_rewrite_time_start),
server.c:3377:                   (server.loading_total_bytes+1)) * 100;
server.c:3381:                eta = 1; /* A fake 1 second figure if we don't have
server.c:3384:                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);
server.c:3438:            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,
server.c:3439:            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,
server.c:3445:            server.stat_expired_stale_perc*100,
server.c:3469:            long long slave_repl_offset = 1;
server.c:3488:                ((int)(server.unixtime-server.master->lastinteraction)) : -1,
server.c:3542:                    if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) == -1)
server.c:3653:    char *section = c->argc == 2 ? c->argv[1]->ptr : "default";
server.c:3678:    if (!fp) return -1;
server.c:3681:        return -1;
server.c:3690:        serverLog(LL_WARNING,"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.");
server.c:3720:    if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
server.c:3731:        redisGitSHA1(),
server.c:3749:    fprintf(stderr,"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n");
server.c:3753:    exit(1);
server.c:3758:    char *buf = zmalloc(1024*16);
server.c:3779:        snprintf(buf,1024*16,ascii_logo,
server.c:3781:            redisGitSHA1(),
server.c:3782:            strtol(redisGitDirty(),NULL,10) > 0,
server.c:3813:        exit(1); /* Exit with an error since this was not a clean shutdown. */
server.c:3820:    server.shutdown_asap = 1;
server.c:3848:/* Returns 1 if there is --sentinel among the arguments or if
server.c:3853:    if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
server.c:3854:    for (j = 1; j < argc; j++)
server.c:3855:        if (!strcmp(argv[j],"--sentinel")) return 1;
server.c:3864:            serverLog(LL_NOTICE,"DB loaded from append only file: %.3f seconds",(float)(ustime()-start)/1000000);
server.c:3869:                (float)(ustime()-start)/1000000);
server.c:3874:                rsi.repl_offset != -1 &&
server.c:3876:                 * of -1 inside the RDB file in a wrong way, see more information
server.c:3878:                rsi.repl_stream_db != -1)
server.c:3890:            exit(1);
server.c:3933:    return 1;
server.c:3938:    int fd = 1;
server.c:3955:    if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
server.c:3963:    strncpy (su.sun_path, notify_socket, sizeof(su.sun_path) -1);
server.c:3964:    su.sun_path[sizeof(su.sun_path) - 1] = '\0';
server.c:3970:    iov.iov_base = "READY=1";
server.c:3971:    iov.iov_len = strlen("READY=1");
server.c:3978:    hdr.msg_iovlen = 1;
server.c:3990:    return 1;
server.c:4018:    if (argc == 3 && !strcasecmp(argv[1], "test")) {
server.c:4027:        } else if (!strcasecmp(argv[2], "sha1test")) {
server.c:4028:            return sha1Test(argc, argv);
server.c:4039:        return -1; /* test not found */
server.c:4053:    char hashseed[16];
server.c:4063:    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));
server.c:4085:        j = 1; /* First option to parse in argv[] */
server.c:4090:        if (strcmp(argv[1], "-v") == 0 ||
server.c:4091:            strcmp(argv[1], "--version") == 0) version();
server.c:4092:        if (strcmp(argv[1], "--help") == 0 ||
server.c:4093:            strcmp(argv[1], "-h") == 0) usage();
server.c:4094:        if (strcmp(argv[1], "--test-memory") == 0) {
server.c:4101:                exit(1);
server.c:4106:        if (argv[j][0] != '-' || argv[j][1] != '-') {
server.c:4121:            if (argv[j][0] == '-' && argv[j][1] == '-') {
server.c:4143:            exit(1);
server.c:4155:            redisGitSHA1(),
server.c:4156:            strtol(redisGitDirty(),NULL,10) > 0,
server.c:4159:    if (argc == 1) {
server.c:4188:                exit(1);
server.c:4200:    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
server.c:4201:        serverLog(LL_WARNING,"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?", server.maxmemory);
server.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
server.h:72:#include "sha1.h"
server.h:78:#define C_ERR                   -1
server.h:81:#define CONFIG_DEFAULT_DYNAMIC_HZ 1             /* Adapt hz to # of clients.*/
server.h:82:#define CONFIG_DEFAULT_HZ        10             /* Time interrupt calls/sec. */
server.h:83:#define CONFIG_MIN_HZ            1
server.h:87:#define CONFIG_DEFAULT_TCP_BACKLOG       511    /* TCP listen backlog. */
server.h:89:#define CONFIG_DEFAULT_DBNUM     16
server.h:90:#define CONFIG_MAX_LINE    1024
server.h:91:#define CRON_DBS_PER_CALL 16
server.h:92:#define NET_MAX_WRITES_PER_EVENT (1024*64)
server.h:93:#define PROTO_SHARED_SELECT_CMDS 10
server.h:94:#define OBJ_SHARED_INTEGERS 10000
server.h:96:#define LOG_MAX_LEN    1024 /* Default maximum length of syslog messages.*/
server.h:97:#define AOF_REWRITE_PERC  100
server.h:98:#define AOF_REWRITE_MIN_SIZE (64*1024*1024)
server.h:100:#define AOF_READ_DIFF_INTERVAL_BYTES (1024*10)
server.h:101:#define CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN 10000
server.h:102:#define CONFIG_DEFAULT_SLOWLOG_MAX_LEN 128
server.h:103:#define CONFIG_DEFAULT_MAX_CLIENTS 10000
server.h:104:#define CONFIG_AUTHPASS_MAX_LEN 512
server.h:105:#define CONFIG_DEFAULT_SLAVE_PRIORITY 100
server.h:107:#define CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD 10
server.h:110:#define CONFIG_DEFAULT_REPL_BACKLOG_SIZE (1024*1024)    /* 1mb */
server.h:111:#define CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT (60*60)  /* 1 hour */
server.h:112:#define CONFIG_REPL_BACKLOG_MIN_SIZE (1024*16)          /* 16k */
server.h:119:#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT 0      /* Use +10000 offset. */
server.h:123:#define CONFIG_DEFAULT_PROTECTED_MODE 1
server.h:126:#define CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR 1
server.h:127:#define CONFIG_DEFAULT_RDB_COMPRESSION 1
server.h:128:#define CONFIG_DEFAULT_RDB_CHECKSUM 1
server.h:132:#define CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA 1
server.h:133:#define CONFIG_DEFAULT_SLAVE_READ_ONLY 1
server.h:134:#define CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY 1
server.h:140:#define CONFIG_DEFAULT_LFU_LOG_FACTOR 10
server.h:141:#define CONFIG_DEFAULT_LFU_DECAY_TIME 1
server.h:144:#define CONFIG_DEFAULT_AOF_LOAD_TRUNCATED 1
server.h:145:#define CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE 1
server.h:146:#define CONFIG_DEFAULT_ACTIVE_REHASHING 1
server.h:147:#define CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC 1
server.h:148:#define CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC 1
server.h:150:#define CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG 10
server.h:153:#define CONFIG_BINDADDR_MAX 16
server.h:162:#define CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER 10 /* don't defrag when fragmentation is below 10% */
server.h:163:#define CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER 100 /* maximum defrag force at 100% fragmentation */
server.h:164:#define CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES (100<<20) /* don't defrag if frag overhead is below 100mb */
server.h:167:#define CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS 1000 /* keys with more than 1000 fields will be processed separately */
server.h:168:#define CONFIG_DEFAULT_PROTO_MAX_BULK_LEN (512ll*1024*1024) /* Bulk request max size */
server.h:171:#define ACTIVE_EXPIRE_CYCLE_FAST_DURATION 1000 /* Microseconds */
server.h:174:#define ACTIVE_EXPIRE_CYCLE_FAST 1
server.h:177:#define STATS_METRIC_SAMPLES 16     /* Number of samples per metric. */
server.h:179:#define STATS_METRIC_NET_INPUT 1    /* Bytes read to network .*/
server.h:184:#define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */
server.h:185:#define PROTO_IOBUF_LEN         (1024*16)  /* Generic I/O buffer size */
server.h:186:#define PROTO_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */
server.h:187:#define PROTO_INLINE_MAX_SIZE   (1024*64) /* Max size of inline reads */
server.h:188:#define PROTO_MBULK_BIG_ARG     (1024*32)
server.h:189:#define LONG_STR_SIZE      21          /* Bytes needed for long -> str + '\0' */
server.h:190:#define REDIS_AUTOSYNC_BYTES (1024*1024*32) /* fdatasync every 32MB */
server.h:192:#define LIMIT_PENDING_QUERYBUF (4*1024*1024) /* 4mb */
server.h:197: * in order to make sure of not over provisioning more than 128 fds. */
server.h:201:#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */
server.h:205:#define CMD_WRITE (1<<0)            /* "w" flag */
server.h:206:#define CMD_READONLY (1<<1)         /* "r" flag */
server.h:207:#define CMD_DENYOOM (1<<2)          /* "m" flag */
server.h:208:#define CMD_MODULE (1<<3)           /* Command exported by module. */
server.h:209:#define CMD_ADMIN (1<<4)            /* "a" flag */
server.h:210:#define CMD_PUBSUB (1<<5)           /* "p" flag */
server.h:211:#define CMD_NOSCRIPT (1<<6)         /* "s" flag */
server.h:212:#define CMD_RANDOM (1<<7)           /* "R" flag */
server.h:213:#define CMD_SORT_FOR_SCRIPT (1<<8)  /* "S" flag */
server.h:214:#define CMD_LOADING (1<<9)          /* "l" flag */
server.h:215:#define CMD_STALE (1<<10)           /* "t" flag */
server.h:216:#define CMD_SKIP_MONITOR (1<<11)    /* "M" flag */
server.h:217:#define CMD_ASKING (1<<12)          /* "k" flag */
server.h:218:#define CMD_FAST (1<<13)            /* "F" flag */
server.h:219:#define CMD_MODULE_GETKEYS (1<<14)  /* Use the modules getkeys interface. */
server.h:220:#define CMD_MODULE_NO_CLUSTER (1<<15) /* Deny on Redis Cluster. */
server.h:224:#define AOF_ON 1              /* AOF is on */
server.h:228:#define CLIENT_SLAVE (1<<0)   /* This client is a slave server */
server.h:229:#define CLIENT_MASTER (1<<1)  /* This client is a master server */
server.h:230:#define CLIENT_MONITOR (1<<2) /* This client is a slave monitor, see MONITOR */
server.h:231:#define CLIENT_MULTI (1<<3)   /* This client is in a MULTI context */
server.h:232:#define CLIENT_BLOCKED (1<<4) /* The client is waiting in a blocking operation */
server.h:233:#define CLIENT_DIRTY_CAS (1<<5) /* Watched keys modified. EXEC will fail. */
server.h:234:#define CLIENT_CLOSE_AFTER_REPLY (1<<6) /* Close after writing entire reply. */
server.h:235:#define CLIENT_UNBLOCKED (1<<7) /* This client was unblocked and is stored in
server.h:237:#define CLIENT_LUA (1<<8) /* This is a non connected client used by Lua */
server.h:238:#define CLIENT_ASKING (1<<9)     /* Client issued the ASKING command */
server.h:239:#define CLIENT_CLOSE_ASAP (1<<10)/* Close this client ASAP */
server.h:240:#define CLIENT_UNIX_SOCKET (1<<11) /* Client connected via Unix domain socket */
server.h:241:#define CLIENT_DIRTY_EXEC (1<<12)  /* EXEC will fail for errors while queueing */
server.h:242:#define CLIENT_MASTER_FORCE_REPLY (1<<13)  /* Queue replies even if is master */
server.h:243:#define CLIENT_FORCE_AOF (1<<14)   /* Force AOF propagation of current cmd. */
server.h:244:#define CLIENT_FORCE_REPL (1<<15)  /* Force replication of current cmd. */
server.h:245:#define CLIENT_PRE_PSYNC (1<<16)   /* Instance don't understand PSYNC. */
server.h:246:#define CLIENT_READONLY (1<<17)    /* Cluster client is in read-only state. */
server.h:247:#define CLIENT_PUBSUB (1<<18)      /* Client is in Pub/Sub mode. */
server.h:248:#define CLIENT_PREVENT_AOF_PROP (1<<19)  /* Don't propagate to AOF. */
server.h:249:#define CLIENT_PREVENT_REPL_PROP (1<<20)  /* Don't propagate to slaves. */
server.h:251:#define CLIENT_PENDING_WRITE (1<<21) /* Client has output to send but a write
server.h:253:#define CLIENT_REPLY_OFF (1<<22)   /* Don't send replies to client. */
server.h:254:#define CLIENT_REPLY_SKIP_NEXT (1<<23)  /* Set CLIENT_REPLY_SKIP for next cmd */
server.h:255:#define CLIENT_REPLY_SKIP (1<<24)  /* Don't send just this reply. */
server.h:256:#define CLIENT_LUA_DEBUG (1<<25)  /* Run EVAL in debug mode. */
server.h:257:#define CLIENT_LUA_DEBUG_SYNC (1<<26)  /* EVAL debugging without fork() */
server.h:258:#define CLIENT_MODULE (1<<27) /* Non connected client used by some module. */
server.h:259:#define CLIENT_PROTECTED (1<<28) /* Client should not be freed for now. */
server.h:264:#define BLOCKED_LIST 1    /* BLPOP & co. */
server.h:272:#define PROTO_REQ_INLINE 1
server.h:278:#define CLIENT_TYPE_SLAVE 1  /* Slaves. */
server.h:288:#define REPL_STATE_CONNECT 1 /* Must connect to master */
server.h:298:#define REPL_STATE_SEND_CAPA 10 /* Send REPLCONF capa */
server.h:299:#define REPL_STATE_RECEIVE_CAPA 11 /* Wait for REPLCONF reply */
server.h:300:#define REPL_STATE_SEND_PSYNC 12 /* Send PSYNC */
server.h:301:#define REPL_STATE_RECEIVE_PSYNC 13 /* Wait for PSYNC reply */
server.h:303:#define REPL_STATE_TRANSFER 14 /* Receiving .rdb from master */
server.h:304:#define REPL_STATE_CONNECTED 15 /* Connected to master */
server.h:317:#define SLAVE_CAPA_EOF (1<<0)    /* Can parse the RDB EOF streaming format. */
server.h:318:#define SLAVE_CAPA_PSYNC2 (1<<1) /* Supports PSYNC2 protocol. */
server.h:325:#define LIST_TAIL 1
server.h:327:#define ZSET_MAX 1
server.h:334:#define LL_VERBOSE 1
server.h:337:#define LL_RAW (1<<10) /* Modifier to log without timestamp */
server.h:342:#define SUPERVISED_AUTODETECT 1
server.h:350:#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */
server.h:354:#define AOF_FSYNC_ALWAYS 1
server.h:359:#define OBJ_HASH_MAX_ZIPLIST_ENTRIES 512
server.h:361:#define OBJ_SET_MAX_INTSET_ENTRIES 512
server.h:362:#define OBJ_ZSET_MAX_ZIPLIST_ENTRIES 128
server.h:365:#define OBJ_STREAM_NODE_MAX_ENTRIES 100
server.h:376:#define SET_OP_DIFF 1
server.h:382:#define MAXMEMORY_FLAG_LRU (1<<0)
server.h:383:#define MAXMEMORY_FLAG_LFU (1<<1)
server.h:384:#define MAXMEMORY_FLAG_ALLKEYS (1<<2)
server.h:389:#define MAXMEMORY_VOLATILE_LFU ((1<<8)|MAXMEMORY_FLAG_LFU)
server.h:404:#define UNIT_MILLISECONDS 1
server.h:408:#define SHUTDOWN_SAVE 1         /* Force SAVE on SHUTDOWN even if no save
server.h:414:#define CMD_CALL_SLOWLOG (1<<0)
server.h:415:#define CMD_CALL_STATS (1<<1)
server.h:416:#define CMD_CALL_PROPAGATE_AOF (1<<2)
server.h:417:#define CMD_CALL_PROPAGATE_REPL (1<<3)
server.h:423:#define PROPAGATE_AOF 1
server.h:428:#define RDB_CHILD_TYPE_DISK 1     /* RDB is written to disk. */
server.h:433:#define NOTIFY_KEYSPACE (1<<0)    /* K */
server.h:434:#define NOTIFY_KEYEVENT (1<<1)    /* E */
server.h:435:#define NOTIFY_GENERIC (1<<2)     /* g */
server.h:436:#define NOTIFY_STRING (1<<3)      /* $ */
server.h:437:#define NOTIFY_LIST (1<<4)        /* l */
server.h:438:#define NOTIFY_SET (1<<5)         /* s */
server.h:439:#define NOTIFY_HASH (1<<6)        /* h */
server.h:440:#define NOTIFY_ZSET (1<<7)        /* z */
server.h:441:#define NOTIFY_EXPIRED (1<<8)     /* x */
server.h:442:#define NOTIFY_EVICTED (1<<9)     /* e */
server.h:443:#define NOTIFY_STREAM (1<<10)     /* t */
server.h:452:#define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
server.h:455:#define serverAssertWithInfo(_c,_o,_e) ((_e)?(void)0 : (_serverAssertWithInfo(_c,_o,#_e,__FILE__,__LINE__),_exit(1)))
server.h:456:#define serverAssert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
server.h:457:#define serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)
server.h:467:#define OBJ_LIST 1      /* List object. */
server.h:481: * in order to dispatch the loading to the right module, plus a 10 bits
server.h:487:#define REDISMODULE_TYPE_ENCVER_BITS 10
server.h:488:#define REDISMODULE_TYPE_ENCVER_MASK ((1<<REDISMODULE_TYPE_ENCVER_BITS)-1)
server.h:512:    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
server.h:520:    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
server.h:551:    int ver;            /* Module serialization version: 1 (old),
server.h:589:#define OBJ_ENCODING_INT 1     /* Encoded as integer */
server.h:598:#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
server.h:601:#define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) /* Max value of obj->lru */
server.h:602:#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */
server.h:610:                            * and most significant 16 bits access time). */
server.h:620:    _var.refcount = 1; \
server.h:725:    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
server.h:754:    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */
server.h:901:    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
server.h:905:#define RDB_SAVE_INFO_INIT {-1,0,"000000000000000000000000000000",-1}
server.h:927:#define CHILD_INFO_MAGIC 0xC17DDA7A12345678LL
server.h:929:#define CHILD_INFO_TYPE_AOF 1
server.h:954:    char runid[CONFIG_RUN_ID_SIZE+1];  /* ID always different at every exec. */
server.h:1055:    int supervised;                 /* 1 if supervised, 0 otherwise. */
server.h:1131:    char replid[CONFIG_RUN_ID_SIZE+1];  /* My current replication ID. */
server.h:1132:    char replid2[CONFIG_RUN_ID_SIZE+1]; /* replid inherited from master*/
server.h:1138:    long long repl_backlog_size;    /* Backlog circular buffer size 固定大小最小16k*/
server.h:1180:    char master_replid[CONFIG_RUN_ID_SIZE+1];  /* Master PSYNC runid. */
server.h:1184:    dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */
server.h:1253:    dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */
server.h:1370:#define OBJ_HASH_KEY 1
server.h:1595:void replicationScriptCacheAdd(sds sha1);
server.h:1596:int replicationScriptCacheExists(sds sha1);
server.h:1616:#define DISK_ERROR_TYPE_AOF 1       /* Don't accept writes: AOF errors. */
server.h:1648:#define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */
server.h:1649:#define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */
server.h:1650:#define ZADD_XX (1<<2)      /* Only touch elements already existing. */
server.h:1653:#define ZADD_NOP (1<<3)     /* Operation not performed because of conditionals.*/
server.h:1654:#define ZADD_NAN (1<<4)     /* Only touch elements already existing. */
server.h:1655:#define ZADD_ADDED (1<<5)   /* The element was new and was added. */
server.h:1656:#define ZADD_UPDATED (1<<6) /* The element already existed, score updated. */
server.h:1659:#define ZADD_CH (1<<16)      /* Return num of elements added or updated. */
server.h:1751:#define RESTART_SERVER_GRACEFULLY (1<<0)     /* Do proper shutdown. */
server.h:1752:#define RESTART_SERVER_CONFIG_REWRITE (1<<1) /* CONFIG REWRITE before restart.*/
server.h:1770:#define HASH_SET_TAKE_FIELD (1<<0)
server.h:1771:#define HASH_SET_TAKE_VALUE (1<<1)
server.h:1776:void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);
server.h:1831:#define LOOKUP_NOTOUCH (1<<0)
server.h:1842:#define EMPTYDB_ASYNC (1<<0)    /* Reclaim memory in another thread. */
server.h:1875:unsigned short crc16(const char *buf, int len);
server.h:1930:int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
server.h:1933:/* Git SHA1 */
server.h:1934:char *redisGitSHA1(void);
setproctitle.c:4: * Copyright (C) 2010  William Ahern
setproctitle.c:5: * Copyright (C) 2013  Salvatore Sanfilippo
setproctitle.c:6: * Copyright (C) 2013  Stam He
setproctitle.c:43:#define HAVE_SETPROCTITLE 1
setproctitle.c:81: * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html
setproctitle.c:119:		error = (0 != setenv(oldenv[i], eq + 1, 1))? errno : 0;
setproctitle.c:138:	for (i = 1; i < argc || (i >= argc && argv[i]); i++) {
setproctitle.c:161:	end = nul + 1;
setproctitle.c:167:		end = argv[i] + strlen(argv[i]) + 1;
setproctitle.c:174:		end = envp[i] + strlen(envp[i]) + 1;
setproctitle.c:221:	char buf[SPT_MAXTITLE + 1]; /* use buffer in case argv[0] is passed */
setproctitle.c:242:		SPT.reset = 1;
setproctitle.c:247:	len = spt_min(len, spt_min(sizeof buf, SPT.end - SPT.base) - 1);
setproctitle.c:253:	} else if (nul == SPT.nul && &nul[1] < SPT.end) {
sha1.c:4:/* ================ sha1.c ================ */
sha1.c:6:SHA-1 in C
sha1.c:8:100% Public Domain
sha1.c:10:Test Vectors (from FIPS PUB 180-1)
sha1.c:12:  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
sha1.c:14:  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
sha1.c:16:  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
sha1.c:20:/* #define SHA1HANDSOFF * Copies data before messing with it. */
sha1.c:22:#define SHA1HANDSOFF
sha1.c:28:#include "sha1.h"
sha1.c:43:#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
sha1.c:44:    ^block->l[(i+2)&15]^block->l[i&15],1))
sha1.c:46:/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
sha1.c:48:#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
sha1.c:49:#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
sha1.c:50:#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
sha1.c:51:#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
sha1.c:54:/* Hash a single 512-bit block. This is the core of the algorithm. */
sha1.c:56:void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
sha1.c:61:        uint32_t l[16];
sha1.c:62:    } CHAR64LONG16;
sha1.c:63:#ifdef SHA1HANDSOFF
sha1.c:64:    CHAR64LONG16 block[1];  /* use array to appear as a pointer */
sha1.c:72:    CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
sha1.c:76:    b = state[1];
sha1.c:81:    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
sha1.c:83:    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
sha1.c:84:    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
sha1.c:85:    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
sha1.c:86:    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
sha1.c:88:    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
sha1.c:91:    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
sha1.c:93:    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
sha1.c:96:    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
sha1.c:98:    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
sha1.c:103:    state[1] += b;
sha1.c:109:#ifdef SHA1HANDSOFF
sha1.c:115:/* SHA1Init - Initialize new context */
sha1.c:117:void SHA1Init(SHA1_CTX* context)
sha1.c:119:    /* SHA1 initialization constants */
sha1.c:120:    context->state[0] = 0x67452301;
sha1.c:121:    context->state[1] = 0xEFCDAB89;
sha1.c:123:    context->state[3] = 0x10325476;
sha1.c:124:    context->state[4] = 0xC3D2E1F0;
sha1.c:125:    context->count[0] = context->count[1] = 0;
sha1.c:131:void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
sha1.c:137:        context->count[1]++;
sha1.c:138:    context->count[1] += (len>>29);
sha1.c:142:        SHA1Transform(context->state, context->buffer);
sha1.c:144:            SHA1Transform(context->state, &data[i]);
sha1.c:155:void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
sha1.c:179:        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
sha1.c:184:    SHA1Update(context, &c, 1);
sha1.c:187:        SHA1Update(context, &c, 1);
sha1.c:189:    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
sha1.c:198:/* ================ end of sha1.c ================ */
sha1.c:204:int sha1Test(int argc, char **argv)
sha1.c:206:    SHA1_CTX ctx;
sha1.c:216:    SHA1Init(&ctx);
sha1.c:217:    for(i=0;i<1000;i++)
sha1.c:218:        SHA1Update(&ctx, buf, BUFSIZE);
sha1.c:219:    SHA1Final(hash, &ctx);
sha1.c:221:    printf("SHA1=");
sha1.h:1:#ifndef SHA1_H
sha1.h:2:#define SHA1_H
sha1.h:3:/* ================ sha1.h ================ */
sha1.h:5:SHA-1 in C
sha1.h:7:100% Public Domain
sha1.h:14:} SHA1_CTX;
sha1.h:16:void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);
sha1.h:17:void SHA1Init(SHA1_CTX* context);
sha1.h:18:void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len);
sha1.h:19:void SHA1Final(unsigned char digest[20], SHA1_CTX* context);
sha1.h:22:int sha1Test(int argc, char **argv);
siphash.c:4:   Copyright (c) 2012-2016 Jean-Philippe Aumasson
siphash.c:6:   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>
siphash.c:7:   Copyright (c) 2017 Salvatore Sanfilippo <antirez@gmail.com>
siphash.c:15:   <http://creativecommons.org/publicdomain/zero/1.0/>.
siphash.c:22:   1. We use SipHash 1-2. This is not believed to be as strong as the
siphash.c:32:      and the 16 bytes output code handling was removed.
siphash.c:69:    (p)[1] = (uint8_t)((v) >> 8);                                              \
siphash.c:70:    (p)[2] = (uint8_t)((v) >> 16);                                             \
siphash.c:81:    (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
siphash.c:82:     ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
siphash.c:89:     ((uint64_t)(siptlw((p)[1])) << 8) |                                      \
siphash.c:90:     ((uint64_t)(siptlw((p)[2])) << 16) |                                     \
siphash.c:99:        v0 += v1;                                                              \
siphash.c:100:        v1 = ROTL(v1, 13);                                                     \
siphash.c:101:        v1 ^= v0;                                                              \
siphash.c:104:        v3 = ROTL(v3, 16);                                                     \
siphash.c:107:        v3 = ROTL(v3, 21);                                                     \
siphash.c:109:        v2 += v1;                                                              \
siphash.c:110:        v1 = ROTL(v1, 17);                                                     \
siphash.c:111:        v1 ^= v2;                                                              \
siphash.c:121:    uint64_t v1 = 0x646f72616e646f6dULL;
siphash.c:122:    uint64_t v2 = 0x6c7967656e657261ULL;
siphash.c:125:    uint64_t k1 = U8TO64_LE(k + 8);
siphash.c:130:    v3 ^= k1;
siphash.c:132:    v1 ^= k1;
siphash.c:149:    case 3: b |= ((uint64_t)in[2]) << 16; /* fall-thru */
siphash.c:150:    case 2: b |= ((uint64_t)in[1]) << 8; /* fall-thru */
siphash.c:151:    case 1: b |= ((uint64_t)in[0]); break;
siphash.c:165:    b = v0 ^ v1 ^ v2 ^ v3;
siphash.c:181:    uint64_t v1 = 0x646f72616e646f6dULL;
siphash.c:182:    uint64_t v2 = 0x6c7967656e657261ULL;
siphash.c:185:    uint64_t k1 = U8TO64_LE(k + 8);
siphash.c:190:    v3 ^= k1;
siphash.c:192:    v1 ^= k1;
siphash.c:209:    case 3: b |= ((uint64_t)siptlw(in[2])) << 16; /* fall-thru */
siphash.c:210:    case 2: b |= ((uint64_t)siptlw(in[1])) << 8; /* fall-thru */
siphash.c:211:    case 1: b |= ((uint64_t)siptlw(in[0])); break;
siphash.c:225:    b = v0 ^ v1 ^ v2 ^ v3;
siphash.c:240:    { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
siphash.c:244:    { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
siphash.c:245:    { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
siphash.c:247:    { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
siphash.c:252:    { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
siphash.c:253:    { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
siphash.c:255:    { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
siphash.c:258:    { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
siphash.c:259:    { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
siphash.c:260:    { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
siphash.c:265:    { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
siphash.c:266:    { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
siphash.c:267:    { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
siphash.c:268:    { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
siphash.c:269:    { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
siphash.c:271:    { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
siphash.c:272:    { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
siphash.c:274:    { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
siphash.c:275:    { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
siphash.c:276:    { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
siphash.c:277:    { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
siphash.c:282:    { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
siphash.c:284:    { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
siphash.c:285:    { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
siphash.c:286:    { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
siphash.c:288:    { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
siphash.c:291:    { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
siphash.c:293:    { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
siphash.c:295:    { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
siphash.c:297:    { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
siphash.c:298:    { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
siphash.c:300:    { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
siphash.c:301:    { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
siphash.c:302:    { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
siphash.c:308: * all the tests, otherwise 1 is returned.
siphash.c:312: * now it uses 1-2 rounds. */
siphash.c:314:    uint8_t in[64], k[16];
siphash.c:318:    for (i = 0; i < 16; ++i)
siphash.c:333:    uint64_t h1, h2;
siphash.c:334:    h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
siphash.c:335:    h2 = siphash_nocase((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
siphash.c:336:    if (h1 != h2) fails++;
siphash.c:338:    h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
siphash.c:339:    h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
siphash.c:340:    if (h1 != h2) fails++;
siphash.c:342:    h1 = siphash((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
siphash.c:343:    h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
siphash.c:344:    if (h1 == h2) fails++;
siphash.c:347:    return 1;
siphash.c:356:        return 1;
slowlog.c:13: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
slowlog.c:59:        if (slargc != argc && j == slargc-1) {
slowlog.c:62:                argc-slargc+1));
slowlog.c:148:    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
slowlog.c:150:"GET [count] -- Return top entries from the slowlog (default: 10)."
slowlog.c:158:    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"reset")) {
slowlog.c:161:    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"len")) {
slowlog.c:164:               !strcasecmp(c->argv[1]->ptr,"get"))
slowlog.c:166:        long count = 10, sent = 0;
slowlog.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
slowlog.h:31:#define SLOWLOG_ENTRY_MAX_STRING 128
solarisfixes.h:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
solarisfixes.h:43:     __builtin_expect(!isnan(__x_f - __x_f), 1); })
sort.c:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
sort.c:48: * 1) The first occurrence of '*' in 'pattern' is substituted with 'subst'.
sort.c:59: * The returned object will always have its refcount increased by 1
sort.c:71:    if (spat[0] == '#' && spat[1] == '\0') {
sort.c:91:    if ((f = strstr(p+1, "->")) != NULL && *(f+2) != '\0') {
sort.c:102:    postfixlen = sdslen(spat)-(prefixlen+1)-(fieldlen ? fieldlen+2 : 0);
sort.c:107:    memcpy(k+prefixlen+sublen,p+1,postfixlen);
sort.c:142:int sortCompare(const void *s1, const void *s2) {
sort.c:143:    const redisSortObject *so1 = s1, *so2 = s2;
sort.c:148:        if (so1->u.score > so2->u.score) {
sort.c:149:            cmp = 1;
sort.c:150:        } else if (so1->u.score < so2->u.score) {
sort.c:151:            cmp = -1;
sort.c:156:            cmp = compareStringObjects(so1->obj,so2->obj);
sort.c:161:            if (!so1->u.cmpobj || !so2->u.cmpobj) {
sort.c:163:                if (so1->u.cmpobj == so2->u.cmpobj)
sort.c:165:                else if (so1->u.cmpobj == NULL)
sort.c:166:                    cmp = -1;
sort.c:168:                    cmp = 1;
sort.c:172:                    cmp = compareStringObjects(so1->u.cmpobj,so2->u.cmpobj);
sort.c:176:                    cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);
sort.c:182:                cmp = compareStringObjects(so1->obj,so2->obj);
sort.c:184:                cmp = collateStringObjects(so1->obj,so2->obj);
sort.c:197:    long limit_start = 0, limit_count = -1, start, end;
sort.c:206:    sortval = lookupKeyRead(c->db,c->argv[1]);
sort.c:231:        int leftargs = c->argc-j-1;
sort.c:235:            desc = 1;
sort.c:237:            alpha = 1;
sort.c:239:            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)
sort.c:248:        } else if (!strcasecmp(c->argv[j]->ptr,"store") && leftargs >= 1) {
sort.c:249:            storekey = c->argv[j+1];
sort.c:251:        } else if (!strcasecmp(c->argv[j]->ptr,"by") && leftargs >= 1) {
sort.c:252:            sortby = c->argv[j+1];
sort.c:255:            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {
sort.c:256:                dontsort = 1;
sort.c:267:        } else if (!strcasecmp(c->argv[j]->ptr,"get") && leftargs >= 1) {
sort.c:274:                SORT_OP_GET,c->argv[j+1]));
sort.c:304:        alpha = 1;
sort.c:322:    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;
sort.c:324:        start = vectorlen-1;
sort.c:327:    if (end >= vectorlen) end = vectorlen-1;
sort.c:332:     * 1) The object to sort is a sorted set or a list (internally sorted).
sort.c:341:        (start != 0 || end != vectorlen-1))
sort.c:343:        vectorlen = end-start+1;
sort.c:361:                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,
sort.c:419:                ln = zslGetElementByRank(zsl,start+1);
sort.c:476:                        int_conversion_error = 1;
sort.c:484:                    serverAssertWithInfo(c,sortval,1 != 1);
sort.c:497:        server.sort_bypattern = sortby ? 1 : 0;
sort.c:498:        server.sort_store = storekey ? 1 : 0;
sort.c:499:        if (sortby && (start != 0 || end != vectorlen-1))
sort.c:507:    outputlen = getop ? getop*(end-start+1) : end-start+1;
sparkline.c:8: * Copyright(C) 2011-2014 Salvatore Sanfilippo <antirez@gmail.com>
sparkline.c:41:static int charset_len = sizeof(charset)-1;
sparkline.c:42:static int label_margin_top = 1;
sparkline.c:49: * sparklineSequenceAddSample(seq, 10, NULL);
sparkline.c:73:    seq->samples = zrealloc(seq->samples,sizeof(struct sample)*(seq->length+1));
sparkline.c:103:    int loop = 1;
sparkline.c:108:        relmax = log(relmax+1);
sparkline.c:110:        relmax = 1;
sparkline.c:121:            if (opt_log) relval = log(relval+1);
sparkline.c:124:            if (step >= steps) step = steps-1;
sparkline.c:128:                int charidx = step-((rows-row-1)*charset_len);
sparkline.c:129:                loop = 1;
sparkline.c:139:                    loop = 1;
sparkline.c:148:                        loop = 1;
sparkline.c:157:            output = sdscatlen(output,"\n",1);
sparkline.c:171:        if (j != 0) output = sdscatlen(output,"\n",1);
sparkline.h:5: * Copyright(C) 2011-2014 Salvatore Sanfilippo <antirez@gmail.com>
sparkline.h:47:#define SPARKLINE_FILL 1      /* Fill the area under the curve. */
stream.h:7:/* Stream item ID: a 128 bit number composed of a milliseconds time and
stream.h:36:    int rev;                /* 1表示从后往前。0表示从前往后遍历 && True if iterating end to start (reverse). */
stream.h:37:    uint64_t start_key[2];  /* 初始化的时候设置的遍历的开始id && Start key as 128 bit big endian. */
stream.h:38:    uint64_t end_key[2];    /* 遍历的结束id && End key as 128 bit big endian. */
syncio.c:3: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
syncio.c:43:#define SYNCIO__RESOLUTION 10 /* Resolution in milliseconds */
syncio.c:47: * returned. Otherwise the operation fails, -1 is returned, and an unspecified
syncio.c:54:    while(1) {
syncio.c:62:        if (nwritten == -1) {
syncio.c:63:            if (errno != EAGAIN) return -1;
syncio.c:75:            return -1;
syncio.c:83: * Otherwise the operation fails, -1 is returned, and an unspecified amount of
syncio.c:91:    while(1) {
syncio.c:99:        if (nread == 0) return -1; /* short read. */
syncio.c:100:        if (nread == -1) {
syncio.c:101:            if (errno != EAGAIN) return -1;
syncio.c:114:            return -1;
syncio.c:123: * On success the number of bytes read is returned, otherwise -1.
syncio.c:132:        if (syncRead(fd,&c,1,timeout) == -1) return -1;
syncio.c:135:            if (nread && *(ptr-1) == '\r') *(ptr-1) = '\0';
test.c:8:    char msg[1024]={0};
test.c:17:#define assert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
test.c:22:    *((char*)-1) = 'x';
test.c:29:    LOG(__LINE__,"this is a va_list test %d,%f",110,12.777);
test.c:30:    assert(1>2);
test.c:31:    while(1)sleep(1);
test.cpp:4:    const uint64_t m = 0xc6a4a7935bd1e995;
test.cpp:21:        k |= (uint64_t) data[1] << 8;
test.cpp:22:        k |= (uint64_t) data[2] << 16;
test.cpp:43:    case 3: h ^= (uint64_t)data[2] << 16; /* fall-thru */
test.cpp:44:    case 2: h ^= (uint64_t)data[1] << 8; /* fall-thru */
test.cpp:45:    case 1: h ^= (uint64_t)data[0];
test.cpp:58:    uint64_t hash = MurmurHash64A(ele,12,0xadc83b19ULL);
test.cpp:60:    const char * ele1="hello world*";
test.cpp:61:    hash = MurmurHash64A(ele1,12,0xadc83b19ULL);
testhelp.h:5: * test_cond("Check if 1 == 1", 1==1)
testhelp.h:6: * test_cond("Check if 5 > 10", 5 > 10)
testhelp.h:11: * Copyright (c) 2010-2012, Salvatore Sanfilippo <antirez at gmail dot com>
testhelp.h:53:        exit(1); \
t_hash.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
t_hash.c:57: * Returns -1 when the field cannot be found. */
t_hash.c:72:        fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
t_hash.c:86:    return -1;
t_hash.c:158:            len = vstr ? vlen : sdigits10(vll);
t_hash.c:170:/* Test if the specified field exists in the given hash. Returns 1 if the field
t_hash.c:179:        if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) return 1;
t_hash.c:181:        if (hashTypeGetFromHashTable(o, field) != NULL) return 1;
t_hash.c:189: * Return 0 on insert and 1 on update.
t_hash.c:206://set value.如果已经存在则更新返回1，如果不存在插入返回0
t_hash.c:207:#define HASH_SET_TAKE_FIELD (1<<0)
t_hash.c:208:#define HASH_SET_TAKE_VALUE (1<<1)
t_hash.c:219:            fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
t_hash.c:224:                update = 1;
t_hash.c:257:            update = 1;
t_hash.c:286: * Return 1 on deleted and 0 on not found. */
t_hash.c:296:            fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
t_hash.c:301:                deleted = 1;
t_hash.c:306:            deleted = 1;
t_hash.c:523://不存在的时候赋值,返回1，存在的时候返回0
t_hash.c:526:    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
t_hash.c:534:        signalModifiedKey(c->db,c->argv[1]);
t_hash.c:535:        notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
t_hash.c:544:    if ((c->argc % 2) == 1) {
t_hash.c:549:    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
t_hash.c:550:    hashTypeTryConversion(o,c->argv,2,c->argc-1);
t_hash.c:553:        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);
t_hash.c:557:    if (cmdname[1] == 's' || cmdname[1] == 'S') {
t_hash.c:564:    signalModifiedKey(c->db,c->argv[1]);
t_hash.c:565:    notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
t_hash.c:577:    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
t_hash.c:600:    signalModifiedKey(c->db,c->argv[1]);
t_hash.c:601:    notifyKeyspaceEvent(NOTIFY_HASH,"hincrby",c->argv[1],c->db->id);
t_hash.c:614:    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
t_hash.c:635:    int len = ld2string(buf,sizeof(buf),value,1);
t_hash.c:639:    signalModifiedKey(c->db,c->argv[1]);
t_hash.c:640:    notifyKeyspaceEvent(NOTIFY_HASH,"hincrbyfloat",c->argv[1],c->db->id);
t_hash.c:693:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
t_hash.c:706:    o = lookupKeyRead(c->db, c->argv[1]);
t_hash.c:722:    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_hash.c:729:                dbDelete(c->db,c->argv[1]);
t_hash.c:730:                keyremoved = 1;
t_hash.c:737:        signalModifiedKey(c->db,c->argv[1]);
t_hash.c:738:        notifyKeyspaceEvent(NOTIFY_HASH,"hdel",c->argv[1],c->db->id);
t_hash.c:740:            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
t_hash.c:751:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_hash.c:760:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_hash.c:790:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
t_hash.c:829:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_hash.c:835://hscan runoobkey 0 match hei* count 10
t_hash.c:841:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
t_list.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
t_list.c:110: * and advances the position of the iterator. Returns 1 when the current
t_list.c:199:    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);
t_list.c:213:            dbAdd(c->db,c->argv[1],lobj);
t_list.c:224:        signalModifiedKey(c->db,c->argv[1]);
t_list.c:225:        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
t_list.c:242:    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_list.c:256:        signalModifiedKey(c->db,c->argv[1]);
t_list.c:257:        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
t_list.c:286:    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_list.c:294:            inserted = 1;
t_list.c:301:        signalModifiedKey(c->db,c->argv[1]);
t_list.c:303:                            c->argv[1],c->db->id);
t_list.c:315:    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
t_list.c:321:    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);
t_list.c:348:    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
t_list.c:364:            signalModifiedKey(c->db,c->argv[1]);
t_list.c:365:            notifyKeyspaceEvent(NOTIFY_LIST,"lset",c->argv[1],c->db->id);
t_list.c:374:    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);
t_list.c:385:        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
t_list.c:388:                                c->argv[1],c->db->id);
t_list.c:389:            dbDelete(c->db,c->argv[1]);
t_list.c:391:        signalModifiedKey(c->db,c->argv[1]);
t_list.c:411:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
t_list.c:426:    if (end >= llen) end = llen-1;
t_list.c:427:    rangelen = (end-start)+1;
t_list.c:457:    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
t_list.c:473:        if (end >= llen) end = llen-1;
t_list.c:475:        rtrim = llen-end-1;
t_list.c:486:    notifyKeyspaceEvent(NOTIFY_LIST,"ltrim",c->argv[1],c->db->id);
t_list.c:488:        dbDelete(c->db,c->argv[1]);
t_list.c:489:        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
t_list.c:491:    signalModifiedKey(c->db,c->argv[1]);
t_list.c:505:    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
t_list.c:511:        li = listTypeInitIterator(subject,-1,LIST_HEAD);
t_list.c:528:        signalModifiedKey(c->db,c->argv[1]);
t_list.c:529:        notifyKeyspaceEvent(NOTIFY_LIST,"lrem",c->argv[1],c->db->id);
t_list.c:533:        dbDelete(c->db,c->argv[1]);
t_list.c:534:        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
t_list.c:573:    if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
t_list.c:582:        robj *touchedkey = c->argv[1];
t_list.c:606:            rewriteClientCommandVector(c,3,shared.rpoplpush,c->argv[1],c->argv[2]);
t_list.c:619: * 1) Provide the client with the 'value' element.
t_list.c:642:        argv[1] = key;
t_list.c:664:            argv[1] = key;
t_list.c:673:            argv[1] = dstkey;
t_list.c:697:    if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
t_list.c:700:    for (j = 1; j < c->argc-1; j++) {
t_list.c:745:    blockForKeys(c,BLOCKED_LIST,c->argv + 1,c->argc - 2,timeout,NULL,NULL);
t_list.c:762:    robj *key = lookupKeyWrite(c->db, c->argv[1]);
t_list.c:771:            blockForKeys(c,BLOCKED_LIST,c->argv + 1,1,timeout,c->argv[2],NULL);
t_set.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
t_set.c:50: * returned, otherwise the new element is added and 1 is returned. */
t_set.c:60:            return 1;
t_set.c:72:                return 1;
t_set.c:82:            return 1;
t_set.c:89://删除字段，成功返回1失败0
t_set.c:95:            return 1;
t_set.c:101:            if (success) return 1;
t_set.c:108://查看是否为set的成员是返回1 不是0
t_set.c:155: * When there are no longer elements -1 is returned. */
t_set.c:159:        if (de == NULL) return -1;
t_set.c:161:        *llele = -123456789; /* Not needed. Defensive. */
t_set.c:164:            return -1;
t_set.c:187:        case -1:    return NULL;
t_set.c:216:        *llele = -123456789; /* Not needed. Defensive. */
t_set.c:255:        while (setTypeNext(si,&element,&intele) != -1) {
t_set.c:277:    set = lookupKeyWrite(c->db,c->argv[1]);
t_set.c:280:        dbAdd(c->db,c->argv[1],set);
t_set.c:292:        signalModifiedKey(c->db,c->argv[1]);
t_set.c:293:        notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
t_set.c:299://srem key member1 member2....
t_set.c:304:    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_set.c:311:                dbDelete(c->db,c->argv[1]);
t_set.c:312:                keyremoved = 1;
t_set.c:318:        signalModifiedKey(c->db,c->argv[1]);
t_set.c:319:        notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
t_set.c:321:            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
t_set.c:335:    srcset = lookupKeyWrite(c->db,c->argv[1]);
t_set.c:351:    //如果是相等的,是成员返回1 不是返回0
t_set.c:363:    notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
t_set.c:367:        dbDelete(c->db,c->argv[1]);
t_set.c:368:        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
t_set.c:377:    signalModifiedKey(c->db,c->argv[1]);
t_set.c:392:    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_set.c:394:    //是成员返回1 不是返回0
t_set.c:405:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_set.c:437:    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
t_set.c:451:    notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
t_set.c:454:    /* CASE 1:
t_set.c:460:        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
t_set.c:463:        dbDelete(c->db,c->argv[1]);
t_set.c:464:        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
t_set.c:467:        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
t_set.c:468:        signalModifiedKey(c->db,c->argv[1]);
t_set.c:478:    propargv[1] = c->argv[1];
t_set.c:545:        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {
t_set.c:563:        dbOverwrite(c->db,c->argv[1],newset);
t_set.c:572:    signalModifiedKey(c->db,c->argv[1]);
t_set.c:592:    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
t_set.c:607:    notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
t_set.c:611:    rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
t_set.c:620:        dbDelete(c->db,c->argv[1]);
t_set.c:621:        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
t_set.c:625:    signalModifiedKey(c->db,c->argv[1]);
t_set.c:640:    int uniq = 1;
t_set.c:659:    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
t_set.c:669:    /* CASE 1: The count was negative, so the extraction method is just:
t_set.c:692:        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
t_set.c:714:        while((encoding = setTypeNext(si,&ele,&llele)) != -1) {
t_set.c:791:    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
t_set.c:802:int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
t_set.c:803:    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
t_set.c:804:    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
t_set.c:810:int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
t_set.c:811:    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
t_set.c:812:    unsigned long first = o1 ? setTypeSize(o1) : 0;
t_set.c:815:    if (first < second) return 1;
t_set.c:816:    if (first > second) return -1;
t_set.c:875:    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {
t_set.c:876:        for (j = 1; j < setnum; j++) {
t_set.c:948:    sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
t_set.c:952:    sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
t_set.c:956:#define SET_OP_DIFF 1
t_set.c:966:    int diff_algo = 1;
t_set.c:985:     * Algorithm 1 is O(N*M) where N is the size of the element first set
t_set.c:1002:        /* Algorithm 1 has better constant times and performs less operations
t_set.c:1005:        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;
t_set.c:1007:        if (diff_algo == 1 && setnum > 1) {
t_set.c:1008:            /* With algorithm 1 it is better to order the sets to subtract
t_set.c:1011:            qsort(sets+1,setnum-1,sizeof(robj*),
t_set.c:1034:    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {
t_set.c:1035:        /* DIFF Algorithm 1:
t_set.c:1045:            for (j = 1; j < setnum; j++) {
t_set.c:1120:    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
t_set.c:1124:    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
t_set.c:1128:    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
t_set.c:1132:    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
t_set.c:1140:    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
t_stream.c:2: * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
t_stream.c:40:#define STREAM_ITEM_FLAG_DELETED (1<<0)     /* Entry is delted. Skip it. */
t_stream.c:41:#define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  /* Same fields as master entry. */
t_stream.c:81:        new_id->seq = last_id->seq+1;
t_stream.c:133:/* Convert the specified stream entry ID as a 128 bit big endian number, so
t_stream.c:138:    e[1] = htonu64(id->seq);
t_stream.c:144: * to a 128 bit big-endian encoded ID. */
t_stream.c:149:    id->seq = ntohu64(e[1]);
t_stream.c:152:/* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */
t_stream.c:154:    if (a->ms > b->ms) return 1;
t_stream.c:155:    else if (a->ms < b->ms) return -1;
t_stream.c:157:    else if (a->seq > b->seq) return 1;
t_stream.c:158:    else if (a->seq < b->seq) return -1;
t_stream.c:180://1.这是value中的listpack的开头,也是第一次创建新的listpack的赋值的。fields
t_stream.c:181://2.count是每一个新得stream_id都会+1
t_stream.c:187:     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|
t_stream.c:202:     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|
t_stream.c:207:     * |flags|entry-id|value-1|...|value-N|lp-count|
t_stream.c:240:     * to do so we consider the ID as a single 128 bit number written in
t_stream.c:258:     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|
t_stream.c:297:        lp = lpAppendInteger(lp,1); /* One item, the one we are adding.count  add 1*/
t_stream.c:319:        //获得原来listpack中的count 并设置count+1
t_stream.c:321:        lp = lpReplaceInteger(lp,&lp_ele,count+1);
t_stream.c:351:     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|
t_stream.c:358:     * |flags|entry-id|value-1|...|value-N|lp-count|
t_stream.c:375:        sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;
t_stream.c:386:        lp_count += numfields+1;
t_stream.c:409: * 1) The stream is already shorter or equal to the specified max length.
t_stream.c:413:// xadd codehole maxlen 3 * name xiaorui age 1
t_stream.c:491:                to_skip = 1+(to_skip*2);
t_stream.c:502:        if (entries + marked_deleted > 10 && marked_deleted > entries/2) {
t_stream.c:543:     * elements into a 128 big big-endian number. */
t_stream.c:548:        si->start_key[1] = 0;
t_stream.c:555:        si->end_key[1] = UINT64_MAX;
t_stream.c:584:/* Return 1 and store the current item ID at 'id' if there are still
t_stream.c:589:    while(1) { /* Will stop when element > stop_key or end of radix tree. */
t_stream.c:639:        while(1) {
t_stream.c:696:                    return 1; /* Valid item returned. */
t_stream.c:707:                    return 1; /* Valid item returned. */
t_stream.c:788:    if (aux == 1) {
t_stream.c:795:        lp = lpReplaceInteger(lp,&p,aux-1);
t_stream.c:798:        lp = lpReplaceInteger(lp,&p,aux+1);
t_stream.c:831:/* Delete the specified item ID from the stream, returning 1 if the item
t_stream.c:833://根据某个id进行删除，成功返回1 失败返回0 
t_stream.c:842:        deleted = 1;
t_stream.c:874:    robj *argv[14];
t_stream.c:876:    argv[1] = key;
t_stream.c:883:    argv[8] = createStringObject("RETRYCOUNT",10);
t_stream.c:885:    argv[10] = createStringObject("FORCE",5);
t_stream.c:886:    argv[11] = createStringObject("JUSTID",6);
t_stream.c:887:    argv[12] = createStringObject("LASTID",6);
t_stream.c:888:    argv[13] = createObjectFromStreamID(&group->last_id);
t_stream.c:889:    propagate(server.xclaimCommand,c->db->id,argv,14,PROPAGATE_AOF|PROPAGATE_REPL);
t_stream.c:897:    decrRefCount(argv[10]);
t_stream.c:898:    decrRefCount(argv[11]);
t_stream.c:899:    decrRefCount(argv[12]);
t_stream.c:900:    decrRefCount(argv[13]);
t_stream.c:912:    argv[1] = createStringObject("SETID",5);
t_stream.c:918:    decrRefCount(argv[1]);
t_stream.c:933: * 1. It updates the last delivered ID in the group in case we are
t_stream.c:966:#define STREAM_RWR_NOACK (1<<0)         /* Do not create entries in the PEL. */
t_stream.c:967:#define STREAM_RWR_RAWENTRIES (1<<1)    /* Do not emit protocol for array
t_stream.c:969:#define STREAM_RWR_HISTORY (1<<2)       /* Only serve consumer local PEL. */
t_stream.c:995:            propagate_last_id = 1;
t_stream.c:1046:                nack->delivery_count = 1;
t_stream.c:1049:            } else if (group_inserted == 1 && consumer_inserted == 0) {
t_stream.c:1085://该函数获取customer->pel 的rax tree中的元素。pel中key是128位.value nck
t_stream.c:1102:        if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,
t_stream.c:1149: * 1 if the conversion happened successfully or 0 if the number is
t_stream.c:1156:        return 1;
t_stream.c:1160:    *value = strtoull(s,&endptr,10);
t_stream.c:1163:    return 1; /* Conversion done! */
t_stream.c:1174: * that can be represented. If 'strict' is set to 1, "-" and "+" will be
t_stream.c:1179:    char buf[128];
t_stream.c:1180:    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;
t_stream.c:1181:    memcpy(buf,o->ptr,sdslen(o->ptr)+1);
t_stream.c:1183:    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\0')
t_stream.c:1187:    if (buf[0] == '-' && buf[1] == '\0') {
t_stream.c:1191:    } else if (buf[0] == '+' && buf[1] == '\0') {
t_stream.c:1202:    if (dot && string2ull(dot+1,&seq) == 0) goto invalid;
t_stream.c:1221: * 1, to be used when we want to return an error if the special IDs + or -
t_stream.c:1224:    return streamGenericParseIDOrReply(c,o,id,missing_seq,1);
t_stream.c:1231:    robj *equal_obj = createStringObject("=",1);
t_stream.c:1234:    rewriteClientCommandArgument(c,maxlen_arg_idx-1,equal_obj);
t_stream.c:1242://xadd codehole maxlen ~ 3 * name xiaorui age 1
t_stream.c:1246:    long long maxlen = -1;  /* If left to -1 no trimming is performed. */
t_stream.c:1247:    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so
t_stream.c:1255:        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
t_stream.c:1257:        if (opt[0] == '*' && opt[1] == '\0') {
t_stream.c:1263:            char *next = c->argv[i+1]->ptr;
t_stream.c:1265:            if (moreargs >= 2 && next[0] == '~' && next[1] == '\0') {
t_stream.c:1266:                approx_maxlen = 1;
t_stream.c:1268:            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\0') {
t_stream.c:1271:            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)
t_stream.c:1283:            id_given = 1;
t_stream.c:1287:    int field_pos = i+1;
t_stream.c:1290:    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {
t_stream.c:1298:    if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
t_stream.c:1313:    signalModifiedKey(c->db,c->argv[1]);//这个是发给感兴趣的模块
t_stream.c:1314:    notifyKeyspaceEvent(NOTIFY_STREAM,"xadd",c->argv[1],c->db->id);//这个发布订阅对该命令xadd感兴趣的client
t_stream.c:1319:        //定长stream数量 其中如果approx_maxlen=1的话，只会删除整个listpck。剩下的不做处理
t_stream.c:1321:            notifyKeyspaceEvent(NOTIFY_STREAM,"xtrim",c->argv[1],c->db->id);
t_stream.c:1335:        signalKeyAsReady(c->db, c->argv[1]);
t_stream.c:1340://xrange codehole 1527849629172-0 +
t_stream.c:1341://xrange codehole - 1527849629172-0 
t_stream.c:1346:    long long count = -1;
t_stream.c:1356:            int additional = c->argc-j-1;
t_stream.c:1357:            if (strcasecmp(c->argv[j]->ptr,"COUNT") == 0 && additional >= 1) {
t_stream.c:1358:                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)
t_stream.c:1370:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
t_stream.c:1377:        if (count == -1) count = 0;
t_stream.c:1389:    xrangeGenericCommand(c,1);
t_stream.c:1395:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
t_stream.c:1401:/* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N
t_stream.c:1402: *       ID_1 ID_2 ... ID_N
t_stream.c:1409://xread count 1 streams codehole $
t_stream.c:1411://xread block 0 count 1 streams codehole $
t_stream.c:1415://xreadgroup GROUP cg1 c1 count 1 streams codehole >
t_stream.c:1417://xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole >
t_stream.c:1418:#define XREAD_BLOCKED_DEFAULT_COUNT 1000
t_stream.c:1420:    long long timeout = -1; /* -1 means, no BLOCK argument given. */
t_stream.c:1429:    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */
t_stream.c:1434:    for (int i = 1; i < c->argc; i++) {
t_stream.c:1435:        int moreargs = c->argc-i-1;
t_stream.c:1448:            streams_arg = i+1;
t_stream.c:1465:            groupname = c->argv[i+1];
t_stream.c:1474:            noack = 1;
t_stream.c:1579:                serve_synchronously = 1;
t_stream.c:1580:                serve_history = 1;
t_stream.c:1587:                    serve_synchronously = 1;
t_stream.c:1595:                serve_synchronously = 1;
t_stream.c:1601:            if (arraylen == 1) arraylen_ptr = addDeferredMultiBulkLength(c);
t_stream.c:1614:                                                        consumername->ptr,1);
t_stream.c:1633:    if (timeout != -1) {
t_stream.c:1682:/* Create a NACK entry setting the delivery count to 1 and the delivery
t_stream.c:1688:    nack->delivery_count = 1;
t_stream.c:1797://xgroup create stream_key cg1 0-0  #  表示从头开始消费
t_stream.c:1813:    char *opt = c->argv[1]->ptr; /* Subcommand name. */
t_stream.c:1824:        mkstream = 1;
t_stream.c:1934:    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
t_stream.c:1947:        streamIteratorStart(&si,s,NULL,NULL,1);
t_stream.c:1961:    notifyKeyspaceEvent(NOTIFY_STREAM,"xsetid",c->argv[1],c->db->id);
t_stream.c:1975:    robj *o = lookupKeyRead(c->db,c->argv[1]);
t_stream.c:2021:    robj *key = c->argv[1];
t_stream.c:2046:    robj *o = lookupKeyRead(c->db,c->argv[1]);
t_stream.c:2157:/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>
t_stream.c:2182: * 1. IDLE <ms>:
t_stream.c:2225:    robj *o = lookupKeyRead(c->db,c->argv[1]);
t_stream.c:2227:    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */
t_stream.c:2228:    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */
t_stream.c:2241:                              "consumer group '%s'", (char*)c->argv[1]->ptr,
t_stream.c:2260:    int last_id_arg = j-1; /* Next time we iterate the IDs we now the range. */
t_stream.c:2268:        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */
t_stream.c:2271:            force = 1;
t_stream.c:2273:            justid = 1;
t_stream.c:2301:        propagate_last_id = 1;
t_stream.c:2304:    if (deliverytime != -1) {
t_stream.c:2321:    streamConsumer *consumer = streamLookupConsumer(group,c->argv[3]->ptr,1);
t_stream.c:2345:            if (streamIteratorGetID(&myiterator,&item_id,&numfields)) found = 1;
t_stream.c:2388:                size_t emitted = streamReplyWithRange(c,o->ptr,&id,&id,1,0,
t_stream.c:2395:            streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);
t_stream.c:2401:        streamPropagateGroupID(c,c->argv[1],group,c->argv[2]);
t_stream.c:2409:/* XDEL <key> [<ID1> <ID2> ... <IDN>]
t_stream.c:2417:    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
t_stream.c:2438:        signalModifiedKey(c->db,c->argv[1]);
t_stream.c:2439:        notifyKeyspaceEvent(NOTIFY_STREAM,"xdel",c->argv[1],c->db->id);
t_stream.c:2456:#define TRIM_STRATEGY_MAXLEN 1
t_stream.c:2462:    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
t_stream.c:2468:    long long maxlen = -1;  /* If left to -1 no trimming is performed. */
t_stream.c:2469:    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so
t_stream.c:2476:        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
t_stream.c:2481:            char *next = c->argv[i+1]->ptr;
t_stream.c:2483:            if (moreargs >= 2 && next[0] == '~' && next[1] == '\0') {
t_stream.c:2484:                approx_maxlen = 1;
t_stream.c:2486:            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\0') {
t_stream.c:2489:            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)
t_stream.c:2515:        signalModifiedKey(c->db,c->argv[1]);
t_stream.c:2516:        notifyKeyspaceEvent(NOTIFY_STREAM,"xtrim",c->argv[1],c->db->id);
t_stream.c:2540:    if (!strcasecmp(c->argv[1]->ptr,"HELP")) {
t_stream.c:2550:    opt = c->argv[1]->ptr;
t_stream.c:2614:        addReplyMultiBulkLen(c,14);
t_stream.c:2633:        count = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,
t_stream.c:2637:        count = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,
t_string.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
t_string.c:38:    if (size > 512*1024*1024) {
t_string.c:39:        addReplyError(c,"string exceeds maximum allowed size (512MB)");
t_string.c:59: * If abort_reply is NULL, "$-1" is used. */
t_string.c:62:#define OBJ_SET_NX (1<<0)     /* Set if key not exists. */
t_string.c:63:#define OBJ_SET_XX (1<<1)     /* Set if key exists. */
t_string.c:64:#define OBJ_SET_EX (1<<2)     /* Set if time in seconds is given */
t_string.c:65:#define OBJ_SET_PX (1<<3)     /* Set if time in ms in given */
t_string.c:79:        //UNIT_SECONDS=0 ,then*1000.说明底层是用ms进行得计时
t_string.c:80:        if (unit == UNIT_SECONDS) milliseconds *= 1000;
t_string.c:108:        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];
t_string.c:111:            (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
t_string.c:116:                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
t_string.c:121:                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
t_string.c:129:                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
t_string.c:143:    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
t_string.c:148:    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
t_string.c:153:    setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
t_string.c:158:    setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
t_string.c:164:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
t_string.c:183:    setKey(c->db,c->argv[1],c->argv[2]);
t_string.c:184:    notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
t_string.c:201:    o = lookupKeyWrite(c->db,c->argv[1]);
t_string.c:208:        //这里检查长度最大512M
t_string.c:214:        dbAdd(c->db,c->argv[1],o);
t_string.c:235:        o = dbUnshareStringValue(c->db,c->argv[1],o);
t_string.c:241:        signalModifiedKey(c->db,c->argv[1]);
t_string.c:243:            "setrange",c->argv[1],c->db->id);
t_string.c:259:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
t_string.c:279:    if ((unsigned long long)end >= strlen) end = strlen-1;
t_string.c:286:        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
t_string.c:293:    addReplyMultiBulkLen(c,c->argc-1);
t_string.c:294:    for (j = 1; j < c->argc; j++) {
t_string.c:307://mset key value [key1 value1 .....]
t_string.c:308://msetnx key value [key1 value1 .....]
t_string.c:319:    //nx==1 则如果key值有一个存在则返回
t_string.c:321:        for (j = 1; j < c->argc; j += 2) {
t_string.c:329:    for (j = 1; j < c->argc; j += 2) {
t_string.c:330:        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
t_string.c:331:        setKey(c->db,c->argv[j],c->argv[j+1]);
t_string.c:334:    server.dirty += (c->argc-1)/2;
t_string.c:343:    msetGenericCommand(c,1);
t_string.c:347://key值对应得value+-1前提数字
t_string.c:352:    o = lookupKeyWrite(c->db,c->argv[1]);
t_string.c:364:    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
t_string.c:373:            dbOverwrite(c->db,c->argv[1],new);
t_string.c:375:            dbAdd(c->db,c->argv[1],new);
t_string.c:378:    signalModifiedKey(c->db,c->argv[1]);
t_string.c:379:    notifyKeyspaceEvent(NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
t_string.c:387:    incrDecrCommand(c,1);
t_string.c:391:    incrDecrCommand(c,-1);
t_string.c:412:    o = lookupKeyWrite(c->db,c->argv[1]);
t_string.c:423:    new = createStringObjectFromLongDouble(value,1);
t_string.c:425:        dbOverwrite(c->db,c->argv[1],new);
t_string.c:427:        dbAdd(c->db,c->argv[1],new);
t_string.c:428:    signalModifiedKey(c->db,c->argv[1]);
t_string.c:429:    notifyKeyspaceEvent(NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
t_string.c:446:    o = lookupKeyWrite(c->db,c->argv[1]);
t_string.c:450:        dbAdd(c->db,c->argv[1],c->argv[2]);
t_string.c:465:        o = dbUnshareStringValue(c->db,c->argv[1],o);
t_string.c:469:    signalModifiedKey(c->db,c->argv[1]);
t_string.c:470:    notifyKeyspaceEvent(NOTIFY_STRING,"append",c->argv[1],c->db->id);
t_string.c:477:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
t_zset.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
t_zset.c:3: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
t_zset.c:56: * pointers being only at "level 1". This allows to traverse the list
t_zset.c:85:    zsl->level = 1;
t_zset.c:119: * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
t_zset.c:123:    int level = 1;
t_zset.c:125:        level += 1;
t_zset.c:139:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:141:        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
t_zset.c:172:        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
t_zset.c:194:            update[i]->level[i].span += x->level[i].span - 1;
t_zset.c:197:            update[i]->level[i].span -= 1;
t_zset.c:205:    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
t_zset.c:211: * The function returns 1 if the node was found and deleted, otherwise
t_zset.c:223:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:242:        return 1;
t_zset.c:265:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:324:    return 1;
t_zset.c:337:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:363:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:388:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:420:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:443: * Start and end are inclusive. Note that start and end need to be 1-based */
t_zset.c:450:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:474: * Note that the rank is 1-based due to the span of zsl->header to the
t_zset.c:482:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:499:/* Finds an element by its rank. The rank argument needs to be 1-based. */
t_zset.c:506:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:526:     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
t_zset.c:527:     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
t_zset.c:532:            spec->min = strtod((char*)min->ptr+1,&eptr);
t_zset.c:534:            spec->minex = 1;
t_zset.c:544:            spec->max = strtod((char*)max->ptr+1,&eptr);
t_zset.c:546:            spec->maxex = 1;
t_zset.c:565:  * that will be used for the comparison, and ex will be set to 0 or 1
t_zset.c:576:        if (c[1] != '\0') return C_ERR;
t_zset.c:577:        *ex = 1;
t_zset.c:581:        if (c[1] != '\0') return C_ERR;
t_zset.c:582:        *ex = 1;
t_zset.c:586:        *ex = 1;
t_zset.c:587:        *dest = sdsnewlen(c+1,sdslen(c)-1);
t_zset.c:591:        *dest = sdsnewlen(c+1,sdslen(c)-1);
t_zset.c:633:    if (a == shared.minstring || b == shared.maxstring) return -1;
t_zset.c:634:    if (a == shared.maxstring || b == shared.minstring) return 1;
t_zset.c:664:    return 1;
t_zset.c:677:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:703:    for (i = zsl->level-1; i >= 0; i--) {
t_zset.c:726:    char buf[128];
t_zset.c:833:    p = ziplistIndex(zl,-1); /* Last score. */
t_zset.c:839:    p = ziplistIndex(zl,1); /* First score. */
t_zset.c:845:    return 1;
t_zset.c:943:    return 1;
t_zset.c:1031:    char scorebuf[128];
t_zset.c:1144: * Start and end are inclusive. Note that start and end need to be 1-based */
t_zset.c:1146:    unsigned int num = (end-start)+1;
t_zset.c:1148:    zl = ziplistDeleteRange(zl,2*(start-1),2*num);
t_zset.c:1298: * The function returns 1 on success, and sets the appropriate flags
t_zset.c:1336:                return 1;
t_zset.c:1355:            return 1;
t_zset.c:1366:            return 1;
t_zset.c:1369:            return 1;
t_zset.c:1381:                return 1;
t_zset.c:1404:            return 1;
t_zset.c:1411:            return 1;
t_zset.c:1414:            return 1;
t_zset.c:1422:/* Delete the element 'ele' from the sorted set, returning 1 if the element
t_zset.c:1430:            return 1;
t_zset.c:1454:            return 1;
t_zset.c:1463: * -1 if the object does not exist.
t_zset.c:1466: * of elements. So the first element has rank 0, the second rank 1, and so
t_zset.c:1467: * forth up to length-1 elements.
t_zset.c:1488:        rank = 1;
t_zset.c:1500:                return rank-1;
t_zset.c:1502:            return -1;
t_zset.c:1519:                return rank-1;
t_zset.c:1521:            return -1;
t_zset.c:1535:    robj *key = c->argv[1];
t_zset.c:1584:    if (incr && elements > 1) {
t_zset.c:1604:            server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))
t_zset.c:1623:        ele = c->argv[scoreidx+1+j*2]->ptr;
t_zset.c:1664:    robj *key = c->argv[1];
t_zset.c:1675:            keyremoved = 1;
t_zset.c:1692:#define ZRANGE_SCORE 1
t_zset.c:1695:    robj *key = c->argv[1];
t_zset.c:1703:    /* Step 1: Parse the range. */
t_zset.c:1737:        if (end >= llen) end = llen-1;
t_zset.c:1744:            zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);
t_zset.c:1755:            keyremoved = 1;
t_zset.c:1761:            deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);
t_zset.c:1773:            keyremoved = 1;
t_zset.c:1847:#define OPVAL_DIRTY_SDS 1
t_zset.c:1975:            val->score = 1.0;
t_zset.c:1983:            val->score = 1.0;
t_zset.c:2015:    return 1;
t_zset.c:2076:    return 1;
t_zset.c:2080: * return 1 and store its score in target. Return 0 otherwise. */
t_zset.c:2090:                *score = 1.0;
t_zset.c:2091:                return 1;
t_zset.c:2099:                *score = 1.0;
t_zset.c:2100:                return 1;
t_zset.c:2113:                return 1;
t_zset.c:2122:                return 1;
t_zset.c:2134:int zuiCompareByCardinality(const void *s1, const void *s2) {
t_zset.c:2135:    unsigned long first = zuiLength((zsetopsrc*)s1);
t_zset.c:2137:    if (first > second) return 1;
t_zset.c:2138:    if (first < second) return -1;
t_zset.c:2142:#define REDIS_AGGR_SUM 1
t_zset.c:2145:#define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
t_zset.c:2165:int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
t_zset.c:2193:    if (setnum < 1) {
t_zset.c:2195:            "at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE");
t_zset.c:2223:        /* Default all weights to 1. */
t_zset.c:2224:        src[i].weight = 1.0;
t_zset.c:2232:            if (remaining >= (setnum + 1) &&
t_zset.c:2288:                for (j = 1; j < setnum; j++) {
t_zset.c:2321:            dictExpand(accumulator,zuiLength(&src[setnum-1]));
t_zset.c:2324:        /* Step 1: Create a dictionary of elements -> aggregated-scores
t_zset.c:2381:        touched = 1;
t_zset.c:2404:    zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
t_zset.c:2408:    zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
t_zset.c:2412:    robj *key = c->argv[1];
t_zset.c:2424:        withscores = 1;
t_zset.c:2445:    if (end >= llen) end = llen-1;
t_zset.c:2446:    rangelen = (end-start)+1;
t_zset.c:2497:                ln = zslGetElementByRank(zsl,start+1);
t_zset.c:2518:    zrangeGenericCommand(c,1);
t_zset.c:2524:    robj *key = c->argv[1];
t_zset.c:2526:    long offset = 0, limit = -1;
t_zset.c:2553:            if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,"withscores")) {
t_zset.c:2555:                withscores = 1;
t_zset.c:2557:                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)
t_zset.c:2718:    genericZrangebyscoreCommand(c,1);
t_zset.c:2722:    robj *key = c->argv[1];
t_zset.c:2780:            count = (zsl->length - (rank - 1));
t_zset.c:2799:    robj *key = c->argv[1];
t_zset.c:2858:            count = (zsl->length - (rank - 1));
t_zset.c:2880:    robj *key = c->argv[1];
t_zset.c:2882:    long offset = 0, limit = -1;
t_zset.c:2909:                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
t_zset.c:3062:    genericZrangebylexCommand(c,1);
t_zset.c:3066:    robj *key = c->argv[1];
t_zset.c:3076:    robj *key = c->argv[1];
t_zset.c:3091:    robj *key = c->argv[1];
t_zset.c:3113:    zrankGenericCommand(c, 1);
t_zset.c:3121:    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
t_zset.c:3141:    long count = 1;
t_zset.c:3245:    genericZpopCommand(c,&c->argv[1],1,ZSET_MIN,0,
t_zset.c:3255:    genericZpopCommand(c,&c->argv[1],1,ZSET_MAX,0,
t_zset.c:3265:    if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
t_zset.c:3268:    for (j = 1; j < c->argc-1; j++) {
t_zset.c:3277:                    genericZpopCommand(c,&c->argv[j],1,where,1,NULL);
t_zset.c:3296:    blockForKeys(c,BLOCKED_ZSET,c->argv + 1,c->argc - 2,timeout,NULL,NULL);
util.c:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
util.c:45:#include "sha1.h"
util.c:54:            while (pattern[1] == '*') {
util.c:58:            if (patternLen == 1)
util.c:59:                return 1; /* match */
util.c:61:                if (stringmatchlen(pattern+1, patternLen-1,
util.c:63:                    return 1; /* match */
util.c:87:            while(1) {
util.c:92:                        match = 1;
util.c:99:                } else if (pattern[1] == '-' && patternLen >= 3) {
util.c:116:                        match = 1;
util.c:120:                            match = 1;
util.c:123:                            match = 1;
util.c:166:        return 1;
util.c:178:    int cycles = 10000000;
util.c:183:        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;
util.c:184:        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
util.c:191: * bytes, so for instance memtoll("1Gb") will return 1073741824 that is
util.c:192: * (1024*1024*1024).
util.c:194: * On parsing error, if *err is not NULL, it's set to 1, otherwise it's
util.c:199:    char buf[128];
util.c:211:        mul = 1;
util.c:213:        mul = 1000;
util.c:215:        mul = 1024;
util.c:217:        mul = 1000*1000;
util.c:219:        mul = 1024*1024;
util.c:221:        mul = 1000L*1000*1000;
util.c:223:        mul = 1024L*1024*1024;
util.c:225:        if (err) *err = 1;
util.c:233:        if (err) *err = 1;
util.c:241:    val = strtoll(buf,&endptr,10);
util.c:243:        if (err) *err = 1;
util.c:249:/* Return the number of digits of 'v' when converted to string in radix 10.
util.c:251:uint32_t digits10(uint64_t v) {
util.c:252:    if (v < 10) return 1;
util.c:253:    if (v < 100) return 2;
util.c:254:    if (v < 1000) return 3;
util.c:255:    if (v < 1000000000000UL) {
util.c:256:        if (v < 100000000UL) {
util.c:257:            if (v < 1000000) {
util.c:258:                if (v < 10000) return 4;
util.c:259:                return 5 + (v >= 100000);
util.c:261:            return 7 + (v >= 10000000UL);
util.c:263:        if (v < 10000000000UL) {
util.c:264:            return 9 + (v >= 1000000000UL);
util.c:266:        return 11 + (v >= 100000000000UL);
util.c:268:    return 12 + digits10(v / 1000000000000UL);
util.c:271:/* Like digits10() but for signed values. */
util.c:272:uint32_t sdigits10(int64_t v) {
util.c:276:                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;
util.c:277:        return digits10(uv)+1; /* +1 for the minus. */
util.c:279:        return digits10(v);
util.c:290: * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920
util.c:295:    static const char digits[201] =
util.c:296:        "0001020304050607080910111213141516171819"
util.c:297:        "2021222324252627282930313233343536373839"
util.c:298:        "4041424344454647484950515253545556575859"
util.c:299:        "6061626364656667686970717273747576777879"
util.c:300:        "8081828384858687888990919293949596979899";
util.c:310:            value = ((unsigned long long) LLONG_MAX)+1;
util.c:312:        negative = 1;
util.c:319:    uint32_t const length = digits10(value)+negative;
util.c:326:    while (value >= 100) {
util.c:327:        int const i = (value % 100) * 2;
util.c:328:        value /= 100;
util.c:329:        dst[next] = digits[i + 1];
util.c:330:        dst[next - 1] = digits[i];
util.c:334:    /* Handle last 1-2 digits. */
util.c:335:    if (value < 10) {
util.c:339:        dst[next] = digits[i + 1];
util.c:340:        dst[next - 1] = digits[i];
util.c:348:/* Convert a string into a long long. Returns 1 if the string could be parsed
util.c:371:    if (slen == 1 && p[0] == '0') {
util.c:373:        return 1;
util.c:379:        negative = 1;
util.c:387:    /* First digit should be 1-9, otherwise the string should just be 0. */
util.c:388:    if (p[0] >= '1' && p[0] <= '9') {
util.c:397:        if (v > (ULLONG_MAX / 10)) /* Overflow. */
util.c:399:        v *= 10;
util.c:415:        if (v > ((unsigned long long)(-(LLONG_MIN+1))+1)) /* Overflow. */
util.c:423:    return 1;
util.c:426:/* Convert a string into a long. Returns 1 if the string could be parsed into a
util.c:439:    return 1;
util.c:442:/* Convert a string into a double. Returns 1 if the string could be parsed
util.c:468:    return 1;
util.c:486:        if (1.0/value < 0)
util.c:501:        double min = -4503599627370495; /* (2^52)-1 */
util.c:507:            len = snprintf(buf,len,"%.17g",value);
util.c:535:        /* We use 17 digits precision since with 128 bit floats that precision
util.c:540:        l = snprintf(buf,len,"%.17Lf", value);
util.c:541:        if (l+1 > len) return 0; /* No room. */
util.c:544:            char *p = buf+l-1;
util.c:552:        l = snprintf(buf,len,"%.17Lg", value);
util.c:553:        if (l+1 > len) return 0; /* No room. */
util.c:567:    static unsigned char seed[20]; /* The SHA1 seed, from /dev/urandom. */
util.c:571:        /* Initialize a seed and use SHA1 in counter mode, where we hash
util.c:576:        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {
util.c:586:            seed_initialized = 1;
util.c:593:        SHA1_CTX ctx;
util.c:596:        SHA1Init(&ctx);
util.c:597:        SHA1Update(&ctx, seed, sizeof(seed));
util.c:598:        SHA1Update(&ctx, (unsigned char*)&counter,sizeof(counter));
util.c:599:        SHA1Final(digest, &ctx);
util.c:608:/* Generate the Redis "Run ID", a SHA1-sized random number that identifies a
util.c:613:    char *charset = "0123456789abcdef";
util.c:628:    char cwd[1024];
util.c:641:    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')
util.c:651:           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')
util.c:653:        sdsrange(relpath,3,-1);
util.c:654:        if (sdslen(abspath) > 1) {
util.c:656:            int trimlen = 1;
util.c:662:            sdsrange(abspath,0,-(trimlen+1));
util.c:706:    strcpy(buf,"+1");
util.c:710:    strcpy(buf," 1");
util.c:714:    strcpy(buf,"1 ");
util.c:718:    strcpy(buf,"01");
util.c:721:    strcpy(buf,"-1");
util.c:722:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:723:    assert(v == -1);
util.c:726:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:729:    strcpy(buf,"1");
util.c:730:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:731:    assert(v == 1);
util.c:734:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:738:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:742:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:749:    assert(string2ll(buf,strlen(buf),&v) == 1);
util.c:761:    strcpy(buf,"+1");
util.c:765:    strcpy(buf,"01");
util.c:768:    strcpy(buf,"-1");
util.c:769:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:770:    assert(v == -1);
util.c:773:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:776:    strcpy(buf,"1");
util.c:777:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:778:    assert(v == 1);
util.c:781:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:785:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:789:    strcpy(buf,"-2147483648");
util.c:790:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:793:    strcpy(buf,"-2147483649"); /* overflow */
util.c:796:    strcpy(buf,"2147483647");
util.c:797:    assert(string2l(buf,strlen(buf),&v) == 1);
util.c:800:    strcpy(buf,"2147483648"); /* overflow */
util.c:812:    assert(sz == 1);
util.c:815:    v = -1;
util.c:818:    assert(!strcmp(buf, "-1"));
util.c:830:    v = -2147483648;
util.c:832:    assert(sz == 11);
util.c:833:    assert(!strcmp(buf, "-2147483648"));
util.c:842:    assert(sz == 19);
util.h:2: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
util.h:39:#define MAX_LONG_DOUBLE_CHARS 5*1024
util.h:45:uint32_t digits10(uint64_t v);
util.h:46:uint32_t sdigits10(int64_t v);
ziplist.c:5: * in O(1) time. However, because every operation requires a reallocation of
ziplist.c:29: * <uint16_t zllen> is the number of entries. When there are more than
ziplist.c:30: * 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the
ziplist.c:75: * the first 2 bits are both set to 1. The following 2 bits are used to specify
ziplist.c:80: * |00pppppp| - 1 byte
ziplist.c:83: * |01pppppp|qqqqqqqq| - 2 bytes
ziplist.c:84: *      String value with length less than or equal to 16383 bytes (14 bits).
ziplist.c:85: *      IMPORTANT: The 14 bit number is stored in big endian.
ziplist.c:86: * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
ziplist.c:87: *      String value with length greater than or equal to 16384 bytes.
ziplist.c:89: *      up to 32^2-1. The 6 lower bits of the first byte are not used and
ziplist.c:92: * |11000000| - 3 bytes
ziplist.c:93: *      Integer encoded as int16_t (2 bytes).
ziplist.c:94: * |11010000| - 5 bytes
ziplist.c:96: * |11100000| - 9 bytes
ziplist.c:98: * |11110000| - 4 bytes
ziplist.c:100: * |11111110| - 2 bytes
ziplist.c:101: *      Integer encoded as 8 bit signed (1 byte).
ziplist.c:102: * |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.
ziplist.c:103: *      Unsigned integer from 0 to 12. The encoded value is actually from
ziplist.c:104: *      1 to 13 because 0000 and 1111 can not be used, so 1 should be
ziplist.c:106: * |11111111| - End of ziplist special entry.
ziplist.c:115: * the strings "2" and "5". It is composed of 15 bytes, that we visually
ziplist.c:122: * The first 4 bytes represent the number 15, that is the number of bytes
ziplist.c:124: * at which the last ziplist entry is found, that is 12, in fact the
ziplist.c:125: * last entry, that is "5", is at offset 12 inside the ziplist.
ziplist.c:126: * The next 16 bit integer represents the number of elements inside the
ziplist.c:131: * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the "F"
ziplist.c:132: * higher order bits 1111, and subtract 1 from the "3", so the entry value
ziplist.c:135: * like the first entry, and 6-1 = 5, so the value of the entry is 5.
ziplist.c:148: * an 11 bytes string follows. From the third byte (48) to the last (64)
ziplist.c:153: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
ziplist.c:154: * Copyright (c) 2009-2017, Salvatore Sanfilippo <antirez at gmail dot com>
ziplist.c:195:#define assert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
ziplist.c:200:    *((char*)-1) = 'x';
ziplist.c:215:#define ZIP_STR_14B (1 << 6)
ziplist.c:217:#define ZIP_INT_16B (0xc0 | 0<<4)
ziplist.c:218:#define ZIP_INT_32B (0xc0 | 1<<4)
ziplist.c:223:/* 4 bit integer immediate encoding |1111xxxx| with xxxx between
ziplist.c:224: * 0001 and 1101. */
ziplist.c:227:#define ZIP_INT_IMM_MIN 0xf1    /* 11110001 */
ziplist.c:228:#define ZIP_INT_IMM_MAX 0xfd    /* 11111101 */
ziplist.c:230:#define INT24_MAX 0x7fffff      /*有符号整数即:0xffffff>>1 = 0x7fffff*/
ziplist.c:231:#define INT24_MIN (-INT24_MAX - 1)
ziplist.c:234: * with "11" as most significant bits of the first byte. */
ziplist.c:244:/* Return the length of a ziplist, or UINT16_MAX if the length cannot be
ziplist.c:246:#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
ziplist.c:249: * bytes count and last item offset. One 16 bit integer for the number
ziplist.c:251:#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
ziplist.c:265:#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
ziplist.c:268: * macro should never overflow the unsigned 16 bit integer, since entries are
ziplist.c:269: * always pushed one at a time. When UINT16_MAX is reached we want the count
ziplist.c:273:    if (ZIPLIST_LENGTH(zl) < UINT16_MAX) \
ziplist.c:274:        ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
ziplist.c:281:    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len 1 or 5*/
ziplist.c:284:                                    For example strings have a 1, 2 or 5 bytes
ziplist.c:288:                                    while for integers it is 1, 2, 3, 4, 8 or
ziplist.c:317:    case ZIP_INT_8B:  return 1;
ziplist.c:318:    case ZIP_INT_16B: return 2;
ziplist.c:341: * 返回encoding 的长度 整型 1个字节 字符串 1，2，5
ziplist.c:345:    unsigned char len = 1, buf[5];
ziplist.c:350:        if (rawlen <= 0x3f) {//1
ziplist.c:354:            len += 1;
ziplist.c:356:            buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
ziplist.c:357:            buf[1] = rawlen & 0xff;
ziplist.c:362:            buf[1] = (rawlen >> 24) & 0xff;
ziplist.c:363:            buf[2] = (rawlen >> 16) & 0xff;
ziplist.c:368:        /* Implies integer encoding, so length is always 1. */
ziplist.c:388:            (lensize) = 1;                                                     \
ziplist.c:390:        } else if ((encoding) == ZIP_STR_14B) {                                \
ziplist.c:392:            (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \
ziplist.c:395:            (len) = ((ptr)[1] << 24) |                                         \
ziplist.c:396:                    ((ptr)[2] << 16) |                                         \
ziplist.c:403:        (lensize) = 1;                                                         \
ziplist.c:413:        memcpy(p+1,&len,sizeof(len));
ziplist.c:414:        memrev32ifbe(p+1);
ziplist.c:416:    return 1+sizeof(len);
ziplist.c:423:        return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
ziplist.c:427:            return 1;
ziplist.c:438:        (prevlensize) = 1;                                                     \
ziplist.c:453:    if ((prevlensize) == 1) {                                                  \
ziplist.c:457:        memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
ziplist.c:500:        if (value >= 0 && value <= 12) {
ziplist.c:504:        } else if (value >= INT16_MIN && value <= INT16_MAX) {
ziplist.c:505:            *encoding = ZIP_INT_16B;
ziplist.c:514:        return 1;
ziplist.c:521:    int16_t i16;
ziplist.c:526:    } else if (encoding == ZIP_INT_16B) {
ziplist.c:527:        i16 = value;
ziplist.c:528:        memcpy(p,&i16,sizeof(i16));
ziplist.c:529:        memrev16ifbe(p);
ziplist.c:533:        memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));
ziplist.c:551:    int16_t i16;
ziplist.c:556:    } else if (encoding == ZIP_INT_16B) {
ziplist.c:557:        memcpy(&i16,p,sizeof(i16));
ziplist.c:558:        memrev16ifbe(&i16);
ziplist.c:559:        ret = i16;
ziplist.c:566:        memcpy(((uint8_t*)&i32)+1,p,sizeof(i32)-sizeof(uint8_t));
ziplist.c:574:        ret = (encoding & ZIP_INT_IMM_MASK)-1;
ziplist.c:597:    zl[bytes-1] = ZIP_END;
ziplist.c:605:    zl[len-1] = ZIP_END;
ziplist.c:611: * length cannot be encoded in 1 byte and the next entry needs to be grow
ziplist.c:668:                curlen-noffset-next.prevrawlensize-1);
ziplist.c:734:                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);
ziplist.c:762:    long long value = 123456789; /* initialized to avoid warning. Using a value
ziplist.c:798:        forcelarge = 1;
ziplist.c:809:        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
ziplist.c:850:    ZIPLIST_INCR_LENGTH(zl,1);
ziplist.c:879:    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
ziplist.c:882:    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
ziplist.c:896:        append = 1;
ziplist.c:911:    /* Combined zl length should be limited within UINT16_MAX */
ziplist.c:912:    zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;
ziplist.c:940:    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
ziplist.c:943:     *   - 1 byte for [END] of first ziplist
ziplist.c:982:        index = (-index)-1;
ziplist.c:1046: * Return 0 if 'p' points to the end of the ziplist, 1 otherwise. */
ziplist.c:1063:    return 1;
ziplist.c:1076:    zl = __ziplistDelete(zl,*p,1);
ziplist.c:1093:/* Return 1 if equal. */
ziplist.c:1183:    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
ziplist.c:1184:        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
ziplist.c:1193:        if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
ziplist.c:1213:        intrev16ifbe(ZIPLIST_LENGTH(zl)),
ziplist.c:1245:                if (fwrite(p,40,1,stdout) == 0) perror("fwrite");
ziplist.c:1249:                    fwrite(p,entry.len,1,stdout) == 0) perror("fwrite");
ziplist.c:1273:    zl = ziplistPush(zl, (unsigned char*)"1024", 4, ZIPLIST_TAIL);
ziplist.c:1279:    uint16_t len;
ziplist.c:1284:    memcpy(&len,zl,sizeof(uint16_t)) ;
ziplist.c:1285:    zl+=sizeof(uint16_t);
ziplist.c:1294:    sprintf(buf, "100");
ziplist.c:1297:    sprintf(buf, "128000");
ziplist.c:1300:    sprintf(buf, "-100");
ziplist.c:1314:    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
ziplist.c:1332:            zl = ziplistDeleteRange(zl,0,1);
ziplist.c:1345:    p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
ziplist.c:1353:            if (vlen && fwrite(vstr,vlen,1,stdout) == 0) perror("fwrite");
ziplist.c:1363:        exit(1);
ziplist.c:1369:    int len = min+rand()%(max-min+1);
ziplist.c:1376:    case 1:
ziplist.c:1378:        maxval = 122;
ziplist.c:1389:        target[p++] = minval+rand()%(maxval-minval+1);
ziplist.c:1418:        srand(atoi(argv[1]));
ziplist.c:1448:            return 1;
ziplist.c:1451:            if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1468:            return 1;
ziplist.c:1474:    printf("Get element at index -1 (last element):\n");
ziplist.c:1477:        p = ziplistIndex(zl, -1);
ziplist.c:1479:            printf("ERROR: Could not access index -1\n");
ziplist.c:1480:            return 1;
ziplist.c:1483:            if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1498:            return 1;
ziplist.c:1501:            if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1518:            return 1;
ziplist.c:1531:                if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1542:    printf("Iterate list from 1 to end:\n");
ziplist.c:1545:        p = ziplistIndex(zl, 1);
ziplist.c:1549:                if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1567:                if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1594:        p = ziplistIndex(zl, -1);
ziplist.c:1598:                if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1612:        p = ziplistIndex(zl, -1);
ziplist.c:1616:                if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
ziplist.c:1631:        zl = ziplistDeleteRange(zl, 0, 1);
ziplist.c:1636:    printf("Delete inclusive range 0,1:\n");
ziplist.c:1644:    printf("Delete inclusive range 1,2:\n");
ziplist.c:1647:        zl = ziplistDeleteRange(zl, 1, 2);
ziplist.c:1655:        zl = ziplistDeleteRange(zl, 5, 1);
ziplist.c:1663:        zl = ziplistDeleteRange(zl, 1, 5);
ziplist.c:1679:                    if (elen && fwrite(entry,elen,1,stdout) == 0)
ziplist.c:1695:        char v1[257] = {0}, v2[257] = {0};
ziplist.c:1696:        memset(v1,'x',256);
ziplist.c:1699:        zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
ziplist.c:1705:        assert(strncmp(v1,(char*)entry,elen) == 0);
ziplist.c:1706:        p = ziplistIndex(zl,1);
ziplist.c:1725:        v[1][  1] = '\0';
ziplist.c:1735:        assert(e[0].prevrawlensize == 1);
ziplist.c:1736:        assert(e[1].prevrawlensize == 5);
ziplist.c:1737:        assert(e[2].prevrawlensize == 1);
ziplist.c:1739:        /* Deleting entry 1 will increase `prevrawlensize` for entry 2 */
ziplist.c:1740:        unsigned char *p = e[1].p;
ziplist.c:1745:        assert(e[0].prevrawlensize == 1);
ziplist.c:1746:        assert(e[1].prevrawlensize == 5);
ziplist.c:1757:        for (i = 0; i < 1000; i++) {
ziplist.c:1761:        for (i = 0; i < 1000; i++) {
ziplist.c:1766:            p = ziplistIndex(zl,-i-1);
ziplist.c:1780:            return 1;
ziplist.c:1784:            return 1;
ziplist.c:1788:        if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
ziplist.c:1789:            printf("ERROR: not \"1024\"\n");
ziplist.c:1790:            return 1;
ziplist.c:1792:        if (ziplistCompare(p,(unsigned char*)"1025",4)) {
ziplist.c:1793:            printf("ERROR: \"1025\"\n");
ziplist.c:1794:            return 1;
ziplist.c:1802:        /* create list gives us: [hello, foo, quux, 1024] */
ziplist.c:1811:            return 1;
ziplist.c:1819:            return 1;
ziplist.c:1824:        /* merge gives us: [hello, foo, quux, 1024, hello, foo, quux, 1024] */
ziplist.c:1829:            return 1;
ziplist.c:1835:            return 1;
ziplist.c:1839:            return 1;
ziplist.c:1843:        if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
ziplist.c:1844:            printf("ERROR: not \"1024\"\n");
ziplist.c:1845:            return 1;
ziplist.c:1847:        if (ziplistCompare(p,(unsigned char*)"1025",4)) {
ziplist.c:1848:            printf("ERROR: \"1025\"\n");
ziplist.c:1849:            return 1;
ziplist.c:1855:            return 1;
ziplist.c:1859:            return 1;
ziplist.c:1863:        if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
ziplist.c:1864:            printf("ERROR: not \"1024\"\n");
ziplist.c:1865:            return 1;
ziplist.c:1867:        if (ziplistCompare(p,(unsigned char*)"1025",4)) {
ziplist.c:1868:            printf("ERROR: \"1025\"\n");
ziplist.c:1869:            return 1;
ziplist.c:1879:        char buf[1024];
ziplist.c:1897:                where = (rand() & 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
ziplist.c:1899:                    buflen = randstring(buf,1,sizeof(buf)-1);
ziplist.c:1905:                    case 1:
ziplist.c:1954:        stress(ZIPLIST_HEAD,100000,16384,256);
ziplist.c:1955:        stress(ZIPLIST_TAIL,100000,16384,256);
ziplist.h:2: * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
ziplist.h:3: * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
ziplist.h:35:#define ZIPLIST_TAIL 1
匹配到二进制文件 ziplist.out
zipmap.c:15: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
zipmap.c:47: * <zmlen> is 1 byte length that holds the current size of the zipmap.
zipmap.c:91: * for the integer value _l, that is, 1 byte for lengths < ZIPMAP_BIGLEN and
zipmap.c:93:#define ZIPMAP_LEN_BYTES(_l) (((_l) < ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)
zipmap.c:100:    zm[1] = ZIPMAP_END;
zipmap.c:109:    memcpy(&len,p+1,sizeof(unsigned int));
zipmap.c:122:            return 1;
zipmap.c:125:            memcpy(p+1,&len,sizeof(len));
zipmap.c:126:            memrev32ifbe(p+1);
zipmap.c:127:            return 1+sizeof(len);
zipmap.c:139:    unsigned char *p = zm+1, *k = NULL;
zipmap.c:162:        p += l+1+free; /* +1 to skip the free byte */
zipmap.c:164:    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;
zipmap.c:190:    used += p[used] + 1 + l;
zipmap.c:204:    zm[len-1] = ZIPMAP_END;
zipmap.c:209: * If 'update' is not NULL, *update is set to 1 if the key was
zipmap.c:223:        p = zm+zmlen-1;
zipmap.c:231:        if (update) *update = 1;
zipmap.c:241:            /* The +1 in the number of bytes to be moved is caused by the
zipmap.c:243:            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
zipmap.c:258:        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
zipmap.c:280: * set to 0 if the key was not found, to 1 if it was found and deleted. */
zipmap.c:286:        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
zipmap.c:292:        if (deleted) *deleted = 1;
zipmap.c:301:    return zm+1;
zipmap.c:305: * In the first call the first argument is the pointer to the zipmap + 1.
zipmap.c:324:        *value = zm+1;
zipmap.c:333: * If the key is found the function returns 1, otherwise 0. */
zipmap.c:340:    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
zipmap.c:341:    return 1;
zipmap.c:344:/* Return 1 if the key exists, otherwise 0 is returned. */
zipmap.c:378:    while(1) {
zipmap.c:388:            if (l != 0 && fwrite(p,l,1,stdout) == 0) perror("fwrite");
zipmap.c:395:            if (l != 0 && fwrite(p,l,1,stdout) == 0) perror("fwrite");
zipmap.c:423:    zm = zipmapSet(zm,(unsigned char*) "foo",3, (unsigned char*) "!",1,NULL);
zipmap.c:425:    zm = zipmapSet(zm,(unsigned char*) "foo",3, (unsigned char*) "12345",5,NULL);
zipmap.c:435:        unsigned char buf[512];
zipmap.c:438:        for (i = 0; i < 512; i++) buf[i] = 'a';
zipmap.c:440:        zm = zipmapSet(zm,buf,512,(unsigned char*) "long",4,NULL);
zipmap.c:441:        if (zipmapGet(zm,buf,512,&value,&vlen)) {
zipmap.h:7: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
zmalloc.c:3: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
zmalloc.c:76:    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
zmalloc.c:82:    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
zmalloc.c:131:    void *ptr = calloc(1, size+PREFIX_SIZE);
zmalloc.c:182:    if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));
zmalloc.c:209:    size_t l = strlen(s)+1;
zmalloc.c:251:    if ((fd = open(filename,O_RDONLY)) == -1) return 0;
zmalloc.c:269:    rss = strtoll(p,NULL,10);
zmalloc.c:298:     * Fragmentation will appear to be always 1 (no fragmentation)
zmalloc.c:308:    uint64_t epoch = 1;
zmalloc.c:324:    return 1;
zmalloc.c:331:    return 1;
zmalloc.c:340: * otherwise if pid is -1 the information is reported is about the
zmalloc.c:343: * Example: zmalloc_get_smap_bytes_by_field("Rss:",-1);
zmalloc.c:347:    char line[1024];
zmalloc.c:352:    if (pid == -1) {
zmalloc.c:355:        char filename[128];
zmalloc.c:366:                bytes += strtol(line+flen,NULL,10) * 1024;
zmalloc.c:389: * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system
zmalloc.c:392: * 1) Was released under the following CC attribution license:
zmalloc.c:405:    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
zmalloc.c:407:    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
zmalloc.c:424:    mib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */
zmalloc.c:426:    mib[1] = HW_PHYSMEM;        /* Others. ------------------ */
zmalloc.c:449:    ptr = zmalloc(123);
zmalloc.c:450:    printf("Allocated 123 bytes; used: %zu\n", zmalloc_used_memory());
zmalloc.h:3: * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
zmalloc.h:41:#if (TC_VERSION_MAJOR == 1 && TC_VERSION_MINOR >= 6) || (TC_VERSION_MAJOR > 1)
zmalloc.h:42:#define HAVE_MALLOC_SIZE 1
zmalloc.h:51:#if (JEMALLOC_VERSION_MAJOR == 2 && JEMALLOC_VERSION_MINOR >= 1) || (JEMALLOC_VERSION_MAJOR > 2)
zmalloc.h:52:#define HAVE_MALLOC_SIZE 1
zmalloc.h:60:#define HAVE_MALLOC_SIZE 1
zmalloc.h:68:#define HAVE_MALLOC_SIZE 1
